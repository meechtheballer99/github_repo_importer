[
  {
    "repo": "CIS-310",
    "folder": ".",
    "code_files": [
      ".\\ProgramTemplate.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ProgramTemplate.asm",
        "snippet": "; Program Template (Template.asm)\n; Program Description:\n; Author:\n; Creation Date:\n; Revisions:\n; Date: Modified by:\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess PROTO, dwExitCode:DWORD\n.data\n; declare variables here\n.code\nmain PROC\n; write your code here\nINVOKE ExitProcess,0\nmain ENDP\n; (insert additional procedures here)\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\b16.asm",
        "snippet": "TITLE      (.asm)\n\n; This program\n; Last update:\n\nINCLUDE Irvine16.inc\n.data\n\n.code\nmain PROC\n\tmov ax,@data\n\tmov ds,ax\n\n\n\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\b32.asm",
        "snippet": "TITLE      (.asm)\n\n; This program\n; Last update:\n\nINCLUDE Irvine32.inc\n.data\n\n.code\nmain PROC\n\n\n\n\n\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\b16.asm",
        "snippet": "TITLE      (.asm)\n\n; This program\n; Last update:\n\nINCLUDE Irvine16.inc\n.data\n\n.code\nmain PROC\n\tmov ax,@data\n\tmov ds,ax\n\n\n\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\b32.asm",
        "snippet": "TITLE      (.asm)\n\n; This program\n; Last update:\n\nINCLUDE Irvine32.inc\n.data\n\n.code\nmain PROC\n\n\n\n\n\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\C progs\\ExecuteShell\\Source.cpp",
        "snippet": "#include <cstdlib>\n\nint main()\n{\n\tsystem( \"dir\" );\n}"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\16-bit.asm",
        "snippet": "TITLE Add and Subtract              (16-bit.asm)\n\n; This program adds and subtracts 32-bit integers.\n\nINCLUDE Irvine16.inc\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\n\tmov\teax,10000h\t\t; EAX = 10000h\n\tadd\teax,40000h\t\t; EAX = 50000h\n\tsub\teax,20000h\t\t; EAX = 30000h\n\tcall\tDumpRegs\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddSub2.asm",
        "snippet": "TITLE Add and Subtract, Version 2         (AddSub2.asm)\n\n; This program adds and subtracts 32-bit integers\n; and stores the sum in a variable.\n\nINCLUDE Irvine32.inc\n\n.data\nval1     dword  10000h\nval2     dword  40000h\nval3     dword  20000h\nfinalVal dword  ?\n\n.code\nmain PROC\n\n\tmov\teax,val1\t\t\t; start with 10000h\n\tadd\teax,val2\t\t\t; add 40000h\n\tsub\teax,val3\t\t\t; subtract 20000h\n\tmov\tfinalVal,eax\t\t; store the result (30000h)\n\tcall\tDumpRegs\t\t\t; display the registers\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwo.asm",
        "snippet": "; AddTwo.asm - adds two 32-bit integers.\n; Chapter 3 example\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwoSum.asm",
        "snippet": "; AddTwoSum.asm - Chapter 3 example.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\nsum dword 0\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\tmov sum,eax\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\b16.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\b32.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\b16.asm",
        "snippet": "TITLE      (.asm)\n\n; This program\n; Last update:\n\nINCLUDE Irvine16.inc\n.data\n\n.code\nmain PROC\n\tmov ax,@data\n\tmov ds,ax\n\n\n\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\b32.asm",
        "snippet": "TITLE      (.asm)\n\n; This program\n; Last update:\n\nINCLUDE Irvine32.inc\n.data\n\n.code\nmain PROC\n\n\n\n\n\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\b16.asm",
        "snippet": "TITLE      (.asm)\n\n; This program\n; Last update:\n\nINCLUDE Irvine16.inc\n.data\n\n.code\nmain PROC\n\tmov ax,@data\n\tmov ds,ax\n\n\n\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\b32.asm",
        "snippet": "TITLE      (.asm)\n\n; This program\n; Last update:\n\nINCLUDE Irvine32.inc\n.data\n\n.code\nmain PROC\n\n\n\n\n\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\C progs\\ExecuteShell\\Source.cpp",
        "snippet": "#include <cstdlib>\n\nint main()\n{\n\tsystem( \"dir\" );\n}"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\16-bit.asm",
        "snippet": "TITLE Add and Subtract              (16-bit.asm)\n\n; This program adds and subtracts 32-bit integers.\n\nINCLUDE Irvine16.inc\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\n\tmov\teax,10000h\t\t; EAX = 10000h\n\tadd\teax,40000h\t\t; EAX = 50000h\n\tsub\teax,20000h\t\t; EAX = 30000h\n\tcall\tDumpRegs\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddSub2.asm",
        "snippet": "TITLE Add and Subtract, Version 2         (AddSub2.asm)\n\n; This program adds and subtracts 32-bit integers\n; and stores the sum in a variable.\n\nINCLUDE Irvine32.inc\n\n.data\nval1     dword  10000h\nval2     dword  40000h\nval3     dword  20000h\nfinalVal dword  ?\n\n.code\nmain PROC\n\n\tmov\teax,val1\t\t\t; start with 10000h\n\tadd\teax,val2\t\t\t; add 40000h\n\tsub\teax,val3\t\t\t; subtract 20000h\n\tmov\tfinalVal,eax\t\t; store the result (30000h)\n\tcall\tDumpRegs\t\t\t; display the registers\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwo.asm",
        "snippet": "; AddTwo.asm - adds two 32-bit integers.\n; Chapter 3 example\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwoSum.asm",
        "snippet": "; AddTwoSum.asm - Chapter 3 example.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\nsum dword 0\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\tmov sum,eax\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwoSum_64.asm",
        "snippet": "; AddTwoSum_64.asm - Chapter 3 example.\n\nExitProcess proto\n\n.data\nsum qword 0\n\n.code\nmain proc\n\tmov\t  rax,5\n\tadd\t  rax,6\n\tmov   sum,rax\n\n\tmov   ecx,0\n\tcall  ExitProcess\nmain endp\nend"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\b16.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\b32.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\b16.asm",
        "snippet": "TITLE      (.asm)\n\n; This program\n; Last update:\n\nINCLUDE Irvine16.inc\n.data\n\n.code\nmain PROC\n\tmov ax,@data\n\tmov ds,ax\n\n\n\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\b32.asm",
        "snippet": "TITLE      (.asm)\n\n; This program\n; Last update:\n\nINCLUDE Irvine32.inc\n.data\n\n.code\nmain PROC\n\n\n\n\n\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\C progs\\ExecuteShell\\Source.cpp",
        "snippet": "#include <cstdlib>\n\nint main()\n{\n\tsystem( \"dir\" );\n}"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\16-bit.asm",
        "snippet": "TITLE Add and Subtract              (16-bit.asm)\n\n; This program adds and subtracts 32-bit integers.\n\nINCLUDE Irvine16.inc\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\n\tmov\teax,10000h\t\t; EAX = 10000h\n\tadd\teax,40000h\t\t; EAX = 50000h\n\tsub\teax,20000h\t\t; EAX = 30000h\n\tcall\tDumpRegs\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddSub2.asm",
        "snippet": "TITLE Add and Subtract, Version 2         (AddSub2.asm)\n\n; This program adds and subtracts 32-bit integers\n; and stores the sum in a variable.\n\nINCLUDE Irvine32.inc\n\n.data\nval1     dword  10000h\nval2     dword  40000h\nval3     dword  20000h\nfinalVal dword  ?\n\n.code\nmain PROC\n\n\tmov\teax,val1\t\t\t; start with 10000h\n\tadd\teax,val2\t\t\t; add 40000h\n\tsub\teax,val3\t\t\t; subtract 20000h\n\tmov\tfinalVal,eax\t\t; store the result (30000h)\n\tcall\tDumpRegs\t\t\t; display the registers\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwo.asm",
        "snippet": "; AddTwo.asm - adds two 32-bit integers.\n; Chapter 3 example\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwoSum.asm",
        "snippet": "; AddTwoSum.asm - Chapter 3 example.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\nsum dword 0\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\tmov sum,eax\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwoSum_64.asm",
        "snippet": "; AddTwoSum_64.asm - Chapter 3 example.\n\nExitProcess proto\n\n.data\nsum qword 0\n\n.code\nmain proc\n\tmov\t  rax,5\n\tadd\t  rax,6\n\tmov   sum,rax\n\n\tmov   ecx,0\n\tcall  ExitProcess\nmain endp\nend"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddVariables.asm",
        "snippet": "; AddVariables.asm - Chapter 3 example.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\nfirstval  dword 20002000h\nsecondval dword 11111111h\nthirdval  dword 22222222h\nsum dword 0\n\n.code\nmain proc\n\tmov\teax,firstval\t\t\t\t\n\tadd\teax,secondval\t\t\n\tadd eax,thirdval\n\tmov sum,eax\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\template.asm",
        "snippet": "; Program template\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\n\t; declare variables here\n.code\nmain proc\n\t; write your code here\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\C progs\\ExecuteShell",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\C progs\\ExecuteShell\\Source.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\C progs\\ExecuteShell\\Source.cpp",
        "snippet": "#include <cstdlib>\n\nint main()\n{\n\tsystem( \"dir\" );\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\16-bit.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddSub2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwo.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwoSum.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwoSum_64.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddVariables.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\template.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\16-bit.asm",
        "snippet": "TITLE Add and Subtract              (16-bit.asm)\n\n; This program adds and subtracts 32-bit integers.\n\nINCLUDE Irvine16.inc\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\n\tmov\teax,10000h\t\t; EAX = 10000h\n\tadd\teax,40000h\t\t; EAX = 50000h\n\tsub\teax,20000h\t\t; EAX = 30000h\n\tcall\tDumpRegs\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddSub2.asm",
        "snippet": "TITLE Add and Subtract, Version 2         (AddSub2.asm)\n\n; This program adds and subtracts 32-bit integers\n; and stores the sum in a variable.\n\nINCLUDE Irvine32.inc\n\n.data\nval1     dword  10000h\nval2     dword  40000h\nval3     dword  20000h\nfinalVal dword  ?\n\n.code\nmain PROC\n\n\tmov\teax,val1\t\t\t; start with 10000h\n\tadd\teax,val2\t\t\t; add 40000h\n\tsub\teax,val3\t\t\t; subtract 20000h\n\tmov\tfinalVal,eax\t\t; store the result (30000h)\n\tcall\tDumpRegs\t\t\t; display the registers\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwo.asm",
        "snippet": "; AddTwo.asm - adds two 32-bit integers.\n; Chapter 3 example\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwoSum.asm",
        "snippet": "; AddTwoSum.asm - Chapter 3 example.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\nsum dword 0\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\tmov sum,eax\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddTwoSum_64.asm",
        "snippet": "; AddTwoSum_64.asm - Chapter 3 example.\n\nExitProcess proto\n\n.data\nsum qword 0\n\n.code\nmain proc\n\tmov\t  rax,5\n\tadd\t  rax,6\n\tmov   sum,rax\n\n\tmov   ecx,0\n\tcall  ExitProcess\nmain endp\nend"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\AddVariables.asm",
        "snippet": "; AddVariables.asm - Chapter 3 example.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\nfirstval  dword 20002000h\nsecondval dword 11111111h\nthirdval  dword 22222222h\nsum dword 0\n\n.code\nmain proc\n\tmov\teax,firstval\t\t\t\t\n\tadd\teax,secondval\t\t\n\tadd eax,thirdval\n\tmov sum,eax\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\template.asm",
        "snippet": "; Program template\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\n\t; declare variables here\n.code\nmain proc\n\t; write your code here\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\64 bit\\AddTwoSum_64.asm",
        "snippet": "; AddTwoSum_64.asm - Chapter 3 example.\n\nExitProcess proto\n\n.data\nsum qword 0\n\n.code\nmain proc\n\tmov\trax,5\n\tadd\trax,6\n\tmov   sum,rax\n\n\tmov   ecx,0\n\tcall  ExitProcess\n\nmain endp\nend"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\64 bit\\template_64.asm",
        "snippet": "; 64-bit Assembly Language template \n; Use this when not calling subroutines.\n\nExitProcess proto\n\n.data\n; Declare your variables here.\n\n.code\nmain proc\n\n\n\n\tmov   ecx,0\t\t\t; assign a process return code\n\tcall  ExitProcess\t; terminate the program\nmain endp\nend"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\64 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\64 bit\\AddTwoSum_64.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\64 bit\\template_64.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\64 bit\\AddTwoSum_64.asm",
        "snippet": "; AddTwoSum_64.asm - Chapter 3 example.\n\nExitProcess proto\n\n.data\nsum qword 0\n\n.code\nmain proc\n\tmov\trax,5\n\tadd\trax,6\n\tmov   sum,rax\n\n\tmov   ecx,0\n\tcall  ExitProcess\n\nmain endp\nend"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch03\\64 bit\\template_64.asm",
        "snippet": "; 64-bit Assembly Language template \n; Use this when not calling subroutines.\n\nExitProcess proto\n\n.data\n; Declare your variables here.\n\n.code\nmain proc\n\n\n\n\tmov   ecx,0\t\t\t; assign a process return code\n\tcall  ExitProcess\t; terminate the program\nmain endp\nend"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\AdditionTest.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\CopyStr.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\Moves.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\Operator.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\Pointers.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\SumArray.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\template.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\AdditionTest.asm",
        "snippet": "; Addition and Subtraction\t\t\t\t\t(AddSubTest.asm)\n\n; Chapter 4 example. Demonstration of ADD, SUB,\n; INC, DEC, and NEG instructions, and how\n; they affect the CPU status flags.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\nRval   SDWORD ?\nXval   SDWORD 26\nYval   SDWORD 30\nZval   SDWORD 40\n\n.code\nmain proc\n\t; INC and DEC\n\tmov\tax,1000h\n\tinc\tax\t\t; 1001h\n\tdec\tax\t\t; 1000h\n\n\t; Expression: Rval = -Xval + (Yval - Zval)\n\tmov\teax,Xval\n\tneg\teax\t\t\t; -26\n\tmov\tebx,Yval\n\tsub\tebx,Zval\t; -10\n\tadd\teax,ebx\n\tmov\tRval,eax\t; -36\n\n\t; Zero flag example:\n\tmov\tcx,1\n\tsub\tcx,1\t\t; ZF = 1\n\tmov\tax,0FFFFh\n\tinc\tax\t\t\t; ZF = 1\n\n\t; Sign flag example:\n\tmov\tcx,0"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\CopyStr.asm",
        "snippet": "; Copying a String (CopyStr.asm)\n\n; This program copies a string.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess PROTO, dwExitCode:dword\n\n.data\nsource  byte  \"This is the source string\",0\ntarget  byte  SIZEOF source DUP(0),0\n\n.code\nmain proc\n\n\tmov  esi,0\t\t\t\t; index register\n\tmov  ecx,SIZEOF source\t; loop counter\nL1:\n\tmov  al,source[esi]\t\t; get a character from source\n\tmov  target[esi],al\t\t; store it in the target\n\tinc  esi\t\t\t\t; move to next character\n\tloop L1\t\t\t\t\t; repeat for entire string\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\Moves.asm",
        "snippet": "; Data Transfer Examples       (Moves.asm)\n\n; Chapter 4 example. Demonstration of MOV and\n; XCHG with direct and direct-offset operands.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess PROTO, dwExitCode:dword\n\n.data\nval1  WORD 1000h\nval2  WORD 2000h\n\narrayB BYTE  10h,20h,30h,40h,50h\narrayW WORD  100h,200h,300h\narrayD DWORD 10000h,20000h\n\n.code\nmain proc\n\n;  MOVZX\n\tmov    bx,0A69Bh\n\tmovzx  eax,bx\t\t; EAX = 0000A69Bh\n\tmovzx  edx,bl\t\t; EDX = 0000009Bh\n\tmovzx  cx,bl\t\t; CX  = 009Bh\n\n;  MOVSX\n\tmov   bx,0A69Bh\n\tmovsx eax,bx\t\t; EAX = FFFFA69Bh\n\tmovsx edx,bl\t\t; EDX = FFFFFF9Bh\n\tmov\t bl,7Bh\n\tmovsx cx,bl\t\t; CX  = 007Bh\n\n;  Memory-to-memory exchange:\n\tmov  ax,val1\t\t; AX = 1000h\n\txchg ax,val2\t\t; AX = 2000h, val2 = 1000h\n\tmov  val1,ax\t\t; val1 = 2000h\n\n;  Direct-Offset Addressing (byte array):"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\Operator.asm",
        "snippet": "; Operators (Operator.asm)\n\n; Demonstrates the TYPE, LENGTHOF, and SIZEOF operators\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess PROTO, dwExitCode:dword\n\n.data\nbyte1    BYTE  10,20,30\narray1   WORD  30 DUP(?),0,0\narray2   WORD  5 DUP(3 DUP(?))\narray3   DWORD 1,2,3,4\ndigitStr BYTE  '12345678',0\nmyArray  BYTE  10,20,30,40,50,\n               60,70,80,90,100\n\n; You can examine the following constant values\n; by looking in the listing file (Operator.lst):\n;---------------------------------------------\nX = LENGTHOF byte1\t\t; 3\nX = LENGTHOF array1\t\t; 30 + 2\nX = LENGTHOF array2\t\t; 5 * 3\nX = LENGTHOF array3\t\t; 4\nX = LENGTHOF digitStr\t; 9\nX = LENGTHOF myArray\t; 10\n\nX = SIZEOF byte1\t\t; 1 * 3\nX = SIZEOF array1\t\t; 2 * (30 + 2)\nX = SIZEOF array2\t\t; 2 * (5 * 3)\nX = SIZEOF array3\t\t; 4 * 4\nX = SIZEOF digitStr\t\t; 1 * 9\n\n.code\nmain PROC"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\Pointers.asm",
        "snippet": "; Pointers (Pointers.asm)\n\n; Demonstration of pointers and TYPEDEF.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess PROTO, dwExitCode:dword\n\n; Create user-defined types.\nPBYTE  TYPEDEF PTR BYTE\t\t; pointer to bytes\nPWORD  TYPEDEF PTR WORD\t\t; pointer to words\nPDWORD TYPEDEF PTR DWORD\t\t; pointer to doublewords\n\n.data\narrayB BYTE  10h,20h,30h\narrayW WORD  1,2,3\narrayD DWORD 4,5,6\n\n; Create some pointer variables.\nptr1 PBYTE  arrayB\nptr2 PWORD  arrayW\nptr3 PDWORD arrayD\n\n.code\nmain PROC\n\n; Use the pointers to access data.\n\tmov esi,ptr1\n\tmov al,[esi]\t\t; 10h\n\tmov esi,ptr2\n\tmov ax,[esi]\t\t; 1\n\tmov esi,ptr3\n\tmov eax,[esi]\t\t; 4\n\n\tinvoke ExitProcess,0\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\SumArray.asm",
        "snippet": "; Summing an Array (SumArray.asm)\n\n; This program sums an array of words.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess PROTO, dwExitCode:dword\n\n.data\nintarray DWORD 10000h,20000h,30000h,40000h\n\n.code\nmain proc\n\n\tmov  edi,OFFSET intarray\t\t; 1: EDI = address of intarray\n\tmov  ecx,LENGTHOF intarray\t\t; 2: initialize loop counter\n\tmov  eax,0\t\t\t\t\t\t; 3: sum = 0\nL1:\t\t\t\t\t\t\t\t\t; 4: mark beginning of loop\n\tadd  eax,[edi]\t\t\t\t\t; 5: add an integer\n\tadd  edi,TYPE intarray   \t\t; 6: point to next element\n\tloop L1\t\t\t\t\t\t\t; 7: repeat until ECX = 0\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\32 bit\\template.asm",
        "snippet": "; Program template\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\n\t; declare variables here\n.code\nmain proc\n\t; write your code here\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\64 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\64 bit\\AddAndSubtract.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\64 bit\\Moves.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\64 bit\\SumArray_64.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\64 bit\\AddAndSubtract.asm",
        "snippet": "; Moves.asm  - Testing the 64-bit move operations\n\nExitProcess proto\n\n.data\ninitval qword 0\nmyByte byte 55h\nmyWord word 6666h\nmyDword dword 80000000h\n\n.code\nmain proc\n; Moving immediate values:\n\tmov  rax,0FFFFFFFFh\n\tadd  rax,1\t\t\t\t\t; RAX = 100000000h\n\t\n\tmov  rax,0FFFFh\n\tmov  bx,1\n\tadd  ax,bx\t\t\t\t\t; RAX = 0\n\t\n\tmov  rax,0\n\tmov  ebx,1\n\tsub  eax,ebx\t\t\t\t; RAX = 00000000FFFFFFFF\n\n\tmov  rax,0\n\tmov  bx,1\n\tsub  ax,bx\t\t\t\t\t; RAX = 000000000000FFFF\n\n\tmov  rax,0FFh\n\tmov  bl,1\n\tadd  al,bl\t\t\t\t\t; RAX = 0\n\t\n\tmov  rcx,OFFSET myByte\n\tinc  BYTE PTR [rcx]\t\t\t\t\t; requires BYTE PTR\n\tdec  BYTE PTR [rcx]\n\t\n\t\n\t\n\tmov   ecx,0\n\tcall  ExitProcess"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\64 bit\\Moves.asm",
        "snippet": "; Moves.asm  - Testing the 64-bit move operations\n\nExitProcess proto\n\n.data\nmessage BYTE \"Welcome to my 64-bit Library!\",0\nmaxuint qword 0FFFFFFFFFFFFFFFFh\nmyByte byte 55h\nmyWord word 6666h\nmyDword dword 80000000h\n\n.code\nmain proc\n; Moving immediate values:\n\tmov  rax,maxuint\t\t; fill all bits in RAX\n\tmov  rax,81111111h\t\t; clears bits 32-63 (no sign extension)\n\tmov  rax,06666h\t\t\t; clears bits 16-63\n\tmov  rax,055h\t\t\t; clears bits 8-63\n\n; Moving memory operands:\n\tmov  rax,maxuint\t\t; fill all bits in RAX\n\tmov  eax,myDword\t\t; clears bits 32-63 (no sign extension)\n\tmov  ax,myWord\t\t\t; affects only bits 0-15\n\tmov  al,myByte\t\t\t; affects only bits 0-7\n\n; 32-bit sign extension works like this\n\tmov   myWord,8111h\t\t; make it negative\n\tmovsx eax,myWord\t\t\t; EAX = FFFF8111h\n\n; The MOVSXD instruction (move with sign-extension) permits the \n; source operand to be a 32-bit register or memory operand:\n\tmov     ebx,0FFFFFFFFh\n\tmovsxd  rax,ebx\t\t\t\t; rax = FFFFFFFFFFFFFFFF\t\n\n\tmov   ecx,0\n\tcall  ExitProcess\nmain endp\n\nend"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch04\\64 bit\\SumArray_64.asm",
        "snippet": "; Summing an Array (SumArray_64.asm)\n; This program sums an array of words.\n; The LOOP instruction requires the /LARGEADDRESSAWARE linker switch to equal NO.\n\nExitProcess proto\n.data\nintarray QWORD 1000000000000h,2000000000000h\n\t     QWORD 3000000000000h,4000000000000h\n\n.code\nmain proc\n\n\tmov  rdi,OFFSET intarray\t\t; 1: RDI = address of intarray\n\tmov  rcx,LENGTHOF intarray\t\t; 2: initialize loop counter\n\tmov  rax,0\t\t\t\t\t\t; 3: sum = 0\nL1:\t\t\t\t\t\t\t\t\t; 4: mark beginning of loop\n\tadd  rax,[rdi]\t\t\t\t\t; 5: add an integer\n\tadd  rdi,TYPE intarray   \t\t; 6: point to next element\n\tloop L1\t\t\t\t\t\t\t; 7: repeat until RCX = 0\n\n\tmov  ecx,0\t\t\t\t\t\t; ExitProcess return value\n\tcall ExitProcess\nmain endp\nend"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\CodePageDemo.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\colors.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\InputLoop.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\msgbox.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\msgboxAsk.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\RevStr.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\TestArraySum.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\TestLib1.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\TestLib2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\TestLib3.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\CodePageDemo.asm",
        "snippet": "; CodePageDemo.asm\n\n; Displays character codes 1 to 255. Select from the\n; following codepages for single-byte character sets:\n; 1250 - Central Europe\n; 1251 - Cyrillic\n; 1252 - Latin I\n; 1253 - Greek\n; 1254 - Turkish\n; 1255 - Hebrew\n; 1256 - Arabic\n; 1247 - Baltic\n; 1258 - Vietnam\n; 874  - Thai\n; 437  - OEM United States\n; 858  - OEM Multilingual Latin and European\n\nINCLUDE Irvine32.inc\nSetConsoleOutputCP PROTO, pageNum:DWORD\n\n.data\ndivider    BYTE \" - \",0\ncodepage   DWORD 1252\n\n.code\nmain PROC\n\tinvoke SetConsoleOutputCP, codePage\n\n\tmov  ecx,255\n\tmov  eax,1\n\tmov  edx,OFFSET divider\nL1:\t\n\tcall\tWriteDec\t\t; EAX is a counter\n\tcall\tWriteString\t; EDX points to string\n\tcall\tWriteChar\t\t; AL is the character\n\tcall Crlf\n\tinc  al\t\t\t; next character\n\tLoop L1\n\n\texit"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\colors.asm",
        "snippet": "; Testing Colors\t(colors.asm)\n\n; Testing SetTextColor and GetTextColor.\n\nINCLUDE Irvine32.inc\n\n.data\nstr1 BYTE \"Sample string, in color\",0dh,0ah,0\n\n.code\nmain PROC\n\n\tmov\tax,yellow + (blue * 16)\n\tcall\tSetTextColor\n\t\n\tmov\tedx,OFFSET str1\n\tcall\tWriteString\n\t\n\tcall\tGetTextColor\n\tcall\tDumpRegs\n\n\texit\nmain ENDP\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\InputLoop.asm",
        "snippet": "; Library Test #1: Integer I/O   (InputLoop.asm)\n\n; Tests the Clrscr, Crlf, DumpMem, ReadInt, SetTextColor, \n; WaitMsg, WriteBin, WriteHex, and WriteString procedures.\n\nINCLUDE Irvine32.inc\n\n.data\nCOUNT = 4\nBlueTextOnGray = blue + (lightGray * 16)\nDefaultColor = lightGray + (black * 16)\n\narrayD SDWORD 12345678h,1A4B2000h,3434h,7AB9h\n\nprompt BYTE \"Enter a 32-bit signed integer: \",0\n\n.code\nmain PROC\n\n; Set text color to blue text on a light gray background\n\n     mov   eax,BlueTextOnGray\n\tcall  SetTextColor\n\tcall  Clrscr\t\t\t; clear the screen\n\t\n\t; Display an array using DumpMem.\n\t\n\tmov\tesi,OFFSET arrayD\t; starting OFFSET\n\tmov\tebx,TYPE arrayD\t; doubleword = 4 bytes\n\tmov\tecx,LENGTHOF arrayD\t; number of units in arrayD\n\tcall\tDumpMem\t\t\t; display memory\n\n     ; Ask the user to input a sequence of signed integers\t\n     \n\tcall\t Crlf\t\t\t; new line\n     mov   ecx,COUNT\n    \nL1:  mov   edx,OFFSET prompt\n     call  WriteString\n     call  ReadInt\t\t\t; input integer into EAX"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\msgbox.asm",
        "snippet": "; MsgBox demo                     (msgbox.asm)\n\nINCLUDE Irvine32.inc\n\n.data\ncaption db \"Dialog Title\", 0 \n\nHelloMsg BYTE \"This is a pop-up message box.\", 0dh,0ah \n\t    BYTE \"Click OK to continue...\", 0 \n\n.code\nmain PROC\n\n\tmov\tebx,0\t\t\t\t; no caption\n\tmov\tedx,OFFSET HelloMsg\t\t; contents\n\tcall\tMsgBox\n\n\tmov\tebx,OFFSET caption\t\t; caption\n\tmov\tedx,OFFSET HelloMsg\t\t; contents\n\tcall\tMsgBox\n\n\texit\nmain ENDP\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\msgboxAsk.asm",
        "snippet": "; MsgBoxAsk demo                     (msgboxAsk.asm)\n\nINCLUDE Irvine32.inc\n\n.data\ncaption BYTE \"Survey Completed\",0\nquestion BYTE \"Thank you for completing the survey.\"\n\tBYTE 0dh,0ah\n\tBYTE \"Would you like to receive the results?\",0\nresults BYTE \"The results will be sent via email.\",0dh,0ah,0\n\n.code\nmain PROC\n\n\tmov ebx,OFFSET caption\n\tmov edx,OFFSET question\n\tcall MsgBoxAsk\n\t;(check return value in EAX)\n\n\texit\nmain ENDP\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\RevStr.asm",
        "snippet": "; Reversing a String (RevStr.asm)\n; This program reverses a string.\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\naName byte \"Abraham Lincoln\",0\nnameSize = ($ - aName) - 1\n\n.code\nmain proc\n\n; Push the name on the stack.\n\nmov\t ecx,nameSize\n\tmov\t esi,0\n\nL1:\tmovzx eax,aName[esi]\t; get character\n\tpush eax\t\t\t\t; push on stack\n\tinc\t esi\n\tloop L1\n\n; Pop the name from the stack in reverse\n; and store it in the aName array.\n\nmov\t ecx,nameSize\n\tmov\t esi,0\n\nL2:\tpop  eax\t\t\t\t; get character\n\tmov\t aName[esi],al\t\t; store in string\n\tinc\t esi\n\tloop L2\n\n\tInvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\TestArraySum.asm",
        "snippet": "; Testing the ArraySum procedure\t(TestArraySum.asm)\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess PROTO, dwExitCode:dword\n\n.data\narray dword 10000h,20000h,30000h,40000h,50000h\ntheSum dword ?\n\n.code\nmain proc\n\tmov   esi,OFFSET array \t\t\t; ESI points to array\n\tmov   ecx,LENGTHOF array\t\t; ECX = array count\n\tcall  ArraySum\t\t\t\t\t; calculate the sum\n\tmov   theSum,eax\t\t\t\t; returned in EAX\n\n\tinvoke ExitProcess,0\nmain endp\n\t\t\n;-----------------------------------------------------\nArraySum proc\n;\n; Calculates the sum of an array of 32-bit integers.\n; Receives: ESI = the array offset\n; ECX = number of elements in the array\n; Returns: EAX = sum of the array elements\n;-----------------------------------------------------\n\tpush  esi \t\t\t\t; save ESI, ECX\n\tpush  ecx\n\tmov   eax,0\t\t\t\t; set the sum to zero\n\nL1:\n\tadd   eax,[esi]\t\t\t; add each integer to sum\n\tadd   esi,TYPE DWORD\t; point to next integer\n\tloop  L1\t\t\t\t; repeat for array size\n\tpop   ecx\t\t\t\t; restore ECX, ESI\n\tpop   esi\n\tret \t\t\t\t\t; sum is in EAX"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\TestLib1.asm",
        "snippet": "; Library Test #1: Integer I/O   (TestLib1.asm)\n\n; Tests the Clrscr, Crlf, DumpMem, ReadInt, \n; SetTextColor, WaitMsg, WriteBin, WriteHex, \n; and WriteString procedures.\n\nINCLUDE Irvine32.inc\n.data\narrayD     DWORD 1000h,2000h,3000h\nprompt1    BYTE \"Enter a 32-bit signed integer: \",0\ndwordVal   DWORD ?\n\n.code\nmain PROC\n; Set text color to yellow text on blue background:\n\tmov\teax,yellow + (blue * 16)\n\tcall\tSetTextColor\n\tcall\tClrscr\t\t\t; clear the screen\n\n; Display the array using DumpMem.\n\tmov\tesi,OFFSET arrayD\t; starting OFFSET\n\tmov\tecx,LENGTHOF arrayD\t; number of units in dwordVal\n\tmov\tebx,TYPE arrayD\t; size of a doubleword\n\tcall\tDumpMem\t\t\t; display memory\n\tcall\tCrlf\t\t\t\t; new line\n\n; Ask the user to input a signed decimal integer.\n\tmov\tedx,OFFSET prompt1\n\tcall\tWriteString\n\tcall\tReadInt\t\t\t; input the integer\n\tmov\tdwordVal,eax\t\t; save in a variable\n\n; Display the integer in decimal, hexadecimal, and binary.\n\tcall\tCrlf\t\t\t\t; new line\n\tcall\tWriteInt\t\t\t; display in signed decimal\n\tcall\tCrlf\n\tcall\tWriteHex\t\t\t; display in hexadecimal\n\tcall\tCrlf\n\tcall\tWriteBin\t\t\t; display in binary\n\tcall\tCrlf"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\TestLib2.asm",
        "snippet": "; Link Library Test #2\t(TestLib2.asm)\n\n; Testing the Irvine32 Library procedures.\n\nINCLUDE Irvine32.inc\n\nTAB = 9\t\t; ASCII code for Tab\n\n.code\nmain PROC\n\tcall\tRandomize\t\t; init random generator\n\tcall\tRand1\n\tcall\tRand2\n\texit\nmain ENDP\n\nRand1 PROC\n; Generate ten pseudo-random integers.\n\tmov\tecx,10\t\t; loop 10 times\n\t\nL1:\tcall\tRandom32\t\t; generate random int\n\tcall\tWriteDec\t\t; write in unsigned decimal\n\tmov\tal,TAB\t\t; horizontal tab\n\tcall\tWriteChar\t\t; write the tab\n\tloop\tL1\n\n\tcall\tCrlf\n\tret\nRand1 ENDP\n\nRand2 PROC\n; Generate ten pseudo-random integers between -50 and +49\n\tmov\tecx,10\t\t; loop 10 times\n\t\nL1:\tmov\teax,100\t\t; values 0-99\n\tcall\tRandomRange\t; generate random int\n\tsub\teax,50\t\t; vaues -50 to +49\n\tcall\tWriteInt\t\t; write signed decimal\n\tmov\tal,TAB\t\t; horizontal tab\n\tcall\tWriteChar\t\t; write the tab"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\32 bit\\TestLib3.asm",
        "snippet": "; Link Library Test #3\t\t(TestLib3.asm)\n\n; Calculate the elapsed execution time of a nested loop\n\nINCLUDE Irvine32.inc\n\n.data\nOUTER_LOOP_COUNT = 3\nstartTime DWORD ?\nmsg1 BYTE \"Please wait...\",0dh,0ah,0\nmsg2 BYTE \"Elapsed milliseconds: \",0\n\n.code\nmain PROC\n\tmov\tedx,OFFSET msg1     ; \"Please wait...\"\n\tcall\tWriteString\n\n; Save the starting time\n\n\tcall\tGetMSeconds\n\tmov\tstartTime,eax\n\t\n; Start the outer loop\n\n\tmov\tecx,OUTER_LOOP_COUNT \t\n\t\nL1:\tcall\tinnerLoop\n\tloop\tL1\n\n; Calculate the elapsed time\n\n\tcall\tGetMSeconds\n\tsub\teax,startTime\n\t\n; Display the elapsed time\n\t\n\tmov\tedx,OFFSET msg2     ; \"Elapsed milliseconds: \"\n\tcall\tWriteString\n\tcall\tWriteDec            ; write the milliseconds\n\tcall\tCrlf"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\64 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\64 bit\\CallProc_64.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\64 bit\\Lib64test.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\64 bit\\TestRandom.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\64 bit\\CallProc_64.asm",
        "snippet": "; Calling a subroutine in 64-bit mode\t\t\t(CallProc_64.asm)\n\nextrn ExitProcess: PROC\n\n.code\nmain proc\n\tsub  rsp,8           ; align the stack pointer\n\tsub  rsp,20h\t\t\t; reserve 32 bytes for shadow parameters\n\n\tmov  rcx,1\t\t\t\t; pass four parameters, in order\n\tmov  rdx,2\n\tmov  r8,3\n\tmov  r9,4\n\tcall AddFour\t\t; look for return value in RAX\n\n\tmov  ecx,0\n\tcall ExitProcess\nmain endp\n\nAddFour proc\n\tmov  rax,rcx\n\tadd  rax,rdx\n\tadd  rax,r8\n\tadd  rax,r9\t\t\t\t; sum is in RAX\n\tret\nAddFour endp\n\nend"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\64 bit\\Lib64test.asm",
        "snippet": "; testing 64-bit Windows API\t\t\t(Lib64test.asm)\n;  Chapter 5 example\n\nExitProcess \tproto\nReadInt64       proto\nReadString      proto\nWriteString\t\tproto\nWriteInt64\t\tproto\nWriteHex32\t\tproto\nWriteHex64\t\tproto\nCrlf \t\t\t\tproto\n\n.data\nmessage BYTE \"Testing the Irvine64 library\",0\nmaxval qword 9223372036854775807\nminval qword -9223372036854775808\nhexval qword 0123456789ABCDEFh\ninbuf  BYTE  50 dup(0),0\ninbuf_size = $ - inbuf\n\n.code\nmain proc\n\n\tmov\t  rdx,offset message\n\tcall  WriteString\n\tcall  Crlf\n\n\tcall  ReadInt64\t\t\t\t; read value into rax\n\tcall  Crlf\n\tcall  WriteInt64\t\t\t; display rax \n\tcall  Crlf\n\ncomment !\n\tmov   rdx,offset inbuf\n\tmov   rcx,inbuf_size\n\tcall  ReadString\t\t\t; read a string (RAX = length)\n\tcall  WriteInt64\t\t\t; display the string length\n\tcall  Crlf\n\t\n\tmov   rdx,offset inbuf"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch05\\64 bit\\TestRandom.asm",
        "snippet": "; Testing the Random Number generator\t\t(TestRandom.asm)\n; Chapter 5 example\n\nExitProcess PROTO\nWriteInt64  PROTO\nCrlf        PROTO\nRandom64\tPROTO\nRandomRange PROTO\nRandomize   PROTO\n\n.code\nmain proc\n\tsub   rsp,8\t\t\t\t; align the stack pointer\n\tsub   rsp,20h\t\t\t; reserve 32 bytes for shadow parameters\n\n\tcall  Randomize\n\tmov   rcx,20\nL1:\n\tmov   rax,234324243242\n\tcall  RandomRange\t\t\t; returns RAX = random value\t\n\tcall  WriteInt64\n\tcall  Crlf\n\tloop  L1\n\n\n\tadd  rsp,28h\t\t\t; restore stack pointer (optional)\n\tmov  ecx,0\n\tcall ExitProcess\nmain endp\n\nend"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\ArraySum.cpp",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\ArryScan.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\Encrypt.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\Finite.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\Flowchart.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\ifstatements.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\jumps.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\Loopnz.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\ProcTble.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\Regist.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\RegistAlt.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\Section_6_7_1.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\SetCur.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\TestGetCommandTail.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\ArraySum.cpp",
        "snippet": "// arraysum.cpp\n// Last update: 06/01/2006\n\n\nvoid main()\n{\n\tint array[] = {10,60,20,33,72,89,45,65,72,18};\n\tint sample = 50;\n\tint ArraySize = sizeof array / sizeof sample;\n\tint index = 0;\n\tint sum = 0;\n\n\twhile( index < ArraySize )\n\t{\n\tif( array[index] > sample )\n\t\tsum += array[index];\n\tindex++;\n\t}\n\n}"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\ArryScan.asm",
        "snippet": "; Scanning an Array              (ArryScan.asm)\n\n; Scan an array for the first nonzero value.\n\nINCLUDE Irvine32.inc\n\n.data\nintArray SWORD  0,0,0,0,1,20,35,-12,66,4,0\n;intArray SWORD  1,0,0,0\n;intArray SWORD  0,0,0,0\n;intArray SWORD  0,0,0,1\nnoneMsg  BYTE \"A non-zero value was not found\",0\n\n.code\nmain PROC\n\tmov   ebx,OFFSET intArray\t\t; point to the array\n\tmov   ecx,LENGTHOF intArray\t\t; loop counter\n\nL1:\n\tcmp   WORD PTR [ebx],0\t\t; compare value to zero\n\tjnz   found\t\t\t\t; found a value\n\tadd   ebx,2\t\t\t\t; point to next\n\tloop  L1\t\t\t\t\t; continue the loop\n\tjmp   notFound\t\t\t\t; none found\n\nfound:\n\tmovsx eax,WORD PTR [ebx]\t\t; otherwise, display it\n\tcall  WriteInt\n\tjmp   quit\n\nnotFound:\n\tmov   edx,OFFSET noneMsg\t\t; display \"not found\" message\n\tcall  WriteString\n\nquit:\n\tcall  crlf\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\Encrypt.asm",
        "snippet": "; Encryption Program               (Encrypt.asm)\n\n; This program demonstrates simple symmetric\n; encryption using the XOR instruction.\n\nINCLUDE Irvine32.inc\nKEY = 239     \t\t; any value between 1-255\nBUFMAX = 128     \t; maximum buffer size\n\n.data\nsPrompt  BYTE  \"Enter the plain text: \",0\nsEncrypt BYTE  \"Cipher text:          \",0\nsDecrypt BYTE  \"Decrypted:            \",0\nbuffer   BYTE   BUFMAX+1 DUP(0)\nbufSize  DWORD  ?\n\n.code\nmain PROC\n\tcall\tInputTheString\t\t; input the plain text\n\tcall\tTranslateBuffer\t; encrypt the buffer\n\tmov\tedx,OFFSET sEncrypt\t; display encrypted message\n\tcall\tDisplayMessage\n\tcall\tTranslateBuffer  \t; decrypt the buffer\n\tmov\tedx,OFFSET sDecrypt\t; display decrypted message\n\tcall\tDisplayMessage\n\n\texit\nmain ENDP\n\n;-----------------------------------------------------\nInputTheString PROC\n;\n; Prompts user for a plaintext string. Saves the string \n; and its length.\n; Receives: nothing\n; Returns: nothing\n;-----------------------------------------------------\n\tpushad\n\tmov\tedx,OFFSET sPrompt\t; display a prompt\n\tcall\tWriteString"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\Finite.asm",
        "snippet": "; Finite State Machine              (Finite.asm)\n\n; This program implements a finite state machine that\n; accepts an integer with an optional leading sign.\n\nINCLUDE Irvine32.inc\n\nENTER_KEY = 13\n.data\nInvalidInputMsg BYTE \"Invalid input\",13,10,0\n\n.code\nmain PROC\n\tcall Clrscr\n\nStateA:\n\tcall\tGetnext       \t\t; read next char into AL\n\tcmp\tal,'+'         \t; leading + sign?\n\tje\tStateB          \t; go to State B\n\tcmp\tal,'-'         \t; leading - sign?\n\tje\tStateB          \t; go to State B\n\tcall\tIsDigit       \t\t; ZF = 1 if AL contains a digit\n\tjz\tStateC\t\t\t; go to State C\n\tcall\tDisplayErrorMsg  \t; invalid input found\n\tjmp\tQuit\n\nStateB:\n\tcall\tGetnext       \t\t; read next char into AL\n\tcall\tIsDigit       \t\t; ZF = 1 if AL contains a digit\n\tjz\tStateC\n\tcall\tDisplayErrorMsg  \t; invalid input found\n\tjmp\tQuit\n\nStateC:\n\tcall\tGetnext       \t\t; read next char into AL\n\tcall\tIsDigit       \t\t; ZF = 1 if AL contains a digit\n\tjz\tStateC\n\tcmp\tal,ENTER_KEY\t\t; Enter key pressed?\n\tje\tQuit\t\t\t\t; yes: quit\n\tcall\tDisplayErrorMsg  \t; no: invalid input found"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\Flowchart.asm",
        "snippet": "; Flowchart Example              (Flowchart.asm)\n\n; Implements the flowchart in Figure 6-2,\n; Calculates the sum of all array elements larger than\n; a given value (sample).\n\nINCLUDE Irvine32.inc\n\n.data\nsum DWORD 0\nsample DWORD 50\n\narray DWORD 10,60,20,33,72,89,45,65,72,18\nArraySize = ($ - Array) / TYPE array\n\n.code\nmain PROC\n\tmov\teax,0\t\t; sum\n\tmov\tedx,sample\n\tmov\tesi,0\t\t; index\n\tmov\tecx,ArraySize\n\nL1:\tcmp\tesi,ecx\n\tjl\tL2\n\tjmp\tL5\n\nL2:\tcmp\tarray[esi*4], edx\n\tjg\tL3\n\tjmp\tL4\nL3:\tadd\teax,array[esi*4]\n\nL4:\tinc\tesi\n\tjmp\tL1\n\nL5:\tmov\tsum,eax\n\n\tcall\tWriteint\n\tcall\tCrlf\n\n\texit"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\ifstatements.asm",
        "snippet": "; IF statements             (IfStatements.asm)\n\n; Implementations of IF statements\n\nINCLUDE Irvine32.inc\n\n.data\nX\tDWORD ?\nY\tDWORD ?\nop1\tDWORD ?\nop2\tDWORD ?\n\n.code\nmain PROC\n\n\tcall example_3\n\n\texit\nmain ENDP\n\n;----------------------------------------------------\nexample_3 PROC\n\nCOMMENT @\nif op1 > op2 then\n\tcall Routine1\nelse\n\tcall Routine2\nend if\n@\n\n; Version 1:\n\tmov\teax,op1\n\tcmp\teax,op2\t; op1 > op2?\n\tjg\tB1\t\t; yes: call Routine1\n\tcall\tRoutine2\t; no: call Routine2\n\tjmp\tB2\nB1:\tcall\tRoutine1\nB2:"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\jumps.asm",
        "snippet": "; Conditional Jumps             (jumps.asm)\n\n; Demonstrates conditional jumps\n\nINCLUDE irvine32.inc\n.data\nvar1 DWORD 0\n\ncode segment 'CODE'\nmain PROC\n\n\tje\tL1\t\t\t; jump to short target\n\tmov  edx,offset var1\t\nL1:\n\n\tmov\tax,bx\n\tnop\t\t\t; align next instruction\n\tmov\tedx,ecx\n\n\n\tjz FarLabel\n\tnop\t\n\tnop\n\tnop\n\n\tmov\tax,4C00h\n\tint\t21h\nmain ENDP\ncode ends\n\nother segment 'CODE'\n\nFarLabel:\n\t\n\n\nother ends"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\Loopnz.asm",
        "snippet": "; Scanning for a Positive Value        (Loopnz.asm)\n\n; Scan an array for the first positive value.\n; If no value is found, ESI will point to a sentinel\n; value (0) stored immediately after the array.\n\nINCLUDE Irvine32.inc\n.data\narray  SWORD  -3,-6,-1,-10,10,30,40,4\nsentinel SWORD  0\n\n.code\nmain PROC\n\tmov esi,OFFSET array\n\tmov ecx,LENGTHOF array\n\nnext:\n\ttest WORD PTR [esi],8000h\t\t; test sign bit\n\tpushfd\t\t\t\t\t\t; push flags on stack\n\tadd  esi,TYPE array\n\tpopfd\t\t\t\t\t\t; pop flags from stack\n\tloopnz next \t\t\t\t\t; continue loop\n\t\n\tjnz  quit\t\t\t\t\t\t; none found\n\tsub  esi,TYPE array\t\t\t\t; ESI points to value\n\nquit:\n\tmovsx eax,WORD PTR[esi]\t\t\t; display the value\n\tcall WriteInt\n\tcall crlf\n\texit\nmain ENDP\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\ProcTble.asm",
        "snippet": "; Table of Procedure Offsets          (ProcTble.asm)\n\n; This progam contains a table with offsets of procedures.\n; It uses the table to execute indirect procedure calls.\n\nINCLUDE Irvine32.inc\n.data\nCaseTable  BYTE   'A'\t\t\t; lookup value\n           DWORD   Process_A\t\t; address of procedure\n           BYTE   'B'\n           DWORD   Process_B\n           BYTE   'C'\n           DWORD   Process_C\n           BYTE   'D'\n           DWORD   Process_D\nNumberOfEntries = 4\n\nprompt BYTE \"Press capital A,B,C,or D: \",0\nmsgA BYTE \"Process_A\",0\nmsgB BYTE \"Process_B\",0\nmsgC BYTE \"Process_C\",0\nmsgD BYTE \"Process_D\",0\n\n.code\nmain PROC\n\tmov  edx,OFFSET prompt\t\t; ask user for input\n\tcall WriteString\n\tcall ReadChar\t\t\t\t; read one character\n\tmov  ebx,OFFSET CaseTable\t; point EBX to the table\n\tmov  ecx,NumberOfEntries \t; loop counter\nL1:\n\tcmp  al,[ebx]\t\t\t\t; match found?\n\tjne  L2\t\t\t\t\t; no: continue\n\tcall NEAR PTR [ebx + 1]\t\t; yes: call the procedure\n\tcall WriteString\t\t\t; display message\n\tcall Crlf\n\tjmp  L3\t\t\t\t\t; exit the search\nL2:\n\tadd  ebx,5\t\t\t\t; point to the next entry\n\tloop L1\t\t\t\t\t; repeat until ECX = 0"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\32 bit\\Regist.asm",
        "snippet": ";  College Registration Example         (Regist.asm)\n\n; Simple demonstration of MASM's .IF,\n; .ENDIF, and .ELSEIF directives.\n\nINCLUDE Irvine32.inc\n\n.data\nTRUE = 1\nFALSE = 0\ngradeAverage  WORD 275\t; test value\ncredits       WORD 12\t; test value\nOkToRegister  BYTE ?\n\n.code\nmain PROC\n\n\tmov OkToRegister,FALSE\n\n\t.IF gradeAverage > 350\n\t   mov OkToRegister,TRUE\n\t.ELSEIF (gradeAverage > 250) && (credits <= 16)\n\t   mov OkToRegister,TRUE\n\t.ELSEIF (credits <= 12)\n\t   mov OkToRegister,TRUE\n\t.ENDIF\n\n\texit\nmain ENDP\n\nEND main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\64 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\64 bit\\BooleanOps.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch06\\64 bit\\BooleanOps.asm",
        "snippet": "; Moves.asm  - Testing the 64-bit move operations\n\nExitProcess proto\n\n.data\nhexval qword 0123456789ABCDEFh\nallones qword 0FFFFFFFFFFFFFFFFh\ntestval qword ?\n\n.code\nmain proc\n; The AND instruction \n\n; The destination is a 64-bit register:\n\tmov  rax,allones\n\tand  rax,80h\t\t\t\t; affects all bits\n\tmov  rax,allones\n\tand  rax,8080h\t\t\t\t; affects all bits\n\tmov  rax,allones\n\tand  rax,808080h\t\t\t; affects all bits\n\tmov  rax,allones\n\tand  rax,80808080h\t\t; affects lower 32 bits\n\n; The destination is a memory operand:\t\n\tmov  rax,allones\n\tmov  testval,rax\n\tand  testval,80h\t\t\t\t; affects all bits\n\t\n\tmov  testval,rax\n\tand  testval,8080h\t\t\t\t; affects all bits\n\t\n\tmov  testval,rax\n\tand  testval,80808080h\t\t; only affects the lower 32 bits\n\n; When a 64-bit register operand is used, AND is a 64-bit operation:\n\tmov   rax,hexval\n\tmov   rbx,80808080h\n\tand   rax,rbx\t\t\t; affects all bits\n\n\tmov   ecx,0"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\AddPacked.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\ASCII_add.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\BinToAsc.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\Bmult.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\CompareMult.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\Divide32.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\encrypt_1.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\Express.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\ExtAdd.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\Idiv.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\imul.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\Multiply.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\MultiShift.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\Shrd.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\WriteBin.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\AddPacked.asm",
        "snippet": "; Packed Decimal Examples            (AddPacked.asm)\n\n; This program adds two decimal integers.\n\nINCLUDE Irvine32.inc\n\n.data\npacked_1 WORD 4536h\npacked_2 WORD 7207h\nsum DWORD ?\n\n.code\nmain PROC\n; Initialize sum and index.\n\tmov\tsum,0\n\tmov\tesi,0\n\t\n; Add low bytes.\n\tmov\tal,BYTE PTR packed_1[esi]\n\tadd\tal,BYTE PTR packed_2[esi]\n\tdaa\n\tmov\tBYTE PTR sum[esi],al\n\t\n; Add high bytes, include carry.\n\tinc\tesi\n\tmov\tal,BYTE PTR packed_1[esi]\n\tadc\tal,BYTE PTR packed_2[esi]\n\tdaa\n\tmov\tBYTE PTR sum[esi],al\n\n; Add final carry, if any.\n\tinc\tesi\n\tmov\tal,0\n\tadc\tal,0\n\tmov\tBYTE PTR sum[esi],al\n\t\n; Display the sum in hexadecimal.\t\n\tmov\teax,sum\n\tcall\tWriteHex\n\tcall\tCrlf"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\ASCII_add.asm",
        "snippet": "; ASCII Addition                      (ASCII_add.asm)\n\n; This program performs ASCII arithmetic on digit strings having \n; implied fixed decimal points.\n\nINCLUDE Irvine32.inc\n\nDECIMAL_OFFSET = 5\t\t\t\t\t\t; offset from right of string\n.data\ndecimal_one BYTE \"100123456789765\"\t\t\t; 1001234567.89765\ndecimal_two BYTE \"900402076502015\"\t\t\t; 9004020765.02015\nsum BYTE (SIZEOF decimal_one + 1) DUP(0),0\n\n.code\nmain PROC\n\n; Start at the last digit position.\n\n\tmov\tesi,SIZEOF decimal_one - 1\n\tmov\tedi,SIZEOF decimal_one\n\tmov\tecx,SIZEOF decimal_one\n\tmov\tbh,0\t\t\t\t\t; set carry value to zero\n\nL1:\tmov\tah,0\t\t\t\t\t; clear AH before addition\n\tmov\tal,decimal_one[esi]\t\t; get the first digit\n\tadd\tal,bh\t\t\t\t; add the previous carry\t\n\taaa\t\t\t\t\t\t; adjust the sum (AH = carry)\n\tmov\tbh,ah\t\t\t\t; save the carry in carry1\n\tor\tbh,30h\t\t\t\t; convert it to ASCII\n\tadd\tal,decimal_two[esi]\t\t; add the second digit\n\taaa\t\t\t\t\t\t; adjust the sum (AH = carry) \n\tor\tbh,ah\t\t\t\t; OR the carry with carry1\n\tor\tbh,30h\t\t\t\t; convert it to ASCII\n\tor\tal,30h\t\t\t\t; convert AL back to ASCII\n\tmov\tsum[edi],al\t\t\t; save it in the sum\n\tdec\tesi \t\t\t\t\t; back up one digit\n\tdec\tedi\n\tloop\tL1\n\tmov\tsum[edi],bh\t\t\t; save last carry digit"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\BinToAsc.asm",
        "snippet": "; Binary to ASCII                    (BinToAsc.asm)\n\n; This program converts a 32-bit binary integer to ASCII.\n\nINCLUDE Irvine32.inc\n\n.data\nbinVal\tDWORD 1234ABCDh\t\t; sample binary value\nbuffer\tBYTE 32 dup(0),0\n\n.code\nmain PROC\n\tmov\teax,binVal\t\t\t; EAX = binary integer\n\tmov\tesi,OFFSET buffer\t\t; point to the buffer\n\tcall\tBinToAsc\t\t\t\t; do the conversion\n\n\tmov\tedx,OFFSET buffer\t\t; display the buffer\n\tcall WriteString\t\t\t; output: 00010010001101001010101111001101\n\n\tcall Crlf\n\texit\nmain ENDP\n\n;---------------------------------------------------------\n; BinToAsc PROC\n;\n; Converts 32-bit binary integer to ASCII binary.\n; Receives: EAX = binary integer, ESI points to buffer\n; Returns: buffer filled with ASCII binary digits\n;---------------------------------------------------------\n\nBinToAsc PROC\n\tpush\tecx\n\tpush\tesi\n\t\n\tmov\tecx,32\t\t\t\t; number of bits in EAX\n\nL1:\tshl\teax,1\t\t\t\t; shift high bit into Carry flag\n\tmov\tBYTE PTR [esi],'0'\t\t; choose 0 as default digit\n\tjnc\tL2\t\t\t\t\t; if no Carry, jump to L2"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\Bmult.asm",
        "snippet": "; Binary Multiplication         (BMult.asm)\n\n; This program demonstrates binary multiplication using SHL.\n; It multiplies intval by 36, using SHL instructions.\n\nINCLUDE Irvine32.inc\n\n.data\nintval  DWORD  123\n\n.code\nmain PROC\n\n\tmov\teax,intval\n\tmov\tebx,eax\n\tshl\teax,5\t\t; multiply by 32\n\tshl\tebx,2\t\t; multiply by 4\n\tadd\teax,ebx\t\t; sum the products\n\tcall\tDumpRegs\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\CompareMult.asm",
        "snippet": "; Comparing Multiplications         (CompareMult.asm)\n\n; This program compares the execution times of two approaches to \n; integer multiplication: Binary shifting versus the MUL instruction.\n\nINCLUDE Irvine32.inc\n\nLOOP_COUNT = 0FFFFFFFFh\n\n.data\nintval DWORD 5\nstartTime DWORD ?\n\n.code\nmain PROC\n\n; First approach:\n\n\tcall\tGetMseconds\t; get start time\n\tmov\tstartTime,eax\n\t\n\tmov\teax,intval\t; multiply now\n\tcall\tmult_by_shifting\n\t\n\tcall\tGetMseconds\t; get stop time\n\tsub\teax,startTime\n\tcall\tWriteDec\t\t; display elapsed time\n\tcall\tCrlf\n\n; Second approach:\n\n\tcall\tGetMseconds\t; get start time\n\tmov\tstartTime,eax\n\t\n\tmov\teax,intval\n\tcall\tmult_by_MUL\n\n\tcall\tGetMseconds\t; get stop time\n\tsub\teax,startTime\n\tcall\tWriteDec\t\t; display elapsed time"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\Divide32.asm",
        "snippet": "Title 32-bit Division Example             (Divide32.asm)\n\n; This program divides a 64-bit integer dividend\n; by a 32-bit divisor. The quotient and remainder\n; are each 32 bits.\n\nINCLUDE Irvine32.inc\n\n.data\ndividend  QWORD   0000000800300020h\ndivisor   DWORD   00000100h\n\n.code\nmain PROC\n\n   mov  edx,dword ptr dividend + 4     ; dividend, high\n   mov  eax,dword ptr dividend         ; dividend, low\n   div  divisor\n\n; quotient(EAX) = 08003000h, remainder(EDX) = 00000020h\n\n   exit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\encrypt_1.asm",
        "snippet": "; Binary Encryption Example         (Encrypt_1.asm)\n\nINCLUDE Irvine32.inc\n\nBufSize = 80\n\n.data\nbuffer BYTE BufSize DUP(0)\n\nKey\tBYTE 2,5,7,12\nprompt1 BYTE \"Enter a plaintext message: \",0\nmsg1\tBYTE \"The cyphertext text is: \",0\nmsg2\tBYTE \"The decrypted text is:  \",0\n\n.code\nmain PROC\n\n\tmov\tedx,OFFSET prompt1\n\tcall\tWriteString\n\tmov\tedx,OFFSET buffer\n\tmov\tecx,BufSize\n\tcall\tReadString\n\t\n\tcall\tEncrypt\n\t\n\tmov\tedx,OFFSET msg1\n\tcall\tWriteString\n\tmov\tedx,OFFSET buffer\n\tcall\tWriteString\n\n\tcall Crlf\n\texit\nmain ENDP\n\n;---------------------------------------------------------\nEncrypt PROC\n;\n; Encrypts/Decrypts a string.\n; Receives: ESI points to string, EDI points to key array\n; Returns: nothing, but buffer is encrypted"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\Express.asm",
        "snippet": "; Unsigned Arithmetic Expressions        (Express.asm)\n\n; This program shows how to translate simple \n; arithmetic expressions into assembly language.\n\nINCLUDE Irvine32.inc\n\n.data\nmsg1 BYTE \"Unsigned overflow!\",0dh,0ah,0\nvar1 DWORD 3\nvar2 DWORD 6\nvar3 DWORD 4\nvar4 DWORD ?\n\n.code\nmain PROC\n\n;Divide Overflow example:\n\n\tmov ax,1000h\n\tmov bl,0\n\tdiv bl\n\tjmp quit\n\n\n;Example 1: var4 = (var1 + var2) * var3;\nExample1:\n\tmov eax,var1\n\tadd eax,var2\n\tmul var3\t\t\t; EAX * var3\n\tjc  tooBig\t\t; overflow?\n\tmov var4,eax\n\tjmp Example2\n\nExample2:\t\t\t\t; var4 = (var1 * 5) / (var2 - 3);\n\n\tmov eax,var1\n\tmov ebx,5\n\tmul ebx\t\t\t; EDX:EAX = product\n\tmov ebx,var2"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\ExtAdd.asm",
        "snippet": "; Extended Addition Example           (ExtAdd.asm)\n\n; This program calculates the sum of two 8-byte integers.\n; The integers are stored as arrays, with the least significant \n; byte stored at the lowest address value.\n\nINCLUDE Irvine32.inc\n\n.data\nop1 BYTE 34h,12h,98h,74h,06h,0A4h,0B2h,0A2h\nop2 BYTE 02h,45h,23h,00h,00h,87h,10h,80h\n\nsum BYTE 9 dup(0) \t; = 0122C32B0674BB5736h\n\n.code\nmain PROC\n\n\tmov\tesi,OFFSET op1\t\t; first operand\n\tmov\tedi,OFFSET op2\t\t; second operand\n\tmov\tebx,OFFSET sum\t\t; sum operand\n\tmov\tecx,LENGTHOF op1   \t; number of bytes\n\tcall\tExtended_Add\n\n; Display the sum.\n\t\n\tmov  esi,OFFSET sum\n\tmov  ecx,LENGTHOF sum\n\tcall\tDisplay_Sum\n\tcall Crlf\n\t\n\texit\nmain ENDP\n\n;--------------------------------------------------------\nExtended_Add PROC\n;\n; Calculates the sum of two extended integers stored \n; as arrays of bytes.\n; Receives: ESI and EDI point to the two integers,\n; EBX points to a variable that will hold the sum, and"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\32 bit\\Idiv.asm",
        "snippet": "; IDIV Examples             (Idiv.asm)\n\n; This program shows examples of various IDIV formats.\n\nINCLUDE Irvine32.inc\n\n.code\nmain PROC\n\n; Example 1\n.data\nbyteVal SBYTE -48\n.code\n\tmov\tal,byteVal\t; dividend\n\tcbw\t\t\t\t; extend AL into AH\n\tmov\tbl,+5\t\t; divisor\n\tidiv\tbl\t\t\t; AL = -9, AH = -3\n\tcall\tDumpRegs\n\n; Example 2\n.data\nwordVal SWORD -5000\n.code\n\tmov\tax,wordVal \t; dividend, low\n\tcwd               \t; extend AX into DX\n\tmov\tbx,+256\t\t; divisor\n\tidiv\tbx\t\t\t; quotient AX = -19, rem DX = -136\n\tcall\tDumpRegs\n\t\n; Example 3\n\n.data\ndwordVal SDWORD +50000\n.code\n\tmov\teax,dwordVal \t; dividend, low\n\tcdq \t\t\t\t; extend EAX into EDX\n\tmov\tebx,-256\t\t; divisor\n\tidiv\tebx          \t; quotient EAX = -195, rem EDX = +80\n\tcall\tDumpRegs"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\64 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\64 bit\\mul_and_imul.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch07\\64 bit\\mul_and_imul.asm",
        "snippet": "; Mul_and_imul.asm\n; Demonstration of the MUL and IMUL instructions\n; with 64-bit operands\n\nExitProcess proto\nWriteHex64 proto\nCrlf proto\n\n.data\nmultiplier  qword 10h\n.code\nmain proc\n\tsub   rsp,28h\n\n\t\n; 64-bit DIV example\n.data\ndividend_hi qword 00000108h\ndividend_lo qword 33300020h\ndivisor     qword 00010000h\n.code\nmov  rdx, dividend_hi\nmov  rax, dividend_lo\ndiv  divisor \t\t\t; RAX = 0108000000003330\n\t\t\t\t\t\t\t; RDX = 0000000000000020\n\t\n; IMUL examples\t\n\tmov   rax,-4\n\tmov   rbx,4\n\timul  rbx \t\t\t; RAX = -16, RDX = 0FFFFFFFFFFFFFFFF\n\n\n.data\nmultiplicand qword -16\n.code\nimul  rax, multiplicand, 4    ; RAX = FFFFFFFFFFFFFFC0 (-64)\n\t\n\t\n\t\n; MUL examples"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\AddTwo.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ArrayFill.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ArrySum.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Endless.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Fact.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\LocalExample.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\LocalVars.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\MakeArray.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Multiword.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Params.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\proc.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Prototypes.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Read_File.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Recurse.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\RecursiveSum.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Reglist.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Smallint.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\swap.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Test_WriteStackFrame.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Uppercase.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\UsesTest.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\AddTwo.asm",
        "snippet": "; Demonstrate the AddTwo Procedure     (AddTwo.asm)\n\n; Demonstrates different procedure call protocols.\n\nINCLUDE Irvine32.inc\n\n.data\nword1 WORD 1234h\nword2 WORD 4111h\n\n.code\nmain PROC\n\n\t;call\tExample1\n\t;call\tExample2\n\n\tmovzx\teax,word1\n\tpush\teax\n\tmovzx\teax,word2\n\tpush\teax\n\tcall\tAddTwo\n\tcall\tDumpRegs\n\n\texit\n\nmain ENDP\n\n; Call the \"C\" version of AddTwo\n\nExample1 PROC\n\tpush 5\n\tpush 6\n\tcall AddTwo_C\n\tadd  esp,8\t\t; clean up the stack\n\tcall DumpRegs\t\t; sum is in EAX\n\tret\nExample1 ENDP\n\n; Call the STDCALL version of AddTwo"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ArrayFill.asm",
        "snippet": "; Demonstrate reference parameters   (ArrayFill.asm)\n\n; This program fills an array with 16-bit randomly generated integers.\n\nINCLUDE Irvine32.inc\n\n.data\ncount = 100\narray WORD count DUP(?)\n\n.code\nmain PROC\n\n\tpush OFFSET array\n\tpush COUNT\n\tcall ArrayFill\n\t\n\texit\n\nmain ENDP\n\n\nArrayFill PROC\t\n\tpush\tebp\n\tmov\tebp,esp\n\tpushad\t\t\t; save registers\n\tmov\tesi,[ebp+12]\t; offset of array\n\tmov\tecx,[ebp+8]\t; array size\n\tcmp\tecx,0\t\t; ECX == 0?\n\tje\tL2\t\t\t; yes: skip over loop\n    \nL1:\n\tmov\teax,10000h\t; get random 0 - FFFFh\n\tcall\tRandomRange\t; from the link library\n\tmov\t[esi],ax\n\tadd\tesi,TYPE WORD\n\tloop\tL1\n\nL2:\tpopad\t\t\t; restore registers\n\tpop\tebp"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ArrySum.asm",
        "snippet": "; ArraySum Optimization          (ArrySum.asm)\n\n; This program calculates the sum of an array.\n\nINCLUDE Irvine32.inc\n\nOptimized = 1\n\n.data\nArray DWORD 50 DUP(5)\n\n.code\nmain PROC\n\n\tpush LENGTHOF Array\n\tpush OFFSET Array\n\tcall ArraySum\n\tadd  sp,8\n\tcall WriteDec\t\t\t; display the sum\n\tcall Crlf\n\n\texit\nmain ENDP\n\nComment !\n\nIMPLEMENTING THE FOLLOWING C++ FUNCTION:\n\nint ArraySum( int array[], int count )\n{\n\tint sum = 0;\n\tfor(int i = 0; i < count; i++)\n\t  sum += array[i];\n\treturn sum;\n}\n!\n\nsum    EQU <[ebp-4]>\npArray EQU <[ebp+8]>\ncount  EQU <[ebp+12]>"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Endless.asm",
        "snippet": "; Endless Recursion               (Endless.asm)\n\n; This program demonstrates nonstop recursion. It\n; causes a stack overflow.\n\n.386\n.model flat,stdcall\n.stack 0FFFFFh\nExitProcess PROTO, dwExitCode:dword\n\n.code\nmain PROC\n\tcall Endless\n\tINVOKE ExitProcess, 0\nmain ENDP\n\n.code\nEndless PROC\n\n\tcall Endless\n\tret\t\t\t\t; never reaches this line\nEndless ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Fact.asm",
        "snippet": "; Calculating a Factorial                   (Fact.asm)\n\n; This program uses recursion to calculate the\n; factorial of an integer.\n\nINCLUDE Irvine32.inc\n\n.code\nmain PROC\n\tpush 5\t\t\t; calculate 5 factorial\n\tcall Factorial\t\t; calculate factorial (eax)\n\tcall WriteDec\t\t; display it\n\tcall Crlf\n\texit\nmain ENDP\n\nFactorial PROC\n\tpush ebp\n\tmov  ebp,esp\n\tmov  eax,[ebp+8]\t; get n\n\tcmp  eax,0\t\t; n < 0?\n\tja   L1\t\t\t; yes: continue\n\tmov  eax,1\t\t; no: return 1\n\tjmp  L2\n\nL1:\tdec  eax\n\tpush eax\t\t\t; Factorial(n-1)\n\tcall Factorial\n\n; Instructions from this point on execute when each\n; recursive call returns.\n\nReturnFact:\n\tmov  ebx,[ebp+8]   \t; get n\n\tmul  ebx          \t; ax = ax * bx\n\nL2:\tpop  ebp\t\t\t; return EAX\n\tret  4\t\t\t; clean up stack\nFactorial ENDP"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\LocalExample.asm",
        "snippet": "; Comparing LOCAL with ENTER-LEAVE   (LocalExample.asm)\n\n; This program compares the LOCAL directive to ENTER-LEAVE.\n\nINCLUDE Irvine32.inc\n\n.code\nmain PROC\n\t\n\nmain ENDP\n\nExample1 PROC\n\tLOCAL temp:DWORD\n\n\tmov\teax,temp\n\n\tret\nExample1 ENDP\n\n\nExample2 PROC\n\tLOCAL temp:DWORD, SwapFlag:BYTE\n\t\n\tmov\teax,temp\n\tmov\tbl,SwapFlag\n\t\n\tret\nExample2 ENDP\n\n\nMySub PROC\n     enter 8,0\n     \n     \n     leave\n     ret\nMySub ENDP"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\LocalVars.asm",
        "snippet": "; Demonstrate local variables   (LocalVars.asm)\n\n; This program demonstrates the use of local variables.\n\nINCLUDE Irvine32.inc\n\n.data\n\n.code\nmain PROC\n\n\tcall\tMySub\n\t\n\texit\n\nmain ENDP\n\n\nX_local EQU DWORD PTR [ebp-4]\nY_local EQU DWORD PTR [ebp-8]\n\nMySub PROC\n\tpush\tebp\n\tmov\tebp,esp\n\tsub\tesp,8\t\t; create variables\n\tmov\tX_local,20\t; X\n\tmov\tY_local,10\t; Y\n\tmov\tesp,ebp\t\t; remove locals from stack\n\tpop\tebp\n\tret\nMySub ENDP\n\n\nEND main\n\n; ALTERNATE VERSION:\n\nMySub PROC\n\tpush\tebp\n\tmov\tebp,esp"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\MakeArray.asm",
        "snippet": "; (MakeArray.asm)\n\n; This program creates an array on the local variables \n; area of the stack.\n\nINCLUDE Irvine32.inc\n\n.data\ncount = 100\narray WORD count DUP(?)\n\n.code\nmain PROC\n\n\tcall\tmakeArray\n\tmov\teax,0\n\n\texit\n\nmain ENDP\n\n\nmakeArray PROC\n\tpush\tebp\n\tmov\tebp,esp\n\tsub\tesp,32\t\t\t\t; myString is at EBP-32\n\n\tlea\tesi,[ebp-32]\t\t; load address of myString\n\tmov\tecx,30\t\t\t\t; loop counter\nL1:\tmov\tBYTE PTR [esi],'*'\t; fill one position\n\tinc\tesi\t\t\t\t\t; move to next\n\tloop\tL1\t\t\t\t; continue until ECX = 0\n\n\tadd\tesp,32\t\t\t\t; remove the array (restore ESP)\n\tpop\tebp\n\tret\nmakeArray ENDP\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Multiword.asm",
        "snippet": "; Multiword procedure arguments    (Multiword.asm)\n\n; This program demonstrates the passing of a 64-bit argument\n; to a procedure.\n\nINCLUDE Irvine32.inc\n\n.data\nlongVal DQ 1234567800ABCDEFh\n\n.code\nmain PROC\n\n\tpush\tDWORD PTR longVal + 4\t; high\n\tpush\tDWORD PTR longVal\t\t; low\n\tcall\tWriteHex64\n\n\tcall\tCrlf\n\texit\nmain ENDP\n\n\n; Displays a 64-bit integer in Hexadecimal\n\nWriteHex64 PROC\n\tpush\tebp\n\tmov\tebp,esp\n\n\tmov\teax,[ebp+12]\t; high doubleword\n\tcall\tWriteHex\n\tmov\teax,[ebp+8]\t; low doubleword\n\tcall\tWriteHex\n\n\tpop\tebp\n\tret\t8\t\t\t; clean up the stack\nWriteHex64 ENDP\n\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\Params.asm",
        "snippet": "; Procedure Parameter Examples          (Params.asm)\n\n; This program demonstrates the use of the PROC, \n; PROTO, and INVOKE directives.\n\nINCLUDE Irvine32.inc\n\nSub1 PROTO someData:WORD\nSub2 PROTO dataPtr:PTR WORD\n\nArraySum PROTO,\n\tptrArray:PTR DWORD,\n\tszArray:DWORD\n\nAddThree PROTO,\n\tval1:DWORD,\n\tval2:DWORD,\n\tval3:DWORD\n\nFillArray PROTO,\n\tpArray:PTR BYTE\n\n.data\nmyData WORD 1000h\ntheSum DWORD  ?\n\n\nbArray BYTE 30 dup(0)\nwArray WORD 30 dup(0)\ndArray  DWORD  10000h,20000h,30000h,40000h,50000h\n\n.code\nmain PROC\n\n\tpush\t5\n\tcall\tSimple\n\n\tINVOKE Sub2, ADDR myData\t\t; pass by reference\n\n\tINVOKE Sub2, ADDR dArray\t\t; wrong type of pointer!"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\C_Examples\\C_Examples",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\C_Examples\\C_Examples\\makeArray.c"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\C_Examples\\C_Examples\\makeArray.c",
        "snippet": "// makearray.c\n\nvoid makeArray( ) \n{\n\tchar myString[30];\n\tint i;\n\n\tfor( i = 0; i < 30; i++ )\n\t\tmyString[i] = (char)i;\n\n}\n\n\nvoid main()\n{\n\n\tmakeArray();\n\n\n}"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\C_Examples\\C_Examples\\Release\\makeArray.asm",
        "snippet": "; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60315.1 \n\n\t;\tD:\\Asmbook 7\\examples\\ch08\\32 bit\\C_Examples\\C_Examples\\makeArray.c\n\t.686P\n\t.XMM\n\tinclude listing.inc\n\t.model\tflat\n\nINCLUDELIB LIBCMT\nINCLUDELIB OLDNAMES\n\nPUBLIC\t_makeArray\nPUBLIC\t_main\nEXTRN\t@__security_check_cookie@4:PROC\nEXTRN\t___security_cookie:DWORD\n; Function compile flags: /Ogtp\n;\tCOMDAT _main\n_TEXT\tSEGMENT\n_main\tPROC\t\t\t\t\t\t; COMDAT\n; File d:\\asmbook 7\\examples\\ch08\\32 bit\\c_examples\\c_examples\\makearray.c\n; Line 20\n\txor\teax, eax\n\tret\t0\n_main\tENDP\n_TEXT\tENDS\n; Function compile flags: /Ogtp\n;\tCOMDAT _makeArray\n_TEXT\tSEGMENT\n__$ArrayPad$ = -4\t\t\t\t\t; size = 4\n_makeArray PROC\t\t\t\t\t\t; COMDAT\n; File d:\\asmbook 7\\examples\\ch08\\32 bit\\c_examples\\c_examples\\makearray.c\n; Line 4\n\tpush\tebp\n\tmov\tebp, esp\n\tsub\tesp, 36\t\t\t\t\t; 00000024H\n\tmov\teax, DWORD PTR ___security_cookie\n\txor\teax, ebp\n\tmov\tDWORD PTR __$ArrayPad$[ebp], eax\n; Line 8\n\txor\teax, eax"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\C_Examples\\C_Examples\\Release",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\C_Examples\\C_Examples\\Release\\makeArray.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\C_Examples\\C_Examples\\Release\\makeArray.asm",
        "snippet": "; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60315.1 \n\n\t;\tD:\\Asmbook 7\\examples\\ch08\\32 bit\\C_Examples\\C_Examples\\makeArray.c\n\t.686P\n\t.XMM\n\tinclude listing.inc\n\t.model\tflat\n\nINCLUDELIB LIBCMT\nINCLUDELIB OLDNAMES\n\nPUBLIC\t_makeArray\nPUBLIC\t_main\nEXTRN\t@__security_check_cookie@4:PROC\nEXTRN\t___security_cookie:DWORD\n; Function compile flags: /Ogtp\n;\tCOMDAT _main\n_TEXT\tSEGMENT\n_main\tPROC\t\t\t\t\t\t; COMDAT\n; File d:\\asmbook 7\\examples\\ch08\\32 bit\\c_examples\\c_examples\\makearray.c\n; Line 20\n\txor\teax, eax\n\tret\t0\n_main\tENDP\n_TEXT\tENDS\n; Function compile flags: /Ogtp\n;\tCOMDAT _makeArray\n_TEXT\tSEGMENT\n__$ArrayPad$ = -4\t\t\t\t\t; size = 4\n_makeArray PROC\t\t\t\t\t\t; COMDAT\n; File d:\\asmbook 7\\examples\\ch08\\32 bit\\c_examples\\c_examples\\makearray.c\n; Line 4\n\tpush\tebp\n\tmov\tebp, esp\n\tsub\tesp, 36\t\t\t\t\t; 00000024H\n\tmov\teax, DWORD PTR ___security_cookie\n\txor\teax, ebp\n\tmov\tDWORD PTR __$ArrayPad$[ebp], eax\n; Line 8\n\txor\teax, eax"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_advanced\\ModSum",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_advanced\\ModSum\\Sum_main.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_advanced\\ModSum\\_arrysum.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_advanced\\ModSum\\_display.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_advanced\\ModSum\\_prompt.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_advanced\\ModSum\\Sum_main.asm",
        "snippet": "; Integer Summation Program\t\t (Sum_main.asm)\n\n; Multimodule example:   (main module)\n; This program inputs multiple integers from the user,\n; stores them in an array, calculates the sum of the\n; array, and displays the sum.\n\nINCLUDE sum.inc\n\n; modify Count to change the size of the array:\nCount = 3\n\n.data\nprompt1 BYTE  \"Enter a signed integer: \",0\nprompt2 BYTE  \"The sum of the integers is: \",0\narray   DWORD  Count DUP(?)\nsum     DWORD  ?\n\n.code\nmain PROC\n\tcall Clrscr\n\n\tINVOKE PromptForIntegers, \n\t\tADDR prompt1, \n\t\tADDR array, \n\t\tCount\n\n\tINVOKE ArraySum, \n\t\tADDR array, \n\t\tCount\n\tmov\tsum,eax\t\t; save the sum\n\n\tINVOKE DisplaySum, \n\t\tADDR prompt2, \n\t\tsum\n\n\tcall\tCrlf\n\texit\nmain ENDP"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_advanced\\ModSum\\_arrysum.asm",
        "snippet": "; ArraySum Procedure                 (_arrysum.asm)\n\nINCLUDE sum.inc\n.code\n;-----------------------------------------------------\nArraySum PROC,\n\tptrArray:PTR DWORD,\t; pointer to array\n\tarraySize:DWORD\t; size of array\n;\n; Calculates the sum of an array of 32-bit integers.\n; Returns:  EAX = sum\n;-----------------------------------------------------\n\tpush ecx\t\t; don't push EAX\n\tpush esi\n\n\tmov  eax,0\t\t; set the sum to zero\n\tmov  esi,ptrArray\n\tmov  ecx,arraySize\n\tcmp  ecx,0\t\t; array size <= 0?\n\tjle  L2\t\t; yes: quit\n\nL1:\tadd  eax,[esi]\t\t; add each integer to sum\n\tadd  esi,4\t\t; point to next integer\n\tloop L1\t\t; repeat for array size\n\nL2:\tpop esi\n\tpop ecx\t\t; return sum in EAX\n\tret\nArraySum ENDP\nEND"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_advanced\\ModSum\\_display.asm",
        "snippet": "; DisplaySum Procedure\t\t(_display.asm)\n\nINCLUDE Sum.inc\n\n.code\n;-----------------------------------------------------\nDisplaySum PROC,\n\tptrPrompt:PTR BYTE,\t; prompt string\n\ttheSum:DWORD\t\t; the array sum\n;\n; Displays the sum on the console.\n; Returns:  nothing\n;-----------------------------------------------------\n\tpush\teax\n\tpush\tedx\n\n\tmov\tedx,ptrPrompt\t; pointer to prompt\n\tcall\tWriteString\n\tmov\teax,theSum\n\tcall\tWriteInt\t\t; display EAX\n\tcall\tCrlf\n\n\tpop\tedx\n\tpop\teax\n\tret\nDisplaySum ENDP\n\nEND"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_advanced\\ModSum\\_prompt.asm",
        "snippet": "; Prompt For Integers\t      (_prompt.asm)\n\nINCLUDE sum.inc\t\t; get procedure prototypes\n\n.code\n;-----------------------------------------------------\nPromptForIntegers PROC,\n  ptrPrompt:PTR BYTE,\t\t; prompt string\n  ptrArray:PTR DWORD,\t\t; pointer to array\n  arraySize:DWORD\t\t\t; size of the array\n;\n; Prompts the user for an array of integers and fills\n; the array with the user's input.\n; Returns:  nothing\n;-----------------------------------------------------\n\tpushad\t\t\t\t; save all registers\n\t\t\n\tmov  ecx,arraySize\n\tcmp  ecx,0\t\t\t; array size <= 0?\n\tjle  L2\t\t\t\t; yes: quit\n\tmov  edx,ptrPrompt\t; address of the prompt\n\tmov  esi,ptrArray\n\nL1:\tcall WriteString\t; display string\n\tcall ReadInt\t\t; read integer into EAX\n\tcall Crlf\t\t\t; go to next output line\n\tmov  [esi],eax\t\t; store in array\n\tadd  esi,4\t\t\t; next integer\n\tloop L1\n\nL2:\tpopad\t\t\t; restore all registers\n\tret\nPromptForIntegers ENDP\n\nEND"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_traditional\\ModSum",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_traditional\\ModSum\\Sum_main.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_traditional\\ModSum\\_arrysum.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_traditional\\ModSum\\_display.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_traditional\\ModSum\\_prompt.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_traditional\\ModSum\\Sum_main.asm",
        "snippet": "; Integer Summation Program\t\t (Sum_main.asm)\n\n; Multimodule example:   (main module)\n; This program inputs multiple integers from the user,\n; stores them in an array, calculates the sum of the\n; array, and displays the sum.\n\n; Uses EXTERN to access external procedures\n\nINCLUDE Irvine32.inc\n\nEXTERN PromptForIntegers@0:PROC\nEXTERN ArraySum@0:PROC, DisplaySum@0:PROC\n\n; Redefine external symbols for convenience\nArraySum\t\t\tEQU ArraySum@0\nPromptForIntegers\tEQU PromptForIntegers@0\nDisplaySum\t\tEQU DisplaySum@0\n\n; modify Count to change the size of the array:\nCount = 3\n\n.data\nprompt1 BYTE  \"Enter a signed integer: \",0\nprompt2 BYTE  \"The sum of the integers is: \",0\narray   DWORD  Count DUP(?)\nsum     DWORD  ?\n\n.code\nmain PROC\n\tcall\tClrscr\n\n; PromptForIntegers( addr prompt1, addr array, Count )\n\tpush\tCount\n\tpush\tOFFSET array\n\tpush\tOFFSET prompt1\n\tcall\tPromptForIntegers\n\n; eax = ArraySum( addr array, Count )\n\tpush\tCount"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_traditional\\ModSum\\_arrysum.asm",
        "snippet": "; ArraySum Procedure             (_arrysum.asm)\n\nINCLUDE Irvine32.inc\n.code\nArraySum PROC\n;\n; Calculates the sum of an array of 32-bit integers.\n\n; Receives:\n;\tptrArray\t\t; pointer to array\n;\tarraySize\t\t; size of array (DWORD)\n; Returns:  EAX = sum\n;-----------------------------------------------------\nptrArray EQU [ebp+8]\narraySize EQU [ebp+12]\n\n\tenter\t0,0\n\tpush\tecx\t\t; don't push EAX\n\tpush\tesi\n\n\tmov\teax,0\t\t; set the sum to zero\n\tmov\tesi,ptrArray\n\tmov\tecx,arraySize\n\tcmp\tecx,0\t\t; array size <= 0?\n\tjle\tL2\t\t; yes: quit\n\nL1:\tadd\teax,[esi]\t\t; add each integer to sum\n\tadd\tesi,4\t\t; point to next integer\n\tloop\tL1\t\t; repeat for array size\n\nL2:\tpop\tesi\n\tpop\tecx\t\t; return sum in EAX\n\tleave\n\tret\t8\nArraySum ENDP\nEND"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_traditional\\ModSum\\_display.asm",
        "snippet": "; DisplaySum Procedure\t\t(_display.asm)\n\nINCLUDE Irvine32.inc\n.code\n;-----------------------------------------------------\nDisplaySum PROC\n\n; Displays the sum on the console.\n; Receives:\n;\tptrPrompt\t\t; offset of prompt string\n;\ttheSum\t\t; the array sum (DWORD)\n; Returns: nothing\n;-----------------------------------------------------\n\ntheSum\tEQU [ebp+12]\nptrPrompt\tEQU [ebp+8]\n\n\tenter\t0,0\n\tpush\teax\n\tpush\tedx\n\n\tmov\tedx,ptrPrompt\t; pointer to prompt\n\tcall\tWriteString\n\tmov\teax,theSum\n\tcall\tWriteInt\t\t; display EAX\n\tcall\tCrlf\n\n\tpop\tedx\n\tpop\teax\n\tleave\n\tret\t8\t\t; restore the stack\nDisplaySum ENDP\nEND"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\ModSum32_traditional\\ModSum\\_prompt.asm",
        "snippet": "; Prompt For Integers\t      (_prompt.asm)\n\nINCLUDE Irvine32.inc\n.code\n;----------------------------------------------------\nPromptForIntegers PROC\n\n; Prompts the user for an array of integers and fills\n; the array with the user's input.\n; Receives:\n; \tptrPrompt:PTR BYTE\t\t\t; prompt string\n; \tptrArray:PTR DWORD\t\t\t; pointer to array\n; \tarraySize:DWORD\t\t\t; size of the array\n; Returns:  nothing\n;-----------------------------------------------------\narraySize\tEQU [ebp+16]\nptrArray\tEQU [ebp+12]\nptrPrompt\tEQU [ebp+8]\n\n\tenter\t0,0\n\tpushad\t\t\t\t; save all registers\n\n\tmov\tecx,arraySize\n\tcmp\tecx,0\t\t\t; array size <= 0?\n\tjle\tL2\t\t\t\t; yes: quit\n\tmov\tedx,ptrPrompt\t\t; address of the prompt\n\tmov\tesi,ptrArray\n\nL1:\tcall\tWriteString\t\t; display string\n\tcall\tReadInt\t\t\t; read integer into EAX\n\tcall\tCrlf\t\t\t\t; go to next output line\n\tmov\t[esi],eax\t\t\t; store in array\n\tadd\tesi,4\t\t\t; next integer\n\tloop\tL1\n\nL2:\tpopad\t\t\t\t; restore all registers\n\tleave\n\tret 12\t\t\t\t; restore the stack\nPromptForIntegers ENDP\nEND"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\public_and_extern",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\public_and_extern\\main.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\public_and_extern\\sub1.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\public_and_extern\\sub2.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\public_and_extern\\main.asm",
        "snippet": "; Main module    (main.asm)\n\nINCLUDE Irvine32.inc\nINCLUDE vars.inc\n\n.code\nmain PROC\n\tmov count,2000h\n\tmov eax,SYM1\n\t\nmain ENDP\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\public_and_extern\\sub1.asm",
        "snippet": "; sub1.asm\n\n.386\n.model flat,STDCALL\n\nINCLUDE vars.inc\n\nSYM1 = 10\t\t\t; public\n\n.data\ncount DWORD 0\t\t; public\n\nEND\n\n\n\n.code\nsub1 PROC \t\t; public by default\n\n\tcall localProc\n\nsub1 ENDP\n\nlocalProc PROC PRIVATE\t; private\n\n\tret\nlocalProc ENDP"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch08\\32 bit\\public_and_extern\\sub2.asm",
        "snippet": "; Main module    (main.asm)\n\n; Last update: 4/10/05\n\nINCLUDE Irvine32.inc\n\n\n.code\nmain PROC\n\n\n\texit\n\nmain ENDP\n\nEND main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Base-Index.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Bsort.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Cmpsb.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Compare.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\CopyStr.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Length.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Mult.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\RowSum.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\StringDemo.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Table.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Table2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Trim.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Ucase.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Base-Index.asm",
        "snippet": "; Two-Dimensional Table                (Base-Index.asm)\n\n; This program uses Base-Index and Base-index-displacement \n; modes to access two-dimensional arrays. \n\n\nINCLUDE Irvine32.inc\n\n.data\ntableB  BYTE   10h,  20h,  30h,  40h,  50h\nRowsize = ($ - tableB)\n        BYTE   60h,  70h,  80h,  90h, 0A0h\n        BYTE  0B0h, 0C0h, 0D0h, 0E0h, 0F0h\n\ntableW  WORD   10h,  20h,  30h,  40h,  50h\nRowsizeW = ($ - tableW)\n        WORD   60h,  70h,  80h,  90h, 0A0h\n        WORD  0B0h, 0C0h, 0D0h, 0E0h, 0F0h\n        \ntableD DWORD 10000h,   20000h,  30000h,  40000h,  50000h\nRowSizeD = ($ - tableD)\n\t  DWORD 60000h,   70000h,  80000h,  90000h, 0A0000h\n       DWORD 0B0000h, 0C0000h, 0D0000h, 0E0000h, 0F0000h\n        \n.code\nmain PROC\n\n; Demonstrate Base-Index mode with the byte array:\n\nrow_index = 1\ncolumn_index = 2\n\n\tmov\tebx,OFFSET tableB\t\t; table offset\n\tadd\tebx,RowSize * row_index\t; row offset\n\tmov\tesi,column_index\n\tmov\tal,[ebx + esi]\t\t\t; AL = 80h\n\ncall\tDumpRegs\t\t\t\t\t; look at AL\n\t\n; Demonstrate Base-Index mode with the word array:"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Bsort.asm",
        "snippet": ";  BubbleSort Procedure                  (BSort.asm)\n\n; This program sorts an array of signed integers, using \n; the Bubble sort algorithm. The main program is in B_main.asm.\n\nINCLUDE Irvine32.inc\n\n.code\n;----------------------------------------------------------\nBubbleSort PROC USES eax ecx esi,\n\tpArray:PTR DWORD,\t\t; pointer to array\n\tCount:DWORD\t\t\t; array size\n;\n; Sort an array of 32-bit signed integers in ascending order\n; using the bubble sort algorithm.\n; Receives: pointer to array, array size\n; Returns: nothing\n;-----------------------------------------------------------\n\n\tmov ecx,Count\n\tdec ecx\t\t\t; decrement count by 1\n\nL1:\tpush ecx\t\t\t; save outer loop count\n\tmov esi,pArray\t\t; point to first value\n\nL2:\tmov eax,[esi]\t\t; get array value\n\tcmp [esi+4],eax\t; compare a pair of values\n\tjge L3\t\t\t; if [esi] <= [edi], don't exch\n\txchg eax,[esi+4]\t; exchange the pair\n\tmov [esi],eax\n\nL3:\tadd esi,4\t\t; move both pointers forward\n\tloop L2\t\t; inner loop\n\n\tpop ecx\t\t; retrieve outer loop count\n\tloop L1\t\t; else repeat outer loop\n\nL4:\tret\nBubbleSort ENDP"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Cmpsb.asm",
        "snippet": "; Comparing Strings             (Cmpsb.asm)\n\n; This program uses CMPSB to compare two strings\n; of equal length.\n\nINCLUDE Irvine32.inc\n.data\nsource BYTE \"MARTIN  \"\ndest   BYTE \"MARTINEZ\"\nstr1   BYTE \"Source is smaller\",0dh,0ah,0\nstr2   BYTE \"Source is not smaller\",0dh,0ah,0\n\n.code\nmain PROC\n\tcld\t\t\t\t\t; direction = forward\n\tmov  esi,OFFSET source\n\tmov  edi,OFFSET dest\n\tmov  cx,LENGTHOF source\n\trepe cmpsb\n\tjb   source_smaller\n\tmov  edx,OFFSET str2\n\tjmp  done\n\nsource_smaller:\n\tmov  edx,OFFSET str1\n\ndone:\n\tcall WriteString\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Compare.asm",
        "snippet": "; Comparing Strings                    (Compare.asm)\n\n; This program tests the Str_compare procedure,\n; which compares two null-terminated strings.\n\nINCLUDE Irvine32.inc\n\nStr_compare PROTO,\n\tstring1:PTR BYTE,\n\tstring2:PTR BYTE\n\n.data\nstring_1 BYTE \"ABCDEFG\",0\nstring_2 BYTE \"ABCDEFG\",0\nstring_3 BYTE 0\nstring_4 BYTE 0\n\n.code\nmain PROC\n\tcall Clrscr\n\n\tINVOKE Str_compare,\n\t  ADDR string_4,\n\t  ADDR string_3\n\tCall DumpRegs\n\n\texit\nmain ENDP\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\CopyStr.asm",
        "snippet": "; Copying Strings                    (CopyStr.asm)\n\n; Testing the Str_copy procedure\n\nINCLUDE Irvine32.inc\n\nStr_copy PROTO,\n \tsource:PTR BYTE, \t\t; source string\n \ttarget:PTR BYTE\t\t; target string\n\nStr_length PROTO,\n\tpString:PTR BYTE\t\t; pointer to string\n\n.data\nstring_1 BYTE \"ABCDEFG\",0\nstring_2 BYTE 100 DUP(?)\n\n.code\nmain PROC\n\tcall Clrscr\n\n\tINVOKE Str_copy,\t\t; copy string_1 to string_2\n\t  ADDR string_1,\n\t  ADDR string_2\n\n\tmov  edx,OFFSET string_2\n\tcall WriteString\n\tcall Crlf\n\n\texit\nmain ENDP\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Length.asm",
        "snippet": "; String Length                   (Length.asm)\n\n; This program tests the Str_length procedure,\n; which returns the length of a string.\n\nINCLUDE Irvine32.inc\n\nStr_length PROTO,\n\tpString:PTR BYTE\t\t; pointer to string\n\n.data\nstring_1 BYTE \"Hello\",0\nstring_2 BYTE \"#\",0\nstring_3 BYTE 0\n\n.code\nmain PROC\n\tcall Clrscr\n\n\tINVOKE Str_length,ADDR string_1\n\tcall DumpRegs\n\tINVOKE Str_length,ADDR string_2\n\tcall DumpRegs\n\tINVOKE Str_length,ADDR string_3\n\tcall DumpRegs\n\n\texit\nmain ENDP\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Mult.asm",
        "snippet": "; Multiply an Array                (Mult.asm)\n\n; This program multiplies each element of an array\n; of 32-bit integers by a constant value.\n\nINCLUDE Irvine32.inc\n\n.data\narray DWORD 1,2,3,4,5,6,7,8,9,10\t; test data\nmultiplier DWORD 10\t\t\t\t; test data\n\n.code\nmain PROC\n\tcld \t\t\t\t\t\t; direction = up\n\tmov\tesi,OFFSET array  \t\t; source index\n\tmov\tedi,esi\t\t\t\t; destination index\n\tmov\tecx,LENGTHOF array\t\t; loop counter\n\nL1:\tlodsd                   \t\t; copy [ESI] into EAX\n\tmul\tmultiplier\t\t\t; multiply by a value\n\tstosd                   \t\t; store EAX at [EDI]\n\tloop L1\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\RowSum.asm",
        "snippet": "; Row Sum Calculation\t\t\t\t\t(RowSum.asm)\n\n; This program demonstrates the use of Base-Index addressing \n; with a two-dimensional table array of bytes (a byte matrix).\n\nINCLUDE Irvine32.inc\n\n.data\ntableB  BYTE  10h,  20h,  30h,  40h,  50h\n        BYTE  60h,  70h,  80h,  90h,  0A0h\n        BYTE  0B0h, 0C0h, 0D0h, 0E0h, 0F0h\nRowSize = 5\nmsg1\tBYTE \"Enter row number: \",0\nmsg2 BYTE \"The sum is: \",0\n\n.code\nmain PROC\n\n; Demonstrate Base-Index mode:\n\n\tmov\t  edx,OFFSET msg1\t\t\t; \"Enter row number:\"\n\tcall  WriteString\n\tcall  Readint\t\t\t\t\t; EAX = row number\n\n\tmov\t  ebx,OFFSET tableB\n\tmov\t  ecx,RowSize\n\tcall  calc_row_sum\t\t\t\t; EAX = sum\n   \n\tmov\t  edx,OFFSET msg2\t\t\t; \"The sum is:\"\n\tcall  WriteString\n\tcall  WriteHex\t\t\t\t\t; write sum in EAX\n\tcall  Crlf\n\n\texit\nmain ENDP\n\n\n;------------------------------------------------------------\ncalc_row_sum PROC uses ebx ecx edx esi\n;"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\StringDemo.asm",
        "snippet": "; String Library Demo\t(StringDemo.asm)\n\n; This program demonstrates the string-handling procedures in \n; the book's link library.\n\nINCLUDE Irvine32.inc\n\n.data\nstring_1 BYTE \"abcde////\",0\nstring_2 BYTE \"ABCDE\",0\nmsg0     BYTE \"string_1 in upper case: \",0\nmsg1     BYTE \"string1 and string2 are equal\",0\nmsg2     BYTE \"string_1 is less than string_2\",0\nmsg3     BYTE \"string_2 is less than string_1\",0\nmsg4     BYTE \"Length of string_2 is \",0\nmsg5     BYTE \"string_1 after trimming: \",0\n\n.code\nmain PROC\n\n\tcall\ttrim_string\n\tcall\tupper_case\n\tcall\tcompare_strings\n\tcall\tprint_length\n\n\texit\nmain ENDP\n\ntrim_string PROC\n; Remove trailing characters from string_1.\n\n\tINVOKE Str_trim, ADDR string_1,'/'\n\tmov\t    edx,OFFSET msg5\n\tcall\tWriteString\n\tmov\t    edx,OFFSET string_1\n\tcall\tWriteString\n\tcall\tCrlf\n\n\tret\ntrim_string ENDP"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Table.asm",
        "snippet": "; Two-Dimensional Table                (Table.asm)\n\n; Demonstration of Base-Index mode with a\n; two-dimensional table.\n\nINCLUDE Irvine32.inc\n\n.data\ntableB  BYTE  10h,  20h,  30h,  40h,  50h\n        BYTE  60h,  70h,  80h,  90h, 0A0h\n        BYTE  0B0h, 0C0h, 0D0h, 0E0h, 0F0h\nRowSize = 5\n\n.code\nmain PROC\n\n; Demonstrate Base-Index mode:\n\n   mov  ebx,OFFSET tableB\n   add  ebx,RowSize\n   mov  esi,2\t\t\t\t; column number\n   mov  al,[ebx + esi]\t\t; AL = 80h\n\n; Calculate sum of row 1:\n\n\tRowNum = 1\n\tmov  ecx,RowSize\n\tmov  ebx,OFFSET tableB\n\tadd  ebx,(RowSize * RowNum)\t; move to row 1\n\tmov  esi,0\t\t\t\t\t; beginning of row\n\tmov  ax,0\t\t\t\t\t; zero the sum\n\tmov  dx,0\t\t\t\t\t; holds each value\n\nL1:\n\tmov   dl,[ebx + esi]\t\t; get a byte\n\tadd   ax,dx\t\t\t\t\t; add to accumulator\n\tinc   esi\n\tloopd L1\n\n; AX = 280h, the sum"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Binary_Search",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Binary_Search\\BinarySearch.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Binary_Search\\BinarySearchTest.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Binary_Search\\BubbleSort.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Binary_Search\\FillArray.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Binary_Search\\PrintArray.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Binary_Search\\BinarySearch.asm",
        "snippet": "TITLE  Binary Search Procedure            (BinarySearch.asm)\n\n; Binary Search procedure\n\nINCLUDE Irvine32.inc\n\n.code\n;-------------------------------------------------------------\nBinarySearch PROC USES ebx edx esi edi,\n\tpArray:PTR DWORD,\t\t; pointer to array\n\tCount:DWORD,\t\t\t; array size\n\tsearchVal:DWORD\t\t\t; search value\nLOCAL first:DWORD,\t\t\t; first position\n\tlast:DWORD,\t\t\t\t; last position\n\tmid:DWORD\t\t\t\t; midpoint\n;\n; Search an array of signed integers for a single value.\n; Receives: Pointer to array, array size, search value.\n; Returns: If a match is found, EAX = the array position of the\n; matching element; otherwise, EAX = -1.\n;-------------------------------------------------------------\n\tmov\t first,0\t\t\t; first = 0\n\tmov\t eax,Count\t\t\t; last = (count - 1)\n\tdec\t eax\n\tmov\t last,eax\n\tmov\t edi,searchVal\t\t; EDI = searchVal\n\tmov\t ebx,pArray\t\t\t; EBX points to the array\n\nL1: ; while first <= last\n\tmov\t eax,first\n\tcmp\t eax,last\n\tjg\t L5\t\t\t\t\t; exit search\n\n; mid = (last + first) / 2\n\tmov\t eax,last\n\tadd\t eax,first\n\tshr\t eax,1\n\tmov\t mid,eax\n\n; EDX = values[mid]"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Binary_Search\\BinarySearchTest.asm",
        "snippet": "TITLE Bubble Sort and Binary Search       BinarySearchTest.asm)\n\n; Bubble sort an array of signed integers, and perform\n; a binary search.\n; Main module, calls Bsearch.asm, Bsort.asm, FillArry.asm\n\nINCLUDE Irvine32.inc\nINCLUDE BinarySearch.inc\t\t; procedure prototypes\n\nLOWVAL = -5000\t\t\t; minimum value\nHIGHVAL = +5000\t\t; maximum value\nARRAY_SIZE = 50\t\t; size of the array\n\n.data\narray DWORD ARRAY_SIZE DUP(?)\n\n.code\nmain PROC\n\tcall Randomize\n\n\t; Fill an array with random signed integers\n\tINVOKE FillArray, ADDR array, ARRAY_SIZE, LOWVAL, HIGHVAL\n\n\t; Display the array\n\tINVOKE PrintArray, ADDR array, ARRAY_SIZE\n\tcall\tWaitMsg\n\n\t; Perform a bubble sort and redisplay the array\n\tINVOKE BubbleSort, ADDR array, ARRAY_SIZE\n\tINVOKE PrintArray, ADDR array, ARRAY_SIZE\n\n\t; Demonstrate a binary search\n\tcall AskForSearchVal\t\t; returned in EAX\n\tINVOKE BinarySearch,\n\t  ADDR array, ARRAY_SIZE, eax\n\tcall\tShowResults\n\n\texit\nmain ENDP"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Binary_Search\\BubbleSort.asm",
        "snippet": "TITLE  BubbleSort Procedure                  (BubbleSort.asm)\n\n; Sort an array of signed integers, using the Bubble\n; sort algorithm. The main program is in BinarySearchTest.asm.\n\nINCLUDE Irvine32.inc\n\n.code\n;----------------------------------------------------------\nBubbleSort PROC USES eax ecx esi,\n\tpArray:PTR DWORD,\t\t; pointer to array\n\tCount:DWORD\t\t\t; array size\n;\n; Sort an array of 32-bit signed integers in ascending order\n; using the bubble sort algorithm.\n; Receives: pointer to array, array size\n; Returns: nothing\n;-----------------------------------------------------------\n\n\tmov ecx,Count\n\tdec ecx\t\t\t; decrement count by 1\n\nL1:\tpush ecx\t\t\t; save outer loop count\n\tmov\tesi,pArray\t; point to first value\n\nL2:\tmov\teax,[esi]\t\t; get array value\n\tcmp\t[esi+4],eax\t; compare a pair of values\n\tjge\tL3\t\t\t; if [esi] <= [edi], don't exch\n\txchg eax,[esi+4]\t; exchange the pair\n\tmov\t[esi],eax\n\nL3:\tadd\tesi,4\t\t; move both pointers forward\n\tloop\tL2\t\t\t; inner loop\n\n\tpop\tecx\t\t\t; retrieve outer loop count\n\tloop L1\t\t\t; else repeat outer loop\n\nL4:\tret\nBubbleSort ENDP"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Binary_Search\\FillArray.asm",
        "snippet": "TITLE FillArray Procedure                 (FillArray.asm)\n\nINCLUDE Irvine32.inc\n\n.code\n;------------------------------------------------------------\nFillArray PROC USES eax edi ecx edx,\n\tpArray:PTR DWORD,\t\t  ; pointer to array\n\tCount:DWORD,\t\t       ; number of elements\n\tLowerRange:SDWORD,\t\t  ; lower range\n\tUpperRange:SDWORD\t\t  ; upper range\n;\n; Fills an array with a random sequence of 32-bit signed\n; integers between LowerRange and (UpperRange - 1).\n; Returns: nothing\n;-----------------------------------------------------------\n\tmov\tedi,pArray\t           ; EDI points to the array\n\tmov\tecx,Count\t                ; loop counter\n\tmov\tedx,UpperRange\n\tsub\tedx,LowerRange\t           ; EDX = absolute range (0..n)\n\tcld                            ; clear direction flag\n\nL1:\tmov\teax,edx\t                ; get absolute range\n\tcall\tRandomRange\n\tadd\teax,LowerRange\t           ; bias the result\n\tstosd\t\t                ; store EAX into [edi]\n\tloop\tL1\n\n\tret\nFillArray ENDP\n\nEND"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\32 bit\\Binary_Search\\PrintArray.asm",
        "snippet": "TITLE PrintArray Procedure                  (PrintArray.asm)\n\nINCLUDE Irvine32.inc\n\n.code\n;-----------------------------------------------------------\nPrintArray PROC USES eax ecx edx esi,\n\tpArray:PTR DWORD,\t\t; pointer to array\n\tCount:DWORD\t\t\t; number of elements\n;\n; Writes an array of 32-bit signed decimal integers to\n; standard output, separated by commas\n; Receives: pointer to array, array size\n; Returns: nothing\n;-----------------------------------------------------------\n.data\ncomma BYTE \", \",0\n.code\n\tmov\tesi,pArray\n\tmov\tecx,Count\n\tcld\t\t\t\t; direction = forward\n\nL1:\tlodsd\t\t\t; load [ESI] into EAX\n\tcall\tWriteInt\t\t; send to output\n\tmov\tedx,OFFSET comma\n\tcall\tWritestring\t; display comma\n\tloop\tL1\n\n\tcall\tCrlf\n\tret\nPrintArray ENDP\n\nEND"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\64 bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\64 bit\\Irvine64.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\64 bit\\StringLib64Test.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\64 bit\\TwoDimArrays.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\64 bit\\Irvine64.asm",
        "snippet": "; 64-bit Library (Irvine64.asm)\n\n; Version 1.0, 1/1/2014\n\nCOMMENT !\nThis library was created exlusively for use with the book,\n\"Assembly Language for Intel-Based Computers\", 7th Edition,\nby Kip R. Irvine, 2014.\n\nCopyright 2014, Prentice-Hall Publishing. No part of this file may be\nreproduced, in any form or by any other means, without permission in writing\nfrom the author or publisher.\n\nWin64 API classifies RAX,RCX,RDX,R8,R9,R10,and R11 as volatile,\nso their values are not preserved across API function calls.\n!\n\n; Public procedures:\n; Crlf\n; Randomize\n; Random64\n; RandomRange\n; ReadInt64\n; ReadString\n; Str_compare\n; Str_copy\n; Str_length\n; WriteHexB\n; WriteHex32\n; WriteHex64\n; WriteInt64\n; WriteString\n\n; This library calls the following external procedures from the Windows API:\nGetConsoleMode proto\nGetStdHandle proto\nReadConsoleA proto\nSetConsoleMode proto\nWriteConsole proto\nWriteConsoleA proto"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\64 bit\\StringLib64Test.asm",
        "snippet": "; testing 64-bit Windows API\t\t\t(Lib64test.asm)\n;  Chapter 5 example\n\nStr_compare\t\tproto\nStr_length\t\tproto\nStr_copy\t\t\tproto\nExitProcess \tproto\n\n.data\nsource byte \"AABCDEFGAABCDFG\",0      ; size = 15\ntarget byte 20 dup(0)\n.code\nmain proc\n\tmov   rax,offset source\n\tcall  Str_length\t\t\t\t; returns length in RAX\n\n\tmov   rsi,offset source\n\tmov   rdi,offset target\n\tcall  str_copy\n\n; We just copied the string, so they should be equal:\n\t\n\tcall  str_compare\t\t\t\t; ZF = 1, strings are equal\n\n; Change the first character of the target string, and\n; compare them again:\n\n\tmov   target,'B'\n\tcall  str_compare\t\t\t\t; CF = 1, source < target\n\t\n\tmov   ecx,0\n\tcall  ExitProcess\nmain endp\n\nend"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch09\\64 bit\\TwoDimArrays.asm",
        "snippet": "; Two-dimensional arrays in 64-bit mode (TwoDimArrays.asm)\n\nCrlf\t\t\tproto\nWriteInt64  proto\nExitProcess proto\n\n.data\ntable QWORD 1,2,3,4,5\nRowSize = ($ - table)\n\t  QWORD 6,7,8,9,10\n     QWORD 11,12,13,14,15\n   \n.code\nmain proc\n; base-index-displacement operands\n\n\tmov\trax,1\t\t\t\t\t; row index (zero-based)\n\tmov\trsi,4\t\t\t\t\t; column index (zero based)\n\tcall\tget_tableVal\t\t; returns the value in RAX\n\tcall\tWriteInt64\t\t\t; and display it\n\tcall\tCrlf\n\n\tmov   ecx,0\t\t\t; assign a process return code\n\tcall  ExitProcess\t; terminate the program\nmain endp\n\n;------------------------------------------------------\n; get_tableVal\n; Returns the array value at a given row and column\n; in a two-dimensional array of quadwords.\n; Receives: RAX = row number, RSI = column number\n; Returns:  value in RAX\n;------------------------------------------------------\nget_tableVal proc uses rbx\n\tmov\trbx,RowSize\n\tmul\trbx\t\t\t\t; product(low) = RAX\n\tmov\trax,table[rax + rsi*TYPE table]\n\n\tret\nget_tableVal endp"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\AllPoints.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Fibon.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\HelloNew.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\List.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Macro1.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Macro2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Macro3.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\MacroTest.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Repeat.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\RowSum.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\ShowTime.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Struct1.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Struct2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\TestDump.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Union.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Walk.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Wraps.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\AllPoints.asm",
        "snippet": "; Loop Through Array       (AllPoints.asm)\n\n; Loop through the array of points and set their\n; X and Y values.\n\nINCLUDE Irvine32.inc\nNumPoints = 3\n.data\nALIGN WORD\nAllPoints COORD NumPoints DUP(<0,0>)\n\n.code\nmain PROC\n\tmov\tedi,0\t\t\t\t; array index\n\tmov\tecx,NumPoints\t\t\t; loop counter\n\tmov\tax,1\t\t\t\t\t; starting X, Y values\n\nL1:\tmov\t(COORD PTR AllPoints[edi]).X,ax\n\tmov\t(COORD PTR AllPoints[edi]).Y,ax\n\tadd\tedi,TYPE COORD\n\tinc\tax\n\tloop L1\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Fibon.asm",
        "snippet": "; Fibonacci Numbers            (Finbon.asm)\n\n; This program shows how use the WHILE directive\n; to generate doubleword variables containing\n; all Fibonacci numbers less than a given limit.\n\nINCLUDE Irvine32.inc\n\n.data\nval1  = 1\nval2  = 1\nDWORD val1\t\t; first two values\nDWORD val2\nval3 = val1 + val2\n\nWHILE val3 LT 0F0000000h\n\tDWORD val3\n\tval1 = val2\n\tval2 = val3\n\tval3 = val1 + val2\nENDM\n\n.code\nmain PROC\n\n\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\HelloNew.asm",
        "snippet": "; Macro Functions            (HelloNew.asm)\n\n; Shows how to use macros to configure\n; a program to run on multiple platforms.\n\nINCLUDE Macros.inc\nIF IsDefined( RealMode )\n\tINCLUDE Irvine16.inc\nELSE\n\tINCLUDE Irvine32.inc\nENDIF\n\n.code\nmain PROC\n\tStartup\n\n\tmWrite <\"This program can be assembled to run \",0dh,0ah>\n\tmWrite <\"in both Real mode and Protected mode.\",0dh,0ah>\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\List.asm",
        "snippet": "; Creating a Linked List            (List.asm)\n\n; This program shows how the STRUC directive\n; and the REPT directive can be combined to\n; create a linked list at assembly time.\n\nINCLUDE Irvine32.inc\n\nListNode STRUCT\n  NodeData DWORD ?\n  NextPtr  DWORD ?\nListNode ENDS\n\nTotalNodeCount = 15\nNULL = 0\nCounter = 0\n\n.data\nLinkedList LABEL PTR ListNode\nREPT TotalNodeCount\n\tCounter = Counter + 1\n;\tListNode <Counter, ($ + SIZEOF ListNode)>\t\t\t; TRY THIS\n\tListNode <Counter, ($ + Counter * SIZEOF ListNode)>\nENDM\nListNode <0,0>\t; tail node\n\n.code\nmain PROC\n\tmov  esi,OFFSET LinkedList\n\n; Display the integers in the NodeData members.\nNextNode:\n\t; Check for the tail node.\n\tmov  eax,(ListNode PTR [esi]).NextPtr\n\tcmp  eax,NULL\n\tje   quit\n\n\t; Display the node data.\n\tmov  eax,(ListNode PTR [esi]).NodeData\n\tcall WriteDec"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Macro1.asm",
        "snippet": "TITLE Macro Examples - 1            (Macro1.ASM)\n\n; This program demonstrates the MACRO directive.\n\nINCLUDE Irvine32.inc\nINCLUDE macros.inc\n\nmPutchar MACRO char\n\tpush eax\n\tmov  al,char\n\tcall WriteChar\n\tpop  eax\nENDM\n\nmPrintChar MACRO char,count\nLOCAL temp\n.data\ntemp BYTE count DUP(&char),0\n.code\n\tpush\tedx\n\tmov\tedx,OFFSET temp\n\tcall\tWriteString\n\tpop\tedx\nENDM\n\nmWriteAt MACRO X,Y,literal\n\tmGotoxy X,Y\n\tmWrite literal\nENDM\n\n\nmPromptInteger MACRO prompt,returnVal\n\tmWrite prompt\n\tcall\tReadInt\n\tmov\treturnVal,eax\nENDM\n.data\nminVal DWORD ?\n\n.code"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Macro2.asm",
        "snippet": "; Useful Macros                  (Macro2.ASM)\n\n; This program demonstrates several useful macros:\n; mGotoxy, mWrite, mWriteLn, mWriteStr, mReadStr,\n; and mDumpMem.\n\nINCLUDE Irvine32.inc\n\n;-----------------------------------------------------\nmWriteStr MACRO buffer\n;\n; Improved version of mWriteStr that checks for\n; a blank argument.\n;-----------------------------------------------------\n\tIFB <buffer>\n\t  ECHO -----------------------------------------\n\t  ECHO *  Error: parameter missing in mWriteStr\n\t  ECHO *  (no code generated)\n\t  ECHO -----------------------------------------\n\t  EXITM\n\tENDIF\n\tpush edx\n\tmov  edx,OFFSET buffer\n\tcall WriteString\n\tpop  edx\nENDM\n\n;-----------------------------------------------------\nmWrite MACRO text\n;\n; No changes to this macro.\n;-----------------------------------------------------\n\tLOCAL string\n\t.data\t\t;; local data\n\tstring BYTE text,0\t\t;; define the string\n\t.code\n\tpush edx\n\tmov  edx,OFFSET string\n\tcall Writestring\n\tpop  edx"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Macro3.asm",
        "snippet": "; Using Macro Conditional Expressions          (Macro3.asm)\n\n; The MUL32 macro issues a warning and exits if EAX\n; is passed as the second argument. The Text macro LINENUM\n; must be defined first. Then, the % (expansion operator)\n; in the first column of the line containing the ECHO statement\n; causes LINENUM to be expanded into the source file line\n; number where the macro is being expanded. It is important\n; to define LINENUM inside the macro--otherwise, it just\n; returns the line number where LINENUM is declared.\n\nINCLUDE Irvine32.inc\n\nMUL32 MACRO op1, op2, product\n\tIFIDNI <op2>,<EAX>\n\t  LINENUM TEXTEQU %(@LINE)\n\t  ECHO --------------------------------------------------\n%\t  ECHO *  Error on line LINENUM: EAX cannot be the second\n\t  ECHO *  argument when invoking the MUL32 macro.\n\t  ECHO --------------------------------------------------\n\tEXITM\n\tENDIF\n\tpush eax\n\tmov  eax,op1\n\tmul  op2\n\tmov  product,eax\n\tpop  eax\nENDM\n\n.data\nval1 DWORD 1234h\nval2 DWORD 1000h\nval3 DWORD ?\narray DWORD 1,2,3,4,5,6,7,8\n\n.code\nmain PROC\n; The following do not evaluate SIZEOF:\n\tECHO The array contains (SIZEOF array) bytes\n\tECHO The array contains %(SIZEOF array) bytes"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\MacroTest.asm",
        "snippet": "; Macro Library Test               (MacroTest.asm)\n\n; This program demonstrates various macros from\n; the Macros.inc file.\n\nINCLUDE Irvine32.inc\nINCLUDE Macros.inc\n\nNAME_SIZE = 50\n\n.data\nstr1 BYTE NAME_SIZE DUP(0)\narray DWORD 5 DUP(12345678h)\n\n.code\nmain PROC\n\tcall Clrscr\n\tmGotoxy 20,0\n\tmDumpMem OFFSET array,\t\\\t; array offset\n\t  LENGTHOF array,\t\\\t\t; number of units\n\t  TYPE array\t\t\t\t; size of each unit\n\n\tmGotoxy 10,8\n\tmWrite \"Please enter your first name: \"\n\tmReadString str1\n\n\tmGotoxy 10,10\n\tmWrite \"Your name is \"\n\tmWriteString str1\n\tcall  Crlf\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\Repeat.asm",
        "snippet": "; Repeat Block Examples         (Repeat.asm)\n\n; This program demonstrates the REPEAT, FOR,\n; FORC, and WHILE directives.\n\nINCLUDE Irvine32.inc\nINCLUDE Macros.inc\n\nCOURSE STRUCT\n  Number  BYTE 9 DUP(?)\n  Credits BYTE ?\nCOURSE ENDS\n\n; A semester contains an array of courses.\nSEMESTER STRUCT\n\tCourses COURSE 6 DUP(<>)\n\tNumCourses WORD ?\nSEMESTER ENDS\n\n.data\n\n; Create a character lookup table:\nDelimiters LABEL BYTE\nFORC code,<@#$%^&*!<!>>\n  BYTE \"&code\"\nENDM\nBYTE 0  \t\t\t; marks the end\n\n; Generate Fibonacci numbers up to 0FFFFh\nf1  = 1\nf2  = 1\nf3 = f1 + f2\nDWORD f1,f2\n\nWHILE f3 LT 0FFFFh\n\tDWORD f3\n\tf1 = f2\n\tf2 = f3\n\tf3 = f1 + f2\nENDM"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\RowSum.asm",
        "snippet": "TITLE Row Sum Calculation               (RowSumMacro.asm)\n\nComment !\nTests the mCalc_row_sum macro.\n!\n\nINCLUDE Irvine32.inc\n\n;------------------------------------------------------------\nmCalc_row_sum MACRO index, arrayOffset, rowSize, eltType\n; Calculates the sum of a row in a two-dimensional array.\n;\n; Receives: row index, offset of the array, number of bytes\n; in each table row, and the array type (BYTE, WORD, or DWORD).\n; Returns: EAX = sum.\n;-------------------------------------------------------------\nLOCAL L1\n\tpush ebx ; save changed regs\n\tpush ecx\n\tpush esi\n\n; set up the required registers\n\tmov eax,index\n\tmov ebx,arrayOffset\n\tmov ecx,rowSize\n\n; calculate the row offset.\n\tmul ecx\t\t\t\t\t\t\t; row index * row size\n\tadd ebx,eax\t\t\t\t\t\t; row offset\n\n; prepare the loop counter.\n\tshr ecx,(TYPE eltType / 2) ; byte=0, word=1, dword=2\n\n; initialize the accumulator and column indexes\n\tmov eax,0\t\t\t\t\t\t; accumulator\n\tmov esi,0\t\t\t\t\t\t; column index\n\nL1: \n\tIFIDNI <eltType>, <DWORD>\n\t\tmov\tedx,eltType PTR[ebx + esi*(TYPE eltType)]"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\64-bit",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\64-bit\\RowSum.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch10\\64-bit\\RowSum.asm",
        "snippet": "; 64-bit Row Sum Calculation         (RowSum.asm)\n\nComment !\nTests the mCalc_row_sum macro.\n!\n\nExitProcess PROTO\nWriteHex64 PROTO\nCrlf PROTO\n\n;------------------------------------------------------------\nmCalc_row_sum MACRO index, arrayOffset, rowSize, eltType\n; Calculates the sum of a row in a two-dimensional array.\n;\n; Receives: row index, offset of the array, number of bytes\n; in each table row, and the array type (BYTE, WORD, or DWORD).\n; Returns: RAX = sum.\n;-------------------------------------------------------------\nLOCAL L1\n\tpush rbx\t\t; save changed regs\n\tpush rcx\n\tpush rsi\n\n; set up the required registers\n\tmov rax,index\n\tmov rbx,arrayOffset\n\tmov rcx,rowSize\n\n; calculate the row offset.\n\tmul rcx\t\t\t\t\t\t\t; row index * row size\n\tadd rbx,rax\t\t\t\t\t\t; row offset\n\n; prepare the loop counter.\n\tshr rcx,(TYPE eltType / 2)\t\t; byte=0, word=1, dword=2\n\n; initialize the accumulator and column indexes\n\tmov rax,0\t\t\t\t\t\t; accumulator\n\tmov rsi,0\t\t\t\t\t\t; column index\n\nL1:"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\AppendFile.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\CheckError.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\Console1.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\Console2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\CreateFile.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\HeapTest1.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\HeapTest2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\Keybd.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\MessageBox.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\PeekInput.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\ReadCharTest.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\ReadConsole.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\ReadFile.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\Scroll.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\template.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\TestReadkey.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\Timer.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\TimingLoop.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\WinApp.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\WriteColors.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\WriteFile.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\AppendFile.asm",
        "snippet": "; Appending to a File                   (AppendFile.asm)\n\n; This program appends text to an existing file.\n\nINCLUDE Irvine32.inc\n\n.data\nbuffer BYTE \"This text is appended to an output file.\",0dh,0ah\nbufSize DWORD ($-buffer)\nerrMsg BYTE \"Cannot open file\",0dh,0ah,0\nfilename     BYTE \"output.txt\",0\nfileHandle   HANDLE ?\t\t\t; handle to output file\nbytesWritten DWORD ?    \t\t\t; number of bytes written\n\n.code\nmain PROC\n\tINVOKE CreateFile,\n\t  ADDR filename, GENERIC_WRITE, DO_NOT_SHARE, NULL,\n\t  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0\n\n\tmov fileHandle,eax\t\t\t; save file handle\n\t.IF eax == INVALID_HANDLE_VALUE\n\t  mov  edx,OFFSET errMsg\t\t; Display error message\n\t  call WriteString\n\t  jmp  QuitNow\n\t.ENDIF\n\n\t; Move the file pointer to the end of the file\n\tINVOKE SetFilePointer,\n\t  fileHandle,0,0,FILE_END\n\n\t; Append text to the file\n\tINVOKE WriteFile,\n\t    fileHandle, ADDR buffer, bufSize,\n\t    ADDR bytesWritten, 0\n\n\tINVOKE CloseHandle, fileHandle\n\nQuitNow:\n\texit"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\CheckError.asm",
        "snippet": "; Check for Errors             (CheckError.asm)\n\n; Demonstrates the WriteWindowsMsg function when\n; handling a Windows API error.\n\nINCLUDE Irvine32.inc\n\n.data\nfilename    BYTE \"nonexistentfile.txt\",0\nfileHandle  DWORD ?\n\n.code\nmain PROC\n\n; Attempt to open a file.\n\tmov\tedx,OFFSET filename\n\tcall\tOpenInputFile\n\tmov\tfileHandle,eax\n\n; Check for errors.\n\t.IF eax == INVALID_HANDLE_VALUE\n\tcall\tWriteWindowsMsg\n\tjmp\tquit\n\t.ENDIF\n\n; Close the file handle.\n\tmov\teax,fileHandle\n\tcall\tCloseFile\n\nquit:\n\texit\nmain ENDP\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\Console1.asm",
        "snippet": "; Win32 Console Example #1                (Console1.asm)\n\n; This program calls the following Win32 Console functions:\n; GetStdHandle, ExitProcess, WriteConsole\n\nINCLUDE Irvine32.inc\n\n.data\nendl EQU <0dh,0ah>\t\t\t; end of line sequence\n\nmessage LABEL BYTE\n\tBYTE \"This program is a simple demonstration of \"\n\tBYTE \"console mode output, using the GetStdHandle \"\n\tBYTE \"and WriteConsole functions.\", endl\nmessageSize DWORD ($-message)\n\nconsoleHandle HANDLE 0     ; handle to standard output device\nbytesWritten  DWORD ?      ; number of bytes written\n\n.code\nmain PROC\n  ; Get the console output handle:\n\tINVOKE GetStdHandle, STD_OUTPUT_HANDLE\n\tmov consoleHandle,eax\n\n  ; Write a string to the console:\n\tINVOKE WriteConsole,\n\t  consoleHandle,\t\t; console output handle\n\t  ADDR message,       \t; string pointer\n\t  messageSize,\t\t\t; string length\n\t  ADDR bytesWritten,\t; returns num bytes written\n\t  0\t\t\t\t\t; not used\n\n\tINVOKE ExitProcess,0\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\Console2.asm",
        "snippet": "; Console Demo #2                (Console2.asm)\n\n; Demonstration of SetConsoleCursorPosition,\n; GetConsoleCursorInfo, SetConsoleCursorInfo,\n; SetConsoleScreenBufferSize, SetConsoleCursorPosition,\n; SetConsoleTitle, and GetConsoleScreenBufferInfo.\n\nINCLUDE SmallWin.inc\n\n.data\noutHandle    DWORD ?\nscrSize COORD <120,50>\nxyPos COORD <20,5>\nconsoleInfo CONSOLE_SCREEN_BUFFER_INFO <>\ncursorInfo CONSOLE_CURSOR_INFO <>\ntitleStr BYTE \"Console2 Demo Program\",0\n\n.code\nmain PROC\n  ; Get Console output handle.\n\tINVOKE GetStdHandle,STD_OUTPUT_HANDLE\n\tmov outHandle,eax\n\n\t; Get console cursor information.\n\tINVOKE GetConsoleCursorInfo, outHandle,\n\t  ADDR cursorInfo\n\n\t; Set console cursor size to 75%\n\tmov cursorInfo.dwSize,75\n\tINVOKE SetConsoleCursorInfo, outHandle,\n\t  ADDR cursorInfo\n\n\t; Set the screen buffer size.\n\tINVOKE SetConsoleScreenBufferSize,\n\t  outHandle,scrSize\n\n  \t; Set the cursor position to (20,5).\n\tINVOKE SetConsoleCursorPosition, outHandle, xyPos\n\n  \t; Set the console window's title."
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\CreateFile.asm",
        "snippet": "; Creating a File\t\t\t\t\t(CreateFile.asm)\n\n; Inputs text from the user, writes the text to an output file. \n\nINCLUDE Irvine32.inc  \n\nBUFFER_SIZE = 501\n.data\nbuffer BYTE BUFFER_SIZE DUP(?)\nfilename     BYTE \"output.txt\",0\nfileHandle   HANDLE ?\nstringLength DWORD ?\nbytesWritten DWORD ?\nstr1 BYTE \"Cannot create file\",0dh,0ah,0\nstr2 BYTE \"Bytes written to file [output.txt]: \",0\nstr3 BYTE \"Enter up to 500 characters and press \"\n     BYTE \"[Enter]: \",0dh,0ah,0\n\n.code\nmain PROC\n; Create a new text file.\n\tmov\tedx,OFFSET filename\n\tcall\tCreateOutputFile\n\tmov\tfileHandle,eax\n\n; Check for errors.\n\tcmp\teax, INVALID_HANDLE_VALUE\t; error found?\n\tjne\tfile_ok\t\t\t\t\t; no: skip\n\tmov\tedx,OFFSET str1\t\t\t; display error\n\tcall\tWriteString\n\tjmp\tquit\nfile_ok:\n\n; Ask the user to input a string.\n\tmov\tedx,OFFSET str3\t\t; \"Enter up to ....\"\n\tcall\tWriteString\n\tmov\tecx,BUFFER_SIZE\t\t; Input a string\n\tmov\tedx,OFFSET buffer\n\tcall\tReadString\n\tmov\tstringLength,eax\t\t; counts chars entered"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\HeapTest1.asm",
        "snippet": "; Heap Test #1                          (Heaptest1.asm)\n\nINCLUDE Irvine32.inc\n\n; This program uses dynamic memory allocation to allocate and \n; fill an array of bytes. \n\n.data\nARRAY_SIZE = 1000\nFILL_VAL EQU 0FFh\n\nhHeap   DWORD ?\t\t; handle to the process heap\npArray  DWORD ?\t\t; pointer to block of memory\nnewHeap DWORD ?\t\t; handle to new heap\nstr1 BYTE \"Heap size is: \",0\n\n.code\nmain PROC\n\tINVOKE GetProcessHeap\t\t; get handle to prog's heap\n\t.IF eax == NULL\t\t\t; failed?\n\tcall\tWriteWindowsMsg\n\tjmp\tquit\n\t.ELSE\n\tmov\thHeap,eax\t\t; success\n\t.ENDIF\n\n\tcall\tallocate_array\n\tjnc\tarrayOk\t\t; failed (CF = 1)?\n\tcall\tWriteWindowsMsg\n\tcall\tCrlf\n\tjmp\tquit\n\narrayOk:\t\t\t\t; ok to fill the array\n\tcall\tfill_array\n\tcall\tdisplay_array\n\tcall\tCrlf\n\n\t; free the array\n\tINVOKE HeapFree, hHeap, 0, pArray"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\HeapTest2.asm",
        "snippet": "; Heap Test #2                     (Heaptest2.asm)\n\nINCLUDE Irvine32.inc\n\n; Creates a heap and allocates multiple memory blocks, \n; expanding the heap until it fails.\n\n.data\nHEAP_START =   2000000\t;   2 MB\nHEAP_MAX  =  400000000\t; 400 MB\nBLOCK_SIZE =    500000\t;  .5 MB\n\nhHeap DWORD ?\t\t\t; handle to the heap\npData DWORD ?\t\t\t; pointer to block\n\nstr1 BYTE 0dh,0ah,\"Memory allocation failed\",0dh,0ah,0\n\n.code\nmain PROC\n\tINVOKE HeapCreate, 0,HEAP_START, HEAP_MAX\n\n\t.IF eax == NULL\t\t; failed?\n\tcall\tWriteWindowsMsg\n\tcall\tCrlf\n\tjmp\tquit\n\t.ELSE\n\tmov\thHeap,eax \t\t; success\n\t.ENDIF\n\n\tmov\tecx,2000\t\t\t; loop counter\n\nL1:\tcall allocate_block\t\t; allocate a block\n\t.IF Carry?\t\t\t; failed?\n\tmov\tedx,OFFSET str1\t; display message\n\tcall\tWriteString\n\tjmp\tquit\n\t.ELSE\t\t\t\t; no: print a dot to\n\tmov\tal,'.'\t\t\t; show progress\n\tcall\tWriteChar\n\t.ENDIF"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\Keybd.asm",
        "snippet": "; Keyboard Toggle Keys             (Keybd.asm)\n\n; This program shows how to detect the states of various\n; keyboard toggle keys. Before you run the program, hold\n; down a selected key.\n\nINCLUDE Irvine32.inc\nINCLUDE Macros.inc\n\n; GetKeyState sets bit 0 in EAX if a toggle key is\n; currently on (CapsLock, NumLock, ScrollLock).\n; It sets the high bit of EAX if the specified key is\n; currently down.\n\n.code\nmain PROC\n\n\tINVOKE GetKeyState, VK_NUMLOCK\n\ttest al,1\n\t.IF !Zero?\n\t  mWrite <\"The NumLock key is ON\",0dh,0ah>\n\t.ENDIF\n\n\tINVOKE GetKeyState, VK_LSHIFT\n\tcall DumpRegs\n\ttest eax,80000000h\n\t.IF !Zero?\n\t  mWrite <\"The Left Shift key is currently DOWN\",0dh,0ah>\n\t.ENDIF\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\MessageBox.asm",
        "snippet": "; Demonstrate MessageBoxA           (MessageBox.asm)\n\n; Demonstration of the Windows API MessageBox function, using\n; various icons and button configurations.\n\nINCLUDE Irvine32.inc\n\n.data\ncaptionW\t\tBYTE \"Warning\",0\nwarningMsg\tBYTE \"The current operation may take years \"\n\t\t\t\tBYTE \"to complete.\",0\n\ncaptionQ\t\tBYTE \"Question\",0 \nquestionMsg\tBYTE \"A matching user account was not found.\"\n\t\t\t\tBYTE 0dh,0ah,\"Do you wish to continue?\",0\t\n\ncaptionC\t\tBYTE \"Information\",0\ninfoMsg\t\tBYTE \"Select Yes to save a backup file \"\n\t\t\t\tBYTE \"before continuing,\",0dh,0ah\n\t\t\t\tBYTE \"or click Cancel to stop the operation\",0\n\ncaptionH\t\tBYTE \"Cannot View User List\",0\nhaltMsg\t\tBYTE \"This operation not supported by your \"\n\t\t\t\tBYTE \"user account.\",0\t            \n\n.code\nmain PROC\n\n; Display Exclamation icon with OK button\n\tINVOKE MessageBox, NULL, ADDR warningMsg, \n\t\tADDR captionW, \n\t\tMB_OK + MB_ICONEXCLAMATION\n\n; Display Question icon with Yes/No buttons\n\tINVOKE MessageBox, NULL, ADDR questionMsg, \n\t\tADDR captionQ, MB_YESNO + MB_ICONQUESTION\n\t\t\n\t; interpret the button clicked by the user\t\n\tcmp\teax,IDYES\t\t; YES button clicked?"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch11\\PeekInput.asm",
        "snippet": "; Using PeekConsoleInput          (PeekInput.asm)\n\nCOMMENT @\nThis program shows how to get single key input by\ncalling PeekConsoleInput.\nThanks to Richard Stam for his first version of this code.\n\nMore analysis is still to be done on this topic, because the\ncurrent version does not recognize keyboard combinations such as\nCtrl-F1 or Alt-F2. The Ctrl and Shift keys are returned as separate\nkeystrokes in themselves. The MS-Windows virtual keycodes do not\nseem to include these combinations.\n@\n\nINCLUDE Irvine32.inc\nINCLUDE Macros.inc\n\nEVENT_BUFFER_SIZE = 1\n\n.data\ninputKey    BYTE ?\nstdInHandle DWORD ?\n\n.code\nmain PROC\n\t;For testing purposes only. Irvine32.lib already does this.\n\tINVOKE GetStdHandle, STD_INPUT_HANDLE\n\tmov stdInHandle,eax\n\n\t;Empties the console input buffer. All console programs\n\t;put a FOCUS_EVENT in the buffer when the program starts\n\t;Later, we'll add this to the Initialize proc in Irvine32.lib.\n\tINVOKE FlushConsoleInputBuffer, stdInHandle\n\nL1:\n\tmov  eax,100\t\t; sleep, to allow OS timeslicing\n\tcall Delay\n\tcall ReadKey_\t\t; not the one in Irvine32 library\n\tjz   L1\t\t\t; no key pressed yet"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\Exceptions.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\Expr.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\expressions.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\FCompare.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\floatTest32.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\fltTst16.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\LoadAndStore.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\LossOfPrecision.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\MixedMode.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\Exceptions.asm",
        "snippet": "; Unmasking an Exception  \t(Exceptions.asm)\n\n; This program shows how to mask (set) and unmask (clear) the divide by zero\n; exception flag.\n\nINCLUDE Irvine32.inc\n\n.data\nctrlWord WORD ?\nval1 DWORD 1\nval2 REAL8 0.0\n\n.code\nmain PROC\n\tfinit\t\t; initialize FPU (divide by zero is masked)\n\n; By unmasking, we enable the divide by zero exception.\n\n\tfstcw\tctrlWord\t\t\t\t; get the control word\n\tand\tctrlWord,1111111111111011b\t; unmask Divide by 0\n\tfldcw\tctrlWord\t\t\t\t; load it back into FPU\n\n\tfild\tval1\n\tfdiv\tval2\t\t\t\t\t\t; divide by zero\n\tfst\tval2\n\t\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\Expr.asm",
        "snippet": "; FPU Expression Evaluation              (Expr.asm)\n\n; This program implements the following expression, using \n; floating-point instructions:\n\n;     (6.0 * 2.0) + (4.5 * 3.2)\n\nINCLUDE Irvine32.inc\t; 32-bit Protected mode program.\n\n.data\narray      REAL4 6.0, 2.0, 4.5, 3.2\ndotProduct REAL4 ?\n\n.code\nmain PROC\n\tfinit\t\t\t; initialize FPU\n\t\n\tfld\tarray\t\t; push 6.0 onto the stack\n\tfmul\tarray+4\t\t; ST(0) = 6.0 * 2.0\n\tcall\tShowFPUStack\n\t\n\tfld\tarray+8\t\t; push 4.5 onto the stack\n\tfmul\tarray+12\t\t; ST(0) = 4.5 * 3.2\n\tcall\tShowFPUStack\n\t\n\tfadd\t \t\t\t; ST(0) = ST(0) + ST(1)\n\tcall\tShowFPUStack\n\tfstp\tdotProduct  \t; pop stack into memory operand\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\expressions.asm",
        "snippet": "; Floating-Point Expressions          (Expressions.asm)\n\n; This program shows how different mathematical\n; expressions are coded in floating-point instructions.\n\nINCLUDE Irvine32.inc\nINCLUDE macros.inc\n\n.code\nmain PROC\n\tfinit\n\n;---------------- Test FIDIV -------------------\n.data\nintOne WORD 20\nintTwo WORD 10\n.code\n\tfild\tintOne\n\tfidiv\tintTwo\n\tcall\tShowFPUStack\n\texit\n\n; ------------------ Calculate X^Y ------------\n.data\nxVal REAL8 2.0\nyVal REAL8 5.0\n.code\n\tfld\tyVal\t\t\t; 5\n\tf2xm1\n\tcall\tShowFPUStack\t; 2^5 - 1\n\n\tfld\tyVal\n\tfld\txVal\n\tfyl2X\n\tcall\tShowFPUStack\t; X = ST(0)\n\tf2xm1\n\tcall\tShowFPUStack\t; X = ST(0)\n\tfincstp\n\tcall\tShowFPUStack\t; X = ST(0)"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\FCompare.asm",
        "snippet": "; Comparing Floating-Point Values\t\t(FCompare.asm)\n\n; This program demonstrates ways of comparing\n; floating-point values.\n\nINCLUDE Irvine32.inc\nINCLUDE macros.inc\n\n.code\nmain PROC\n\n\tcall compare_for_equality\n\tcall compare_for_inequality\n\n\texit\nmain ENDP\n\n;--------------------------------------------------\ncompare_for_equality PROC\n;--------------------------------------------------\n.data\nepsilon REAL8 1.0E-12\nval2 REAL8 0.0\t\t\t\t\t; value to compare\nval3 REAL8 1.001E-13\t\t\t; considered equal to val2\n\n.code \n; if( val2 == val3 )\n;    display \"Values are equal\"\n\n\tfld\tepsilon\n\tcall\tShowFPUStack\n\t\n\tfld\tval2\n\tcall\tShowFPUStack\n\t\n\tfsub\tval3\n\tcall\tShowFPUStack\n\t\n\tfabs\n\tcall\tShowFPUStack"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\floatTest32.asm",
        "snippet": "; 32-bit Floating-Point I/O Test  \t(floatTest32.asm)\n\n; This program demonstrates floating-point\n; I/O procedures in the Irvine32 library.\n\nINCLUDE Irvine32.inc\nINCLUDE macros.inc\n\n.data\nfirst  REAL8 123.456\nsecond REAL8 10.0\nthird  REAL8 ?\n\n.code\nmain PROC\n\tfinit\t\t\t\t\t; initialize FPU\n\n; Push two floats and display the FPU stack.\n\tfld\tfirst\n\tfld\tsecond\n\tcall\tShowFPUStack\n\n; Input two floats and display their product.\n\tmWrite \"Please enter a real number: \"\n\tcall\tReadFloat\n\t\n\tmWrite \"Please enter a real number: \"\n\tcall\tReadFloat\n\t\n\tfmul\tST(0),ST(1)\t\t\t; multiply\n\t\n\tmWrite \"Their product is: \"\n\tcall\tWriteFloat\n\tcall\tCrlf\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\fltTst16.asm",
        "snippet": "; 16-bit Floating-Point I/O Test \t(fltTst16.asm)\n\n; Testing floating-point procedures in the Irvine16 library.\n\nINCLUDE Irvine16.inc\nINCLUDE macros.inc\n\n.data\nfirst  REAL8 123.456\nsecond REAL8 10.0\nthird  REAL8 ?\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\tfinit\t\t; initialize FPU\n\n; Add two floats, display their sum, and\n; display the FPU stack.\n\n\tfld\tfirst\n\tfadd\tsecond\n\tcall\tWriteFloat\n\tcall\tShowFPUStack\n\n; Input two floats and display their sum.\n\n\tmWrite \"Please enter a real number: \"\n\tcall\tReadFloat\n\t\n\tmWrite \"Please enter a real number: \"\n\tcall\tReadFloat\n\t\n\tfadd\tST(0),ST(1)\n\t\n\tmWrite \"Their sum is: \"\n\tcall\tWriteFloat\n\tcall\tCrlf"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\LoadAndStore.asm",
        "snippet": "; Load and Store (floats)       (LoadAndStore.asm)\n\n; This program demonstrates the use of Load and Store \n; instructions in the FPU instruction set.\n\nINCLUDE Irvine32.inc\n\n.code\nmain PROC\n\n.data\ndblOne   REAL8  1234.56\ndblTwo   REAL8  10.1\n\ndblThree REAL8 ?\ndblFour  REAL8 ?\n\nbigVal   REAL10 1.0123456789012345E+864\n\n.code\n\tfinit\n\t\n; Load a large value onto the stack, pop it \n; back into the same variable.\n\tfld\tbigVal\t\n\tfstp\tbigVal\n\n; Load two operands onto the stack\n\tfld\tdblOne\n\tfld\tdblTwo\n\tcall\tShowFPUStack\n\t\n; Store operands into memory, pop from stack\t\n\tfstp\tdblThree\n\tcall\tShowFPUStack\n\n\tfstp\tdblFour\n\tcall\tShowFPUStack\n\t\n    exit"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\LossOfPrecision.asm",
        "snippet": "; Floating-Point PrecisionLoss          (LossOfPrecision.asm)\n\n; This program demonstrates a simple rounding error in \n; often encountered in floating-point operations. Also, the\n; program shows how to compare real numbers by examining the\n; epsilon (absolute value of the difference) between the numbers.\n\nINCLUDE Irvine32.inc\nINCLUDE macros.inc\n\n.code\nmain PROC\n\tfinit\n\tcall\tshow_rounding_error\n\tcall\tcomparing_reals\n\n\texit\nmain ENDP\n\n;------------------------------------------\nshow_rounding_error PROC\n;------------------------------------------\n.data\nval1   REAL8 2.0\nresult REAL8 ?\n\n.code\n; multiply sqrt(2.0) * sqrt(2.0)\n\n\tfld\tval1\t\t\t\t; load val1 onto stack\n\tfsqrt\t\t\t\t\t; calculate its square root\n\tcall\tShowFPUStack\n\tfmul\tST(0),ST(0)\t\t; st(0) contains the product,\n\tcall\tShowFPUStack\t; which appears to equal 2.0\n\t\n; subtract 2.0\tfrom ST(0)\n\tfsub\tval1\n\tcall\tShowFPUStack\n\tfst\tresult"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch12\\MixedMode.asm",
        "snippet": "; Mixed-Mode FPU Arithmetic      (MixedMode.asm)\n\n; This program demonstrates mixed-mode arithmetic using \n; reals and integers. Also, it demonstrates the multiplication \n; and division of reals, as well as the SQRT instruction.\n\nINCLUDE Irvine32.inc\n\n.code\nmain PROC\n\n; ------------- Mixed-mode arithmetic ---------------\n; Implement the following expression: Z = (int) (N + X)\n.data\nN SDWORD 20\nX REAL8 3.5\nZ SDWORD ?\nctrlWord WORD ?\n\n.code\n\tfinit\t\t\t\t\t\t; initialize FPU\n\n; Demonstrates rounding upward.\n\tfild\tN\t\t\t\t\t\t; load integer into ST(0)\n\tfadd\tX\t\t\t\t\t\t; add mem to ST(0)\n\tfist\tZ \t\t\t\t\t\t; store ST(0) to mem int\n\tmov\teax,Z\t\t\t\t\t; sum: 24\n\n; Demonstrates truncation.\n\tfstcw ctrlWord\t\t\t\t\t; store control word\n\tor\t ctrlWord, 110000000000b\t\t; set the RC field to truncate\n\tfldcw ctrlWord\t\t\t\t\t; load control word\n\t\n\tfild\tN\t\t\t\t\t\t; load integer into ST(0)\n\tfadd\tX\t\t\t\t\t\t; add mem to ST(0)\n\tfist\tZ \t\t\t\t\t\t; store ST(0) to mem int\n\t\n\tfstcw ctrlWord\t\t\t\t\t; store control word\n\tand\t ctrlWord, 001111111111b\t\t; reset rounding to default\n\tfldcw ctrlWord\t\t\t\t\t; load control word"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Addem",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Addem\\addem.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Addem\\addMain.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Addem\\addem.asm",
        "snippet": "; The addem Subroutine    (addem.asm)\n\n; This subroutine links to Visual C++.\n\n.386P\n.model flat\npublic _addem\n\n.code\n_addem proc near\n    push   ebp\n    mov    ebp,esp\n    mov    eax,[ebp+16]    ; first argument\n    add    eax,[ebp+12]    ; second argument\n    add    eax,[ebp+8]     ; third argument\n    pop    ebp\n    ret                   \n_addem endp\nend"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Addem\\addMain.cpp",
        "snippet": "// Addem Main Program      (AddMain.cpp) \n\n#include <iostream>\nusing namespace std;\n\nextern \"C\" int addem(int p1, int p2, int p3);\n\nint main()\n{\n  int total = addem( 10, 15, 25 );\n  cout << \"Total = \" << total << endl;\n\n  return 0;\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_bak",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_bak\\ArraySum.cpp",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_bak\\ArraySum_debug.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_bak\\ArraySum_OLD.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_bak\\ArraySum_release.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_bak\\ArraySum.cpp",
        "snippet": "void MySub()\n{\n\tchar A = 'A';\n\tint B = 10;\n\tchar name[20];\n\tname[0] = 'B';\n\tdouble c = 1.2;\n}\n\n\nint ArraySum( int array[], int count )\n{\n\tint sum = 0;\n\n\tfor(int i = 0; i < count; i++)\n\t  sum += array[i];\n\t\n\treturn sum;\n}\n\n\nvoid main()\n{\n\tint Array[10] = {1,2,3,4,5,6,7,8,9,10};\n\n\tint sum = ArraySum( Array, 50 );\n\n}"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_bak\\ArraySum_debug.asm",
        "snippet": "; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 \n\n\tTITLE\t.\\ArraySum.cpp\n\t.386P\ninclude listing.inc\nif @Version gt 510\n.model FLAT\nelse\n_TEXT\tSEGMENT PARA USE32 PUBLIC 'CODE'\n_TEXT\tENDS\n_DATA\tSEGMENT DWORD USE32 PUBLIC 'DATA'\n_DATA\tENDS\nCONST\tSEGMENT DWORD USE32 PUBLIC 'CONST'\nCONST\tENDS\n_BSS\tSEGMENT DWORD USE32 PUBLIC 'BSS'\n_BSS\tENDS\n$$SYMBOLS\tSEGMENT BYTE USE32 'DEBSYM'\n$$SYMBOLS\tENDS\n$$TYPES\tSEGMENT BYTE USE32 'DEBTYP'\n$$TYPES\tENDS\n_TLS\tSEGMENT DWORD USE32 PUBLIC 'TLS'\n_TLS\tENDS\n;\tCOMDAT ?MySub@@YAXXZ\n_TEXT\tSEGMENT PARA USE32 PUBLIC 'CODE'\n_TEXT\tENDS\n;\tCOMDAT ?ArraySum@@YAHQAHH@Z\n_TEXT\tSEGMENT PARA USE32 PUBLIC 'CODE'\n_TEXT\tENDS\n;\tCOMDAT _main\n_TEXT\tSEGMENT PARA USE32 PUBLIC 'CODE'\n_TEXT\tENDS\nsxdata\tSEGMENT DWORD USE32 'SXDATA'\nsxdata\tENDS\nFLAT\tGROUP _DATA, CONST, _BSS\n\tASSUME\tCS: FLAT, DS: FLAT, SS: FLAT\nendif\n\nINCLUDELIB LIBCD\nINCLUDELIB OLDNAMES"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_bak\\ArraySum_OLD.asm",
        "snippet": "TITLE\tD:\\Kip\\AsmBook4\\Examples\\HLL_Linking\\VisualCPP\\ArraySum\\ArraySum.cpp\n\t.386P\ninclude listing.inc\n.model FLAT\n\nPUBLIC\t?MySub@@YAXXZ\t\t\t\t\t; MySub\nEXTRN\t__fltused:NEAR\n\n_TEXT\tSEGMENT\n\n_A$ = -4\n_B$ = -8\n_name$ = -28\n_c$ = -36\n\n?MySub@@YAXXZ PROC NEAR\t\t\t\t\t; MySub, COMDAT\n\n\tpush\tebp\n\tmov\tebp, esp\n\tsub\tesp, 100\t\t\t\t; local variables\n\tpush\tebx\n\tpush\tesi\n\tpush\tedi\n\n\tmov\tBYTE PTR _A$[ebp], 'A'    ; [ebp-4]\n\tmov\tDWORD PTR _B$[ebp], 10\t\t\t; [ebp-8]\n\tmov\tBYTE PTR _name$[ebp],'B'     ; [ebp-28]\n\tmov\tDWORD PTR _c$[ebp], 33333333H   ; [ebp-36]\n\tmov\tDWORD PTR _c$[ebp+4], 3ff33333H ; [ebp-32]\n\n\tpop\tedi\n\tpop\tesi\n\tpop\tebx\n\tmov\tesp, ebp\n\tpop\tebp\n\tret\t0\n?MySub@@YAXXZ ENDP\n\n_TEXT\tENDS\nPUBLIC\t?ArraySum@@YAHQAHH@Z\t\t\t\t; ArraySum"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_bak\\ArraySum_release.asm",
        "snippet": "; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 \n\n\tTITLE\t.\\ArraySum.cpp\n\t.386P\ninclude listing.inc\nif @Version gt 510\n.model FLAT\nelse\n_TEXT\tSEGMENT PARA USE32 PUBLIC 'CODE'\n_TEXT\tENDS\n_DATA\tSEGMENT DWORD USE32 PUBLIC 'DATA'\n_DATA\tENDS\nCONST\tSEGMENT DWORD USE32 PUBLIC 'CONST'\nCONST\tENDS\n_BSS\tSEGMENT DWORD USE32 PUBLIC 'BSS'\n_BSS\tENDS\n$$SYMBOLS\tSEGMENT BYTE USE32 'DEBSYM'\n$$SYMBOLS\tENDS\n$$TYPES\tSEGMENT BYTE USE32 'DEBTYP'\n$$TYPES\tENDS\n_TLS\tSEGMENT DWORD USE32 PUBLIC 'TLS'\n_TLS\tENDS\n;\tCOMDAT ?MySub@@YAXXZ\n_TEXT\tSEGMENT PARA USE32 PUBLIC 'CODE'\n_TEXT\tENDS\n;\tCOMDAT ?ArraySum@@YAHQAHH@Z\n_TEXT\tSEGMENT PARA USE32 PUBLIC 'CODE'\n_TEXT\tENDS\n;\tCOMDAT _main\n_TEXT\tSEGMENT PARA USE32 PUBLIC 'CODE'\n_TEXT\tENDS\nsxdata\tSEGMENT DWORD USE32 'SXDATA'\nsxdata\tENDS\nFLAT\tGROUP _DATA, CONST, _BSS\n\tASSUME\tCS: FLAT, DS: FLAT, SS: FLAT\nendif\n\nINCLUDELIB LIBC\nINCLUDELIB OLDNAMES"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_C\\ArraySum_C",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_C\\ArraySum_C\\ArraySum.c"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\ArraySum_C\\ArraySum_C\\ArraySum.c",
        "snippet": "// ArraySum.c\n\nint arraySum( int array[], int count )\n{\n\tint i;\n\tint sum = 0;\n\n\tfor(i = 0; i < count; i++)\n\t  sum += array[i];\n\t\n\treturn sum;\n}\n\n\nvoid main()\n{\n\tint array[10] = {1,2,3,4,5,6,7,8,9,10};\n\n\tint sum = arraySum( array, 50 );\n\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\C_Language_Project\\C_Language_Project",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\C_Language_Project\\C_Language_Project\\asmMain.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\C_Language_Project\\C_Language_Project\\main.c"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\C_Language_Project\\C_Language_Project\\asmMain.asm",
        "snippet": "TITLE Test Floating-point output       (asmMain.asm)\n\n; Test the printf and scanf functions from the C library.\n\nINCLUDE Irvine32.inc\n\nTAB = 9\n\n.code\nasmMain PROC C\n\n;---------- test the printf function --------------\n; Do not pass REAL4 variables to printf using INVOKE!\n\n.data\nformatTwo BYTE \"%.2f\",TAB,\"%.3f\",0dh,0ah,0\nval1 REAL8 456.789\nval2 REAL8 864.231\n.code\nINVOKE printf, ADDR formatTwo, val1, val2\n\n;--------- test the scanf function -------------\n.data\nstrSingle BYTE \"%f\",0\nstrDouble BYTE \"%lf\",0\nfloat1 REAL4 1234.567\ndouble1 REAL8  1234567.890123\n.code\n\n; Input a float, then a double:\n; INVOKE scanf, ADDR strSingle, ADDR float1\n; INVOKE scanf, ADDR strDouble, ADDR double1\n\n; --------------------------------------------------------\n; Passing a single - precision value to printf is tricky\n; because it expects the argument to be a double.\n; The following code emulates code generated by Visual C++.\n; It may not make much sense until you read Chapter 17.\n\n.data"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\C_Language_Project\\C_Language_Project\\main.c",
        "snippet": "// A C program\n\n#include <stdio.h>\n\nextern int asmMain();\n\nint main() {\n\tprintf(\"Hello world\\n\");\n\n\tasmMain();\n\n\tgetchar();\n\n\treturn 0;\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\DirectoryListing",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\DirectoryListing\\asmMain.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\DirectoryListing\\startup.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\DirectoryListing\\asmMain.asm",
        "snippet": "; ASM program launched from C++    (asmMain.asm)\n \n.586\n.MODEL flat,C\n\n; Standard C library functions:\nsystem PROTO, pCommand:PTR BYTE\nprintf PROTO, pString:PTR BYTE, args:VARARG\nscanf  PROTO, pFormat:PTR BYTE,pBuffer:PTR BYTE, args:VARARG\nfopen  PROTO, mode:PTR BYTE, filename:PTR BYTE\nfclose PROTO, pFile:DWORD\n\nBUFFER_SIZE = 5000\n.data\nstr1 BYTE \"cls\",0\nstr2 BYTE \"dir/w\",0\nstr3 BYTE \"Enter the name of a file: \",0\nstr4 BYTE \"%s\",0\nstr5 BYTE \"cannot open file\",0dh,0ah,0\nstr6 BYTE \"The file has been opened and closed\",0dh,0ah,0\nmodeStr BYTE \"r\",0\n\nfileName BYTE 60 DUP(0)\npBuf  DWORD ?\npFile DWORD ?\n\n.code\nasm_main PROC\n\n    ; clear the screen, display disk directory\n    INVOKE system,ADDR str1\n    INVOKE system,ADDR str2\n    \n    ; ask for a filename\n    INVOKE printf,ADDR str3\n    INVOKE scanf, ADDR str4, ADDR fileName\n\n    ; try to open the file\n    INVOKE fopen, ADDR fileName, ADDR modeStr\n    mov pFile,eax"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\DirectoryListing\\startup.cpp",
        "snippet": "// startup.cpp\n\n// stub module: launches assembly language program\n\nextern \"C\" void asm_main();\t\t// asm startup proc\n\nvoid main()\n{\n\tasm_main();\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Encode",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Encode\\Encode.cpp",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Encode\\translat.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Encode\\Encode.cpp",
        "snippet": "// ENCODE.CPP - Copy and encrypt a file.\n\n// Updated 6/30/05\n\n#include <iostream>\n#include <fstream>\n#include \"translat.h\"\n\nusing namespace std;\n\nint main( int argcount, char * args[] ) \n{  \n\t// Read input and output files from the command line.\n\tif( argcount < 3 ) {\n\t\tcout << \"Usage: encode infile outfile\" << endl;\n\t\treturn -1;\n\t}\n\n\tconst int BUFSIZE = 2000;\n\tchar buffer[BUFSIZE];\n\tunsigned int count;\t\t\t// character count\n  \n\tunsigned char encryptCode;\n\tcout << \"Encryption code [0-255]? \";\n\tcin >> encryptCode;\n\n\tifstream infile( args[1], ios::binary );\n\tofstream outfile( args[2], ios::binary );\n\n\tcout << \"Reading \" << args[1] << \" and creating \" \n\t\t<< args[2] << endl;\n\n\twhile (!infile.eof() )\n\t{\n\t\tinfile.read(buffer, BUFSIZE );\n\t\tcount = infile.gcount();\n\t\tTranslateBuffer(buffer, count, encryptCode);\n\t\toutfile.write(buffer, count);\n\t}\n\treturn 0;"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Encode\\translat.cpp",
        "snippet": "// translat.cpp\n\n#include \"translat.h\"\n\n\n/* Translate a buffer of <count> bytes, using an encryption\n   character <eChar>. Uses an XOR operation (ASM function).*/\n\nvoid TranslateBuffer( char * buf, unsigned count, \n                      unsigned char eChar )\n{\n  __asm {\n     mov esi,buf     ; set index register\n     mov ecx,count   /* set loop counter */\n     mov al,eChar \n  L1:\n     xor [esi],al\n     inc  esi\n     Loop L1\n } // asm\n\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Encode_Inline",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Encode_Inline\\Encode.cpp",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Encode_Inline\\translat.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Encode_Inline\\Encode.cpp",
        "snippet": "// ENCODE.CPP - Copy and encrypt a file.\n\n// Updated 6/28/05\n\n#include <iostream>\n#include <fstream>\n#include \"translat.h\"\n\nusing namespace std;\n\nvoid main( int argcount, char * args[] ) \n{  \n\t// Read input and output files from the command line.\n\tif( argcount < 3 ) {\n\t\tcout << \"Usage: encode infile outfile\" << endl;\n\t\treturn;\n\t}\n\n  const int BUFSIZE = 2000;\n  char buffer[BUFSIZE];\n  unsigned int count;\t\t\t\t// character count\n  \n  unsigned char encryptCode;\n  cout << \"Encryption code [0-255]? \";\n  cin >> encryptCode;\n\n  ifstream infile( args[1], ios::binary );\n  ofstream outfile( args[2], ios::binary );\n\n  cout << \"Reading \" << args[1] << \" and creating \" \n\t\t<< args[2] << endl;\n\n  while (!infile.eof() )\n  {\n    infile.read(buffer, BUFSIZE );\n    count = infile.gcount();\n\n    __asm {\n       lea esi,buffer\n       mov ecx,count"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Encode_Inline\\translat.cpp",
        "snippet": "// translat.cpp\n\n#include \"translat.h\"\n\n\n/* Translate a buffer of <count> bytes, using an encryption\n   character <eChar>. Uses an XOR operation (ASM function).*/\n\nvoid TranslateBuffer( char * buf, unsigned count, \n                      unsigned char eChar )\n{\n  __asm {\n     mov esi,buf     ; set index register\n     mov ecx,count   /* set loop counter */\n     mov al,eChar \n  L1:\n     xor [esi],al\n     inc  esi\n     Loop L1\n } // asm\n\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\IndexOf_asm",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\IndexOf_asm\\indexof.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\IndexOf_asm\\main.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\IndexOf_asm\\indexof.asm",
        "snippet": "; IndexOf function      (IndexOf.asm)\n\n.586\n.model flat,C\nIndexOf PROTO,\n\tsrchVal:DWORD, arrayPtr:PTR DWORD, count:DWORD\n\n.code\n;-----------------------------------------------\nIndexOf PROC uses ecx esi edi,\n\tsrchVal:DWORD, arrayPtr:PTR DWORD, count:DWORD\n;\n; Performs a linear search of a 32-bit integer array,\n; looking for a specific value. If the value is found,\n; the matching index position is returned in EAX; \n; otherwise, EAX equals -1.\n;-----------------------------------------------\n\tNOT_FOUND = -1\n\n \tmov  eax,srchVal    \t\t\t; search value\n \tmov  ecx,count      \t\t\t; array size\n\tmov  esi,arrayPtr\n\tmov  edi,0\t\t\t\t\t\t; index\n\nL1: cmp  [esi+edi*4],eax\n\tje   found\n\tinc\t edi\n\tloop L1\n\nnotFound:\t\n     mov  eax,NOT_FOUND\n     jmp  short exit\n\nfound:\n     mov\teax,edi\n\nexit:\n\t ret\t\t\t; EDI contains the index\nIndexOf ENDP\nEND"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\IndexOf_asm\\main.cpp",
        "snippet": "// main.cpp - Testing the IndexOf function.\n\n#include <iostream>\n#include <time.h>\n#include \"indexof.h\"\nusing namespace std;\n\nint main()  {\n\t// Fill an array with pseudorandom integers.\n\tconst unsigned ARRAY_SIZE = 100000; \n\tconst unsigned LOOP_SIZE = 30000;\n\tchar* boolstr[] = {\"false\",\"true\"};\n\n\tlong array[ARRAY_SIZE]; \n\tfor(unsigned i = 0; i < ARRAY_SIZE; i++) {\n     array[i] = rand() % 50000;\n\t}\n\t\n\tlong searchVal;\n\ttime_t startTime, endTime;\n\tcout << \"Enter an integer value to find: \";\n\tcin >> searchVal;\n\tcout << \"Please wait...\\n\";\n\n\t// Test the Assembly language function.\n\ttime( &startTime );\n\tlong index = 0;\n\n\tfor( unsigned n = 0; n < LOOP_SIZE; n++)\n\t\t index = IndexOf( searchVal, array, ARRAY_SIZE );\n\n\tbool found = index != -1;\n\n\ttime( &endTime );\n\tcout << \"Elapsed ASM time: \" << long(endTime - startTime) \n\t\t  << \" seconds. Found = \" << boolstr[found] << endl;\n\n\treturn 0;\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\IndexOf_cpp",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\IndexOf_cpp\\IndexOf.cpp",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\IndexOf_cpp\\main.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\IndexOf_cpp\\IndexOf.cpp",
        "snippet": "// IndexOf.cpp\n\n// Implements a linear search of an array of\n// long integers.\n\n#include \"indexof.h\"\n\nlong IndexOf( long searchVal, long array[], unsigned count )\n{\n\tfor(unsigned i = 0; i < count; i++) {\n\t\tif( array[i] == searchVal )\n\t\t\treturn i;\n\t}\n  return -1;\n}"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\IndexOf_cpp\\main.cpp",
        "snippet": "// main.cpp - Testing the IndexOf function.\n\n#include <iostream>\n#include <time.h>\n#include \"indexof.h\"\nusing namespace std;\n\nint main()  {\n\t// Fill an array with pseudorandom integers.\n\tconst unsigned ARRAY_SIZE = 100000; \n\tconst unsigned LOOP_SIZE = 30000;\n\tchar* boolstr[] = {\"false\",\"true\"};\n\n\tlong array[ARRAY_SIZE]; \n\tfor(unsigned i = 0; i < ARRAY_SIZE; i++)\n     array[i] = rand();\n\n\tlong searchVal;\n\ttime_t startTime, endTime;\n\tcout << \"Enter an integer value to find: \";\n\tcin >> searchVal;\n\tcout << \"Please wait...\\n\";\n\n\t// Test the Assembly language function.\n\ttime( &startTime );\n\tlong count = 0;\n\n\tfor( unsigned n = 0; n < LOOP_SIZE; n++)\n\t\t count = IndexOf( searchVal, array, ARRAY_SIZE );\n\n\tbool found = count != -1;\n\n\ttime( &endTime );\n\tcout << \"Elapsed ASM time: \" << long(endTime - startTime) \n\t\t  << \" seconds. Found = \" << boolstr[found] << endl;\n\n\treturn 0;\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\InlineTest",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\InlineTest\\inlineTest.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\InlineTest\\inlineTest.cpp",
        "snippet": "// test1.cpp - Test Inline Operators\n\n#pragma warning (disable:4101)\n// disable warning about unreferenced local variables\n\n#include <iostream>\n\nint main()\n{\n\tstd::cout << \"(this program generates no output)\\n\\n\";\n\nstruct Package {\n  long originZip;        // 4\n  long destinationZip;   // 4\n  float shippingPrice;   // 4\n};\n  \n   char myChar;\n   bool myBool;\n   short myShort;\n   int  myInt;\n   long myLong;\n   float myFloat;\n   double myDouble;\n   Package myPackage;\n\n   long double myLongDouble;\n   long myLongArray[10];\n\n__asm {\n   mov  eax,myPackage.destinationZip;\n\n   mov  eax,LENGTH myInt;         // 1\n   mov  eax,LENGTH myLongArray;   // 10\n\n   mov  eax,TYPE myChar;        // 1\n   mov  eax,TYPE myBool;        // 1\n   mov  eax,TYPE myShort;       // 2\n   mov  eax,TYPE myInt;         // 4\n   mov  eax,TYPE myLong;        // 4"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\MultiplicationTable",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\MultiplicationTable\\main.cpp",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\MultiplicationTable\\subr.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\MultiplicationTable\\main.cpp",
        "snippet": "// main.cpp\n\n// Demonstrates function calls between a C++ program\n// and an external assembly language module.\n// Last update: 6/24/2005\n\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nextern \"C\" {\n\t// external ASM procedures:\n\tvoid DisplayTable();\n\tvoid SetTextOutColor( unsigned color );\n\n\t// local C++ functions:\n\tint askForInteger();\n\tvoid showInt( int value, int width );\n}\n\n// program entry point\nint main()\n{\n\tSetTextOutColor( 0x1E );\t// yellow on blue\n\tDisplayTable();\t\t\t\t// call ASM procedure\n\treturn 0;\n}\n\n// Prompt the user for an integer. \n\nint askForInteger()\n{\n\tint n;\n\tcout << \"Enter an integer between 1 and 90,000: \";\n\tcin >> n;\n\treturn n;\n}\n\n// Display a signed integer with a specified width."
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\MultiplicationTable\\subr.asm",
        "snippet": "; Multiplication Table program       (subr.asm)\n\n; Calls external C++ functions.\n\nINCLUDE Irvine32.inc\n\naskForInteger PROTO C\nshowInt PROTO C, value:SDWORD, outWidth:DWORD\n\nOUT_WIDTH = 8\nENDING_POWER = 10\n\n.data\nintVal DWORD ?\n\n.code\n;---------------------------------------------\nSetTextOutColor PROC C, \n\tcolor:DWORD\n;\n; Sets the text colors and clears the console\n; window. Calls Irvine32 library functions.\n;---------------------------------------------\n\tmov\teax,color\n\tcall\tSetTextColor\n\tcall\tClrscr\n\tret\nSetTextOutColor ENDP\n\n;---------------------------------------------\nDisplayTable PROC C\n;\n; Inputs an integer n and displays a\n; multiplication table ranging from n * 2^1\n; to n * 2^10.\n;----------------------------------------------\n\tINVOKE askForInteger\t; call C++ function\n\tmov\tintVal,eax            \t; save the integer\n\tmov\tecx,ENDING_POWER       \t; loop counter"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example\\asmMain.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example\\asmMain_stub.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example\\main.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example\\asmMain.asm",
        "snippet": "TITLE Test Floating - point output       (asmMain.asm)\n\n; Test the printf and scanf functions from the C library.\n; Test the printSingle function in the C++ module.\n\nINCLUDE Irvine32.inc\n\n; printSingle is a function in the startup C++ program,\n; which will be called from this module.\n\nprintSingle PROTO C,\naSingle:REAL4,\n\tprecision : DWORD\n\n\tTAB = 9\n\n\t.code\nasmMain PROC C\t\t\t; Entry point for this module\n\n;---------- test the printf function --------------\n; Note: do not pass REAL4 variables to printf using INVOKE\n\n.data\nprompt BYTE \"Enter a float, followed by a double: \",0\nformatTwo BYTE \"%.2f\",TAB,\"%.3f\",0dh,0ah,0\nval1 REAL8 456.789\nval2 REAL8 864.231\n.code\nINVOKE printf, ADDR formatTwo, val1, val2\n\n;--------- test the scanf function -------------\n.data\nstrSingle BYTE \"%f\",0\nstrDouble BYTE \"%lf\",0\nfloat1 REAL4 1234.567\ndouble1 REAL8  1234567.890123\n.code\n\n; Input a float, then a double:\nINVOKE printf, ADDR prompt"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example\\asmMain_stub.asm",
        "snippet": "TITLE Stub program for asmMain     (asmMain_stub.asm)\n\n; Use this file as a starting point for creating a main\n; ASM module called by C++. Its use is explained in the book\n; in Section 12.3.4.1.\n\n.386\n.model flat,stdcall\n.stack 2000\n\n.code\nasmMain PROC C\n\n\tret\nasmMain ENDP\n\nEND"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example\\main.cpp",
        "snippet": "// main.cpp\n\n#include <stdio.h>\n\nextern \"C\" void asmMain( );\nextern \"C\" void printSingle( float d, int precision );\n\nvoid printSingle(float d, int precision)\n{\n\tprintf(\"%f\", d);\n}\n\n/*\nvoid printSingle( float d, int precision )\n{\n\tstrstream temp;\n\ttemp << \"%.\" << precision << \"f\" << '\\0';\n\tprintf(temp.str( ), d );\n}*/\n\n\nint main( )\n{\n\tprintf(\"Input an integer: \");\n\tint d;\n\tscanf(\"%d\", &d);\n\tprintf(\"Input a float, then a double: \");\n\tasmMain( );\n\treturn 0;\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example - C language",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example - C language\\asmMain.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example - C language\\asmMain_stub.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example - C language\\main.c"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example - C language\\asmMain.asm",
        "snippet": "TITLE Test Floating-point output       (asmMain.asm)\n\n; Test the printf and scanf functions from the C library.\n; Test the printSingle function in the C++ module.\n; Last update: 7/30/05\n\nINCLUDE Irvine32.inc\n\nprintSingle PROTO C,\n\taSingle:REAL4, \n\tprecision:DWORD\n\nprintf PROTO C,\n\tformat:PTR BYTE, args:VARARG\n\nTAB = 9\n\n.code\nasmMain PROC C\n\n;---------- test the printf function --------------\n; Do not pass REAL4 variables to printf using INVOKE!\n\n.data\nformatTwo BYTE \"%.2f\",TAB,\"%.3f\",0dh,0ah,0\nval1 REAL8 456.789\nval2 REAL8 864.231\n.code\nINVOKE printf, ADDR formatTwo, val1, val2\n\n;--------- test the scanf function -------------\n.data\nstrSingle BYTE \"%f\",0\nstrDouble BYTE \"%lf\",0\nfloat1 REAL4 1234.567\ndouble1 REAL8  1234567.890123\n.code\n\n; Input a float, then a double:\nINVOKE scanf, ADDR strSingle, ADDR float1"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example - C language\\asmMain_stub.asm",
        "snippet": "TITLE Stub program for asmMain     (asmMain_stub.asm)\n\n; Use this file as a starting point for creating a main\n; ASM module called by C++. Its use is explained in the book\n; in Section 12.3.4.1.\n\n.386\n.model flat,stdcall\n.stack 2000\n\n.code\nasmMain PROC C\n\n\tret\nasmMain ENDP\n\nEND"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Printf_Example - C language\\main.c",
        "snippet": "// main.c\n\n#include <stdio.h>\n\nextern void _asmMain( );\nextern void _printSingle( float d, int precision );\n\nint main( )\n{\n\tasmMain( );\n\treturn 0;\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Strings",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Strings\\strings.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Strings\\strings.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Strings\\strings.asm",
        "snippet": "TITLE\tstrings.cpp\n\t.386P\ninclude listing.inc\nif @Version gt 510\n.model FLAT\nelse\n_TEXT\tSEGMENT PARA USE32 PUBLIC 'CODE'\n_TEXT\tENDS\n_DATA\tSEGMENT DWORD USE32 PUBLIC 'DATA'\n_DATA\tENDS\nCONST\tSEGMENT DWORD USE32 PUBLIC 'CONST'\nCONST\tENDS\n_BSS\tSEGMENT DWORD USE32 PUBLIC 'BSS'\n_BSS\tENDS\n$$SYMBOLS\tSEGMENT BYTE USE32 'DEBSYM'\n$$SYMBOLS\tENDS\n$$TYPES\tSEGMENT BYTE USE32 'DEBTYP'\n$$TYPES\tENDS\n_TLS\tSEGMENT DWORD USE32 PUBLIC 'TLS'\n_TLS\tENDS\n;\tCOMDAT ??_C@_03NBBF@tim?$AA@\nCONST\tSEGMENT DWORD USE32 PUBLIC 'CONST'\nCONST\tENDS\n;\tCOMDAT _MakeString\n_TEXT\tSEGMENT PARA USE32 PUBLIC 'CODE'\n_TEXT\tENDS\n;\tCOMDAT _main\n_TEXT\tSEGMENT PARA USE32 PUBLIC 'CODE'\n_TEXT\tENDS\nFLAT\tGROUP _DATA, CONST, _BSS\n\tASSUME\tCS: FLAT, DS: FLAT, SS: FLAT\nendif\nPUBLIC\t_MakeString\nPUBLIC\t??_C@_03NBBF@tim?$AA@\t\t\t\t; `string'\nEXTRN\t_strcpy:NEAR\nEXTRN\t__chkesp:NEAR\n;\tCOMDAT ??_C@_03NBBF@tim?$AA@\n; File - strings.cpp\nCONST\tSEGMENT\n??_C@_03NBBF@tim?$AA@ DB 'tim', 00H\t\t\t; `string'"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch13\\Strings\\strings.cpp",
        "snippet": "// strings.cpp\n\n// The strings example was designed to show how C++ creates\n// stack space for a local variable (a string).\n\n#include <string.h>\n\nextern \"C\" void MakeString()\n{\n\tchar firstName[20];\n\tstrcpy(firstName,\"tim\");\n}\n\nvoid main()\n{\n\tMakeString();\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Binfile.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\DateTime.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Encrypt.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Fileio.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Hello.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Hello2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Keybd.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Readfile.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Test16.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Binfile.asm",
        "snippet": "; Binary File Program         (Binfile.asm)\n\n; This program creates a binary file containing \n; an array of doublewords.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\n.data\nmyArray DWORD 50 DUP(?)\n\nfileName   BYTE \"binary array file.bin\",0\nfileHandle WORD ?\ncommaStr   BYTE \", \",0\n\n; Set CreateFile to zero if you just want to\n; read and display the existing binary file.\nCreateFile = 1\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n                                                             \n.IF CreateFile EQ 1\n\tcall\tFillTheArray\n\tcall\tDisplayTheArray\n\tcall\tCreateTheFile\n\tcall\tWaitMsg\n\tcall\tCrlf\n.ENDIF\n\tcall\tReadTheFile\n\tcall\tDisplayTheArray\n\nquit:\n\tcall\tCrlf\n    exit\nmain ENDP\n\n;------------------------------------------------------"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\DateTime.asm",
        "snippet": "; Display the Date and Time     (DateTime.asm)\n\n; This Real-mode program displays the date and time.\n; Last update: 06/01/2006\n\nInclude Irvine16.inc\n\nWrite PROTO char:BYTE\n.data\nstr1 BYTE \"Date: \",0\nstr2 BYTE \",  Time: \",0\n\n.code\nmain PROC\n\tmov  ax,@data\n\tmov  ds,ax\n\n; Display the date:\n\tmov   dx,OFFSET str1\n\tcall  WriteString\n\tmov   ah,2Ah\t\t; get system date\n\tint   21h\n\tmovzx eax,dh\t\t; month\n\tcall  WriteDec\n\tINVOKE Write,'-'\n\tmovzx eax,dl\t\t; day\n\tcall  WriteDec\n\tINVOKE Write,'-'\n\tmovzx eax,cx\t\t; year\n\tcall  WriteDec\n\n; Display the time:\n\tmov   dx,OFFSET str2\n\tcall  WriteString\n\tmov   ah,2Ch\t\t; get system time\n\tint   21h\n\tmovzx eax,ch\t\t; hours\n\tcall  WritePaddedDec\n\tINVOKE Write,':'\n\tmovzx eax,cl\t\t; minutes"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Encrypt.asm",
        "snippet": "; Encryption Program               (Encrypt.asm)\n\n; This program uses MS-DOS function calls to\n; read and encrypt a file. Run it from the\n; command prompt, using redirection:\n\n;    Encrypt < infile.txt > outfile.txt\n\n; Function 6 is also used for output, to avoid\n; filtering ASCII control characters.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\nXORVAL = 239\t\t\t; any value between 0-255\n.code\nmain PROC\n\tmov   ax,@data\n\tmov   ds,ax\n\nL1:\n\tmov\tah,6\t\t\t; direct console input\n\tmov\tdl,0FFh\t\t; don't wait for character\n\tint\t21h\t\t\t; AL = character\n\tjz\tL2\t\t\t; quit if ZF = 1 (EOF)\n\txor\tal,XORVAL\n\tmov\tah,6\t\t\t; write to output\n\tmov\tdl,al\n\tint\t21h\n\tjmp\tL1\t\t\t; repeat the loop\n\nL2:\texit\nmain ENDP\nEND  main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Fileio.asm",
        "snippet": "; Extended Open/Create            (Fileio.asm)\n\n; Demonstration of 16-bit File I/O.\n; The complete program does not appear in the text, but\n; excerpts appear.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\n.data\nDate WORD ?\nhandle WORD ?\nactionTaken WORD ?\nFileName BYTE \"long_filename.txt\",0\nNewFile  BYTE \"newfile.txt\",0\ncannotCreate BYTE \"Cannot create newfile.txt\",0dh,0ah,0\ncannotOpen   BYTE \"Cannot open long_filename.txt\",0dh,0ah,0\nfailedMsg    BYTE \"Cannot create or open newfile.txt\",0dh,0ah,0\n\n.code\nmain PROC\n\tmov  ax,@data\n\tmov  ds,ax\n\n;Create new file, fail if it already exists:\n\tmov  ax,716Ch             \t; Extended Open/Create\n\tmov  bx,2\t\t\t\t\t\t; read-write\n\tmov  cx,0      \t\t\t\t; normal attribute\n\tmov  dx,10h\t\t\t\t\t\t; action: create\n\tmov  si,OFFSET NewFile\n\tint  21h\n\tjc   failed_create\n\tmov  handle,ax        \t\t; file handle\n\tmov  actionTaken,cx   \t\t; action taken to open file\n\tjmp  open_existing\n\nfailed_create:\n\tmov  dx,OFFSET cannotCreate\n\tcall WriteString"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Hello.asm",
        "snippet": "; Hello World Program         (Hello.asm)\n\n.MODEL small\n.STACK 100h\n.386\n\n.data\nmessage BYTE \"Hello, world!\",0dh,0ah\n\n.code\nmain PROC\n\tmov\tax,@data\t\t\t\t; initialize DS\n\tmov\tds,ax\n\n\tmov\tah,40h\t\t\t\t; write to file/device\n\tmov\tbx,1\t\t\t\t\t; output handle\n\tmov\tcx,SIZEOF message\t\t; number of bytes\n\tmov\tdx,OFFSET message\t\t; addr of buffer\n\tint\t21h\n\n\t.EXIT\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Hello2.asm",
        "snippet": "; Hello World Program         (Hello2.asm)\n\n.MODEL small\n.STACK 100h\n.386\n\n.data\nmessage BYTE \"Hello, world!\",0dh,0ah\n\n.code\nmain PROC\n\t.STARTUP\n\n\tmov\tah,40h\t\t\t; write to file/device\n\tmov\tbx,1\t\t\t\t; output handle\n\tmov\tcx,SIZEOF message\t; number of bytes\n\tmov\tdx,OFFSET message\t; addr of buffer\n\tint\t21h\n\n    .EXIT\nmain ENDP\nEND"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Keybd.asm",
        "snippet": "; Buffered Keyboard Input         (Keybd.asm)\n\n; Test function 3Fh, read from file or device\n; with the keyboard. Flush the buffer.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\n.data\nfirstName BYTE 15 DUP(?),0\nlastName  BYTE 30 DUP(?),0\n\n.code\nmain PROC\n   mov  ax,@data\n   mov  ds,ax\n\n; Input the first name:\n\tmov  ah,3Fh\n\tmov  bx,0\t\t\t\t\t; keyboard handle\n\tmov  cx,LENGTHOF firstName\n\tmov  dx,OFFSET firstName\n\tint  21h\n\n; Disable the following line to see what happens\n; when the buffer is not flushed:\n\t;call FlushBuffer\n\n; Input the last name:\n\tmov  ah,3Fh\n\tmov  bx,0\t\t\t\t\t; keyboard handle\n\tmov  cx,LENGTHOF lastName\n\tmov  dx,OFFSET lastName\n\tint  21h\n\n; Display both names:\n\tmov  dx,OFFSET firstName\n\tcall WriteString\n\tmov  dx,OFFSET lastName\n\tcall WriteString"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Readfile.asm",
        "snippet": "; Read a text file         (Readfile.asm)\n\n; Read, display, and copy a text file.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\n.data\nBufSize = 5000\ninfile    BYTE \"my_text_file.txt\",0\noutfile   BYTE \"my_output_file.txt\",0\ninHandle  WORD ?\noutHandle WORD ?\nbuffer    BYTE BufSize DUP(?)\nbytesRead WORD ?\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\n; Open the input file\n\tmov\tax,716Ch   \t\t; extended create or open\n\tmov\tbx,0      \t\t; mode = read-only\n\tmov\tcx,0\t\t\t\t; normal attribute\n\tmov\tdx,1\t\t\t\t; action: open\n\tmov\tsi,OFFSET infile\n\tint\t21h       \t\t; call MS-DOS\n\tjc\tquit\t\t\t\t; quit if error\n\tmov\tinHandle,ax\n\n; Read the input file\n\tmov\tah,3Fh\t\t\t; read file or device\n\tmov\tbx,inHandle\t\t; file handle\n\tmov\tcx,BufSize\t\t; max bytes to read\n\tmov\tdx,OFFSET buffer\t; buffer pointer\n\tint\t21h\n\tjc\tquit\t\t\t\t; quit if error\n\tmov\tbytesRead,ax"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Test16.asm",
        "snippet": "; Testing the Link Library \t        (Test16.asm)\n\n; Use this program to test individual Irvine16\n; library procedures.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\n.code\nmain PROC\n\tmov ax,@data\n\tmov ds,ax\n\n\tcall ReadHex\n\tcall DumpRegs\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Project\\main.asm",
        "snippet": "; MASM Template\t\t\t\t\t\t(main.asm)\n\n; Description:\n; \n; Revision date:\n\nINCLUDE Irvine32.inc\n.data\nmyMessage BYTE \"MASM program example\",0dh,0ah,0\n\n\n.code\nmain PROC\n\tcall Clrscr  \n\n\n\tmov\t edx,offset myMessage\n\tcall WriteString\n\n\texit\nmain ENDP\n\nEND main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Project",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Project\\main.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch14\\Project\\main.asm",
        "snippet": "; MASM Template\t\t\t\t\t\t(main.asm)\n\n; Description:\n; \n; Revision date:\n\nINCLUDE Irvine32.inc\n.data\nmyMessage BYTE \"MASM program example\",0dh,0ah,0\n\n\n.code\nmain PROC\n\tcall Clrscr  \n\n\n\tmov\t edx,offset myMessage\n\tcall WriteString\n\n\texit\nmain ENDP\n\nEND main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch15",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch15\\Cluster.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch15\\DiskSpc.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch15\\Sector.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch15\\Sector32.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch15\\Cluster.asm",
        "snippet": "TITLE  Cluster Display Program           (Cluster.asm)\n\n; This program reads the directory of drive A, decodes\n; the file allocation table, and displays the list of\n; clusters allocated to each file.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\n; Attributes specific to 1.44MB diskettes:\nFATSectors = 9\t\t; num sectors, first copy of FAT\nDIRSectors = 14\t; num sectors, root directory\nDIR_START = 19\t\t; starting directory sector num\n\nSECTOR_SIZE = 512\nDRIVE_A = 0\nFAT_START = 1\t\t; starting sector of FAT\nEOLN equ <0dh,0ah>\n\nDirectory STRUCT\n\tfileName   BYTE 8 dup(?)\n\textension  BYTE 3 dup(?)\n\tattribute  BYTE ?\n\treserved   BYTE 10 dup(?)\n\ttime       WORD ?\n\tdate       WORD ?\n\tstartingCluster WORD ?\n\tfileSize   DWORD ?\nDirectory ENDS\nENTRIES_PER_SECTOR = SECTOR_SIZE / (size Directory)\n\n.data\nheading LABEL byte\n\tBYTE  'Cluster Display Program           (CLUSTER.EXE)'\n\tBYTE   EOLN,EOLN,'The following clusters are allocated '\n\tBYTE  'to each file:',EOLN,EOLN,0\n\nfattable WORD ((FATSectors * SECTOR_SIZE) / 2) DUP(?)\ndirbuf Directory (DIRSectors * ENTRIES_PER_SECTOR) DUP(<>)\ndriveNumber BYTE ?"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch15\\DiskSpc.asm",
        "snippet": "TITLE Disk Free Space                  (DiskSpc.asm)\n\n; This program calls INT 21h Function 7303h, to get free \n; space information on a FAT-type drive volume. It \n; displays both the volume size and free space. Works \n; under Windows 95/98/Me, but not under Windows NT/2000/XP.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\n.data\nbuffer ExtGetDskFreSpcStruc <>\ndriveName BYTE \"C:\\\",0\nstr1 BYTE \"Volume size (KB): \",0\nstr2 BYTE \"Free space (KB):  \",0\nstr3 BYTE \"Function call failed.\",0dh,0ah,0\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\tmov\tes,ax\n\n\tmov\tbuffer.Level,0\t\t\t; must be zero\n\tmov\tdi,OFFSET buffer\t\t; ES:DI points to buffer\n\tmov\tcx,SIZEOF buffer\t\t; buffer size\n\tmov\tdx,OFFSET DriveName\t\t; ptr to drive name\n\tmov\tax,7303h\t\t\t\t; get disk free space\n\tint\t21h\n\tjc\terror\t\t\t\t; failed if CF = 1\n\n\tmov\tdx,OFFSET str1\t\t\t; volume size\n\tcall\tWriteString\n\tcall\tCalcVolumeSize\n\tcall\tWriteDec\n\tcall\tCrlf\n\n\tmov\tdx,OFFSET str2\t\t\t; free space\n\tcall\tWriteString\n\tcall\tCalcVolumeFree"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch15\\Sector.asm",
        "snippet": "TITLE Sector Display Program              (Sector.asm)\n\n; Demonstrates INT 21h function 7305h (ABSDiskReadWrite)\n; This Real-mode program reads and displays disk sectors.\n; Works on FAT16 & FAT32 file systems running under Windows\n; 95, 98, and Millenium.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\nSetcursor PROTO, row:BYTE, col:BYTE\nEOLN EQU <0dh,0ah>\nESC_KEY = 1Bh\nDATA_ROW = 5\nDATA_COL = 0\nSECTOR_SIZE = 512\nREAD_MODE = 0\t\t; for Function 7505h\n\nDiskIO STRUCT\n\tstartSector DWORD ?\t\t; starting sector number\n\tnumSectors  WORD 1\t\t; number of sectors\n\tbufferOfs   WORD OFFSET buffer\t; buffer offset\n\tbufferSeg   WORD SEG buffer\t\t; buffer segment\nDiskIO ENDS\n\n.data\ndriveNumber BYTE ?\ndiskStruct DiskIO <>\nbuffer BYTE SECTOR_SIZE DUP(0),0\t\t    ; one sector\n\ncurr_row   BYTE  ?\ncurr_col   BYTE  ?\n\n; String resources\nstrLine       BYTE  EOLN,79 DUP(0C4h),EOLN,0\nstrHeading    BYTE \"Sector Display Program (Sector.exe)\"\n              BYTE EOLN,EOLN,0\nstrAskSector  BYTE \"Enter starting sector number: \",0\nstrAskDrive   BYTE \"Enter drive number (1=A, 2=B, \"\n\t          BYTE \"3=C, 4=D, 5=E, 6=F): \",0"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch15\\Sector32.asm",
        "snippet": "TITLE Sector Display Program              (Sector32.asm)\n\n; Demonstrates INT 21h function 7305h (ABSDiskReadWrite)\n; This Real-mode program reads and displays disk sectors.\n; Works on FAT16 & FAT32 file systems running under Windows\n; 95, 98, and Millenium.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\nSetcursor PROTO, row:BYTE, col:BYTE\nEOLN EQU <0dh,0ah>\nESC_KEY = 1Bh\nDATA_ROW = 5\nDATA_COL = 0\nSECTOR_SIZE = 512\nREAD_MODE = 0\t\t\t\t\t; for Function 7505h\n\nDiskIO STRUCT\n\tstartSector DWORD ?\t\t\t; starting sector number\n\tnumSectors  WORD 1\t\t\t; number of sectors\n\tbufferOfs   WORD buffer\t\t; buffer offset\n\tbufferSeg   WORD @DATA\t\t; buffer segment\nDiskIO ENDS\n\n.data\ndriveNumber BYTE ?\ndiskStruct DiskIO <>\nbuffer BYTE SECTOR_SIZE DUP(0),0\t; one sector\n\ncurr_row   BYTE  ?\ncurr_col   BYTE  ?\n\n; String resources\nstrLine       BYTE  EOLN,79 DUP(0C4h),EOLN,0\nstrHeading    BYTE \"Sector Display Program (Sector32.exe)\"\n              BYTE EOLN,EOLN,0\nstrAskSector  BYTE \"Enter starting sector number: \",0\nstrAskDrive   BYTE \"Enter drive number (1=A, 2=B, \"\n\t          BYTE \"3=C, 4=D, 5=E, 6=F): \",0\nstrCannotRead BYTE EOLN,\"*** Cannot read the sector. \""
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\ClearKbd.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\ColorSt2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Colorstr.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Delay.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\DrawLine.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\getVideo.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Keybd.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Mode13.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Mouse.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Pixel2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\TextWin.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\WriteColors.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\ClearKbd.asm",
        "snippet": "TITLE Testing ClearKeyboard       (ClearKbd.asm)\n\n; This program shows how to clear the keyboard\n; buffer, while waiting for a particular key.\n; To test it, rapidly press random keys to fill\n; up the buffer. When you press Esc, the program \n; ends immediately.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\nClearKeyboard PROTO, scanCode:BYTE\nESC_key = 1\t\t\t; scan code\n\n.code\nmain PROC\nL1:\t;------------------------- LOOP BODY\n\t; Display a dot, to show program's progress\n\tmov\tah,2\n\tmov\tdl,'.'\n\tint\t21h\n\tmov\teax,300\t\t; delay for 300 ms\n\tcall\tDelay\n\t;-------------------------\n\tINVOKE ClearKeyboard,ESC_key\t; check for Esc key\n\tjnz\tL1\t\t\t\t\t; continue loop if ZF=0\n\nquit:\n\tcall Clrscr\n\texit\nmain ENDP\n\n;---------------------------------------------------\nClearKeyboard PROC,\n\tscanCode:BYTE\n;\n; Clears the keyboard, while checking for a\n; particular scan code.\n; Receives: keyboard scan code\n; Returns: Zero flag set if the ASCII code is\n; found; otherwise, Zero flag is clear."
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\ColorSt2.asm",
        "snippet": "TITLE Color String Example              (ColorSt2.asm)\n\nComment !\nDemonstrates INT 10h function 13h, which writes\na string containing embedded attribute bytes to the\nvideo display. The write mode values in AL are:\n0 = string contains only character codes; cursor not\n    updated after write, and attribute is in BL.\n1 = string contains only character codes; cursor is\n    updated after write, and attribute is in BL.\n2 = string contains alternating character codes and\n    attribute bytes; cursor position not updated\n    after write.\n3 = string contains alternating character codes and\n    attribute bytes; cursor position is updated\n    after write.\n\n; Last update: 06/01/2006\n!\n\nINCLUDE Irvine16.inc\n\n.data\ncolorString BYTE 'A',1Fh,'B',1Ch,'C',1Bh,'D',1Ch\nrow    BYTE  10\ncolumn BYTE  20\n\n.code\nmain PROC\n\tmov  ax,@data\n\tmov  ds,ax\n\n\tcall ClrScr\n\tmov  ax,SEG colorString\n\tmov  es,ax\n\tmov  ah,13h\t\t\t\t\t; write string\n\tmov  al,2\t\t\t\t\t\t; write mode\n\tmov  bh,0\t\t\t\t\t\t; video page\n\tmov  cx,(SIZEOF colorString) / 2\t; string length\n\tmov  dh,row\t\t\t\t\t; start row"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Colorstr.asm",
        "snippet": "TITLE Color String Example              (ColorStr.asm)\n\n; This program writes a multicolor string on the display.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\n.data\nATTRIB_HI = 10000000b\nstring BYTE \"ABCDEFGHIJKLMOP\"\ncolor  BYTE 1\n\n.code\nmain PROC\n\tmov  ax,@data\n\tmov  ds,ax\n\n\tcall ClrScr\n\tcall EnableBlinking\n\tmov  cx,SIZEOF string\n\tmov  si,OFFSET string\n\nL1:\tpush cx\t\t\t; save loop counter\n\tmov  ah,9      \t; write character/attribute\n\tmov  al,[si]   \t; character to display\n\tmov  bh,0      \t; video page 0\n\tmov  bl,color\t\t; attribute\n\tor   bl,ATTRIB_HI\t; set blink/intensity bit\n\tmov  cx,1     \t\t; display it one time\n\tint  10h\n\tmov  cx,1\t\t\t; advance cursor to\n\tcall AdvanceCursor\t; next screen column\n\tinc  color\t\t; next color\n\tinc  si\t\t\t; next character\n\tpop  cx\t\t\t; restore loop counter\n\tLoop L1\n\n\tcall Crlf\n\texit\nmain ENDP"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Delay.asm",
        "snippet": "TITLE                               (delay.asm)\n\n; Bit 4 of port 61h toggles every 15.085 microseconds\n; Must be tested under MS-DOS, Windows 95, or Windows 98.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\n.data\nmilliseconds DWORD 5000\n\n.code\nmain PROC\n\tmov  ax,@data\n\tmov  ds,ax\n\n\tmov  eax,0\n\tmov  cx,5\nL1:\n\tpush eax\n\tmov  eax,milliseconds\n\tcall DelayTest\n\tpop  eax\n\tinc  eax\n\tcall WriteDec\n\tcall Crlf\n\tLoop L1\n\nquit:\n\texit\nmain ENDP\n\n;-----------------------------------------------------------\nDelayTest PROC\n;\n; Create an n-millisecond delay. It has been measured to\n; be accurate over a 1-minute time period but it is probably\n; not accurate for short durations.\n; Receives: EAX = milliseconds\n; Returns: nothing"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\DrawLine.asm",
        "snippet": "TITLE DrawLine Program              (DrawLine.asm)\n\n; This program draws text and a straight line in graphics mode.\n; Last update: 4/3/2007\n; Windows XP users: To run this program, open a command prompt using the \n; command_prompt shortcut provided in this folder. Then switch to full-screen \n; mode by pressing Alt-Enter, type Drawline and press Enter.\n\nINCLUDE Irvine16.inc\n\n;------------ Video Mode Constants -------------------\nMode_06 = 6\t\t; 640 X 200,  2 colors\nMode_0D = 0Dh\t\t; 320 X 200, 16 colors\nMode_0E = 0Eh\t\t; 640 X 200, 16 colors\nMode_0F = 0Fh\t\t; 640 X 350,  2 colors\nMode_10 = 10h\t\t; 640 X 350, 16 colors\nMode_11 = 11h\t\t; 640 X 480,  2 colors\nMode_12 = 12h\t\t; 640 X 480, 16 colors\nMode_13 = 13h\t\t; 320 X 200, 256 colors\nMode_6A = 6Ah\t\t; 800 X 600, 16 colors\n\n.data\nsaveMode  BYTE  ?\t\t; save the current video mode\ncurrentX  WORD 100\t\t; column number (X-coordinate)\ncurrentY  WORD 100\t\t; row number (Y-coordinate)\nCOLOR = 1001b\t\t\t; line color (cyan)\n\nprogTitle BYTE \"DrawLine.asm\"\nTITLE_ROW = 5\nTITLE_COLUMN = 14\n\n; When using a 2-color mode, set COLOR to 1 (white)\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\n; Save the current video mode.\n\tmov\tah,0Fh"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\getVideo.asm",
        "snippet": "TITLE Get Video Information               (getVideo.asm)\n\n; This program retrieves information about the current video\n; display mode as well as a pointer to a table describing the\n; characteristics and capabilities of the video display adapter\n; and monitor. Information about INT 10h function 1Bh may be found\n; in \"Advanced MS-DOS, 2nd Edition\", by Ray Duncan, pages 531-532.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\nINCLUDE Macros.inc\n\nCOMMENT !    ; (CursorPosStruc and VideoInfoStruc are defined in Irvine16.inc)\nCursorPosStruc STRUCT\n\tYcoord BYTE ?\n\tXcoord BYTE ?\nCursorPosStruc ENDS\n\nVideoInfoStruc STRUC\n\tsupportedInfoPtr     DWORD ?\n\tvideoMode            BYTE ?\n\tnumCharColumns       WORD ?\n\tvideoBufferLen       WORD ?\n\tvideoBufferStartPtr  WORD ?\n\tcursors CursorPosStruc 8 DUP(<>)\t; video pages 0-7\n\tcursorStartLine      BYTE ?\n\tcursorEndLine        BYTE ?\n\tactiveDisplayPage    BYTE ?\n\tadapterBasePortAddr  WORD ?\n\tcurrentRegister3B8or3D8 BYTE ?\n\tcurrentRegister3B9or3D9 BYTE ?\n\tnumCharRows          BYTE ?\n\tcharacterScanHeight  WORD ?\n\tactiveDisplayCode    BYTE ?\n\tinactiveDisplayCode  BYTE ?\n\tnumberOfColors       WORD ?\n\tnumberOfVideoPages   BYTE ?\n\tnumberOfScanLines    WORD ?\n\tprimaryCharBlock     BYTE ?\n\tsecondaryCharBlock   BYTE ?"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Keybd.asm",
        "snippet": "TITLE Keyboard Display           (keybd.asm)\n\n; This program displays keyboard scan codes\n; and ASCII codes, using INT 16h.\n; Last update: 06/01/2006\n\nInclude Irvine16.inc\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\tcall\tClrScr\t; clear screen\n\nL1:\tmov\tah,10h\t; keyboard input\n\tint\t16h\t\t; using BIOS\n\tcall\tDumpRegs\t; look at AH, AL\n\tcmp\tal,1Bh\t; ESC key pressed?\n\tjne\tL1\t\t; no: repeat the loop\n\n\tcall\tClrScr\t; clear screen\n\t\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Mode13.asm",
        "snippet": "; Memory Mapped Graphics, Mode 13        \t(Mode13.asm)\n\nComment !\n\nThis program demonstrates direct memory mapping in video\ngraphics Mode 13 (320 x 200, 256 colors). The video memory\nis a two-dimensional array of memory bytes which can be addressed\nand modified individually. Each byte represents a pixel on\nthe screen, and each byte contains an index into the color\npalette.\nLast update: 06/01/2006\n!\n\nINCLUDE Irvine16.inc\n\nVIDEO_PALLETE_PORT = 3C8h\nCOLOR_SELECTION_PORT = 3C9h\nCOLOR_INDEX = 1\nPALLETE_INDEX_BACKGROUND = 0\nSET_VIDEO_MODE = 0\nGET_VIDEO_MODE = 0Fh\nVIDE0_SEGMENT = 0A000h\nWAIT_FOR_KEYSTROKE = 10h\nMODE_13 = 13h\n\n.data\nsaveMode BYTE ?\t; saved video mode\nxVal WORD ?\t\t; x-coordinate\nyVal WORD ?\t\t; y-coordinate\nmsg BYTE \"Welcome to Mode 13!\",0\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\n\tcall\tSetVideoMode\n\tcall\tSetScreenBackground\n\t\n; Display a greeting message."
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Mouse.asm",
        "snippet": "TITLE Tracking the Mouse                      (mouse.asm)\n\n; Demonstrates basic mouse functions available via INT 33h.\n; In Standard DOS mode, each character position in the DOS\n; window equals 8 mouse units.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\nGET_MOUSE_STATUS = 0\nSHOW_MOUSE_POINTER = 1\nHIDE_MOUSE_POINTER = 2\nGET_CURSOR_SIZE = 3\nGET_BUTTON_PRESS_INFO = 5\nGET_MOUSE_POSITION_AND_STATUS = 3\nESCkey = 1Bh\n\n.data\ngreeting    BYTE \"[Mouse.exe] Press Esc to quit\",0\nstatusLine  BYTE \"Left button:                              \"\n\t       BYTE \"Mouse position: \",0\nblanks      BYTE \"                \",0\nxCoord WORD 0\t\t; current X-position\nyCoord WORD 0\t\t; current Y-position\nxPress      WORD 0\t; X-pos of last button press\nyPress      WORD 0\t; Y-pos of last button press\n\n; Display coordinates.\nstatusRow\t     BYTE ?\nstatusCol      BYTE 15\nbuttonPressCol BYTE 20\nstatusCol2     BYTE 60\ncoordCol       BYTE 65\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\tcall\tClrscr"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch16\\Pixel2.asm",
        "snippet": "TITLE Cartesian Coordinates                 (Pixel2.asm)\n\n; This program switches into 800 X 600 graphics mode and\n; draws the X and Y axes of a Cartesian coordinate system.\n; Switch to full-screen mode before running this program.\n; Color constants are defined in Irvine16.inc.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\nMode_6A = 6Ah\t\t; 800 X 600, 16 colors\nX_axisY = 300\nX_axisX = 50\nX_axisLen = 700\n\nY_axisX = 400\nY_axisY = 30\nY_axisLen = 540\n\n.data\nsaveMode BYTE ?\n\n.code\nmain PROC\n\tmov ax,@data\n\tmov ds,ax\n\n; Save the current video mode\n\tmov  ah,0Fh\t\t; get video mode\n\tint  10h\n\tmov  saveMode,al\n\n; Switch to a graphics mode\n\tmov  ah,0   \t\t; set video mode\n\tmov  al,Mode_6A\t; 800 X 600, 16 colors\n\tint  10h\n\n; Draw the X-axis\n\tmov  cx,X_axisX\t; X-coord of start of line\n\tmov  dx,X_axisY\t; Y-coord of start of line"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\CtrlBrk.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\HelloCom.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\MultCode.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\MultData.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\MultiSeg.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\No_Reset.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\Speaker.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\CtrlBrk.asm",
        "snippet": "TITLE Control-Break Handler             (Ctrlbrk.asm)\n\n; This program installs its own Ctrl-Break handler and\n; prevents the user from using Ctrl-Break (or Ctrl-C)\n; to halt the program. The program inputs and echoes\n; keystrokes until the Esc key is pressed.\n; Last update: 06/01/2006\n\nINCLUDE Irvine16.inc\n\n.data\nbreakMsg BYTE \"BREAK\",0\nmsg\tBYTE \"Ctrl-Break demonstration.\"\n\tBYTE  0dh,0ah\n\tBYTE \"This program disables Ctrl-Break (Ctrl-C). Press any\"\n\tBYTE  0dh,0ah\n\tBYTE \"keys to continue, or press ESC to end the program.\"\n\tBYTE  0dh,0ah,0\n\n.code\nmain PROC\n\tmov   ax,@data\n\tmov   ds,ax\n\n\tmov   dx,OFFSET msg\t; display greeting message\n\tcall  Writestring\n\ninstall_handler:\n\tpush  ds          \t; save DS\n\tmov   ax,@code    \t; initialize DS\n\tmov   ds,ax\n\tmov   ah,25h      \t; set interrupt vector\n\tmov   al,23h      \t; for interrupt 23h\n\tmov   dx,OFFSET break_handler\n\tint   21h\n\tpop   ds          \t; restore DS\n\nL1:\tmov   ah,1        \t; wait for a key, echo it\n\tint   21h\n\tcmp   al,1Bh      \t; ESC pressed?"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\HelloCom.asm",
        "snippet": "TITLE Hello Program in COM format   (HelloCom.asm)\n\n.model tiny\n.code\norg 100h       \t; must be before main\nmain PROC\n\tmov  ah,9\n\tmov  dx,OFFSET hello_message\n\tint  21h\n\tmov  ax,4C00h\n\tint  21h\nmain ENDP\n\nhello_message BYTE 'Hello, world!',0dh,0ah,'$'\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\MultCode.asm",
        "snippet": "TITLE Multiple Code Segments      (MultCode.asm)\n\n; This small model program contains multiple\n; code segments.\n; Last update: 06/01/2006\n\n.model small,stdcall\n.stack 100h\nWriteString PROTO\n\n.data\nmsg1 db \"First Message\",0dh,0ah,0\nmsg2 db \"Second Message\",0dh,0ah,\"$\"\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\t\n\tmov\tdx,OFFSET msg1\n\tcall\tWriteString\t; NEAR call\n\tcall\tDisplay\t\t; FAR call\n\t.exit\nmain ENDP\n\n.code OtherCode\nDisplay PROC FAR\n\tmov\tah,9\n\tmov\tdx,offset msg2\n\tint\t21h\n    ret\nDisplay ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\MultData.asm",
        "snippet": "TITLE Multiple Data Segments            (MultData.asm)\n\n; This program shows how to explicitly declare\n; multiple data segments.\n; Last update: 06/01/2006\n\ncseg  SEGMENT 'CODE'\n      ASSUME cs:cseg, ds:data1, ss:mystack\n\nmain PROC\n\tmov  ax,data1           \t; point DS to data1 segment\n\tmov  ds,ax\n\tmov  ax,seg val2        \t; point ES to data2 segment\n\tmov  es,ax\n\n\tmov  ax,val1            \t; requires ASSUME for DS\n\tmov  bx,es:val2         \t; ASSUME not required\n\tcmp  ax,bx\n\tjb   L1                 \t; requires ASSUME for CS\n\tmov  ax,0\n\nL1:\n\tmov  ax,4C00h           \t; return to MS-DOS\n\tint  21h\nmain ENDP\ncseg  ENDS\n\ndata1 SEGMENT 'DATA'        \t; specify class type\n\tval1  dw  1001h\ndata1 ENDS\n\ndata2 SEGMENT 'DATA'\n\tval2  dw  1002h\ndata2 ENDS\n\nmystack SEGMENT para STACK 'STACK'\n\tBYTE 100h dup('S')\nmystack ENDS\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\MultiSeg.asm",
        "snippet": "TITLE Multiple Segment Example                 (MultiSeg.asm)\n\n; This program shows how to explicityly declare\n; multiple data segments.\n; Last update: 06/01/2006\n\ncseg  SEGMENT 'CODE'\n      ASSUME cs:cseg, ds:data1, ss:mystack\n\nmain PROC\n\tmov  ax,data1           \t; point DS to data1 segment\n\tmov  ds,ax\n\tmov  ax,seg val2        \t; point ES to data2 segment\n\tmov  es,ax\n\n\tmov  ax,val1            \t; requires ASSUME for DS\n\tmov  bx,es:val2         \t; ASSUME not required\n\tcmp  ax,bx\n\tjb   L1                 \t; requires ASSUME for CS\n\tmov  ax,0\n\nL1:\n\tmov  ax,4C00h           \t; return to MS-DOS\n\tint  21h\nmain ENDP\ncseg  ENDS\n\ndata1 SEGMENT 'DATA'        \t; specify class type\n\tval1  dw  1001h\ndata1 ENDS\n\ndata2 SEGMENT 'DATA'\n\tval2  dw  1002h\ndata2 ENDS\n\nmystack SEGMENT para STACK 'STACK'\n\tBYTE 100h dup('S')\nmystack ENDS\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\No_Reset.asm",
        "snippet": "TITLE Reset-Disabling program                  (No_Reset.asm)\n\n; This program disables the usual DOS reset command\n; (Ctrl-Alt-Del), by intercepting the INT 9 keyboard\n; hardware interrupt.  It checks the shift status bits\n; in the MS-DOS keyboard flag and changes any Ctrl-Alt-Del\n; to Alt-Del.  The computer can only be rebooted by\n; typing Ctrl+Alt+Right shift+Del.  Assemble, link,\n; and convert to a COM program by including the /T\n; command on the Microsoft LINK command line.\n; Last update: 12/12/2004\n\n.model tiny\n.386\n.code\n\trt_shift   EQU 01h\t\t; Right shift key: bit 0\n\tctrl_key   EQU 04h\t\t; CTRL key: bit 2\n\talt_key    EQU 08h\t\t; ALT key: bit 3\n\tdel_key    EQU 53h\t\t; scan code for DEL key\n\tkybd_port  EQU 60h\t\t; keyboard input port\n\n\tORG   100h       \t\t; this is a COM program\nstart:\n\tjmp   setup      \t\t; jump to TSR installation\n\n;   Memory-resident code begins here\nint9_handler PROC FAR\n\tsti               \t\t; enable hardware interrupts\n\tpushf\t\t; save regs & flags\n\tpush  es\n\tpush  ax\n\tpush  di\n\n;   Point ES:DI to the DOS keyboard flag byte:\nL1:\tmov   ax,40h             \t\t; DOS data segment is at 40h\n\tmov   es,ax\n\tmov   di,17h             \t\t; location of keyboard flag\n\tmov   ah,es:[di]         \t\t; copy keyboard flag into AH\n\n;   Test for the CTRL and ALT keys:"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\Speaker.asm",
        "snippet": "TITLE Speaker Demo Program               (Speaker.asm)\n\n; This program plays a series of ascending notes on\n; the PC speaker.\n; Last update: 10/8/01\n\nINCLUDE Irvine16.inc\t; 16-bit Real mode program\nspeaker  =  61h\t; address of speaker port\ntimer    =  42h\t; address of timer port\ndelay1   = 500\ndelay2   = 0D000h\t; delay between notes\nstartPitch = 60\n\n.code\nmain PROC\n\tin   al,speaker\t; get speaker status\n\tpush ax             \t; save status\n\tor   al,00000011b   \t; set lowest 2 bits\n\tout  speaker,al     \t; turn speaker on\n\tmov  al,startPitch          ; starting pitch\n\nL2:\n\tout  timer,al       \t; timer port: pulses speaker\n\n   ; Create a delay loop between pitches:\n\tmov  cx,delay1\nL3:\tpush cx\t; outer loop\n\tmov  cx,delay2\nL3a:\t; inner loop\n\tloop L3a\n\tpop  cx\n\tloop L3\n\n\tsub  al,1           \t; raise pitch\n\tjnz  L2             \t; play another note\n\n\tpop  ax              \t; get original status\n\tand  al,11111100b    \t; clear lowest 2 bits\n\tout  speaker,al\t; turn speaker off\n\texit"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\Seg2\\seg2.asm",
        "snippet": "TITLE Segment Example           (main module, Seg2.asm)\n\n; Startup module, which calls a procedure located in an \n; external module. Build this program using the make16.bat\n; file located in the same directory.\n; Last update: 06/01/2006\n\nEXTRN var2:WORD\n\n;subroutine_1 PROTO\t\t; replaced by the following line:\nEXTERN subroutine_1:PROC\t; required by MASM 8.0\n\ncseg SEGMENT BYTE PUBLIC 'CODE'\nASSUME cs:cseg,ds:dseg, ss:sseg\n\nmain PROC\n\tmov  ax,dseg        \t; initialize DS\n\tmov  ds,ax\n\n\tmov  ax,var1        \t; local variable\n\tmov  bx,var2        \t; external variable\n\tcall subroutine_1   \t; external procedure\n\n\tmov  ax,4C00h\t; exit to OS\n\tint  21h\nmain ENDP\ncseg ENDS\n\ndseg SEGMENT WORD PUBLIC 'DATA'   ; local data segment\n\tvar1 WORD 1000h\ndseg ends\n\nsseg SEGMENT STACK 'STACK'\t; stack segment\n\tBYTE 100h dup('S')\nsseg ENDS\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\Seg2\\seg2a.asm",
        "snippet": "TITLE Segment Example       (submodule, SEG2A.ASM)\n\n; External module for the Seg2 program. Build this program using\n; the make16.bat file located in the same directory.\n; Last update: 06/01/2006\n\nPUBLIC subroutine_1, var2\n\ncseg SEGMENT BYTE PUBLIC 'CODE'\nASSUME cs:cseg, ds:dseg\n\nsubroutine_1 PROC           ; called from MAIN\n\tmov ah,9\n\tmov dx,OFFSET msg\n\tint 21h\n\tret\nsubroutine_1 ENDP\ncseg ENDS\n\ndseg SEGMENT WORD PUBLIC 'DATA'\n\nvar2 WORD 2000h                ; accessed by MAIN\nmsg  BYTE 'Now in Subroutine_1'\n     BYTE 0Dh,0Ah,'$'\n\ndseg ENDS\nEND"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\Seg2",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\Seg2\\seg2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\Seg2\\seg2a.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\Seg2\\seg2.asm",
        "snippet": "TITLE Segment Example           (main module, Seg2.asm)\n\n; Startup module, which calls a procedure located in an \n; external module. Build this program using the make16.bat\n; file located in the same directory.\n; Last update: 06/01/2006\n\nEXTRN var2:WORD\n\n;subroutine_1 PROTO\t\t; replaced by the following line:\nEXTERN subroutine_1:PROC\t; required by MASM 8.0\n\ncseg SEGMENT BYTE PUBLIC 'CODE'\nASSUME cs:cseg,ds:dseg, ss:sseg\n\nmain PROC\n\tmov  ax,dseg        \t; initialize DS\n\tmov  ds,ax\n\n\tmov  ax,var1        \t; local variable\n\tmov  bx,var2        \t; external variable\n\tcall subroutine_1   \t; external procedure\n\n\tmov  ax,4C00h\t; exit to OS\n\tint  21h\nmain ENDP\ncseg ENDS\n\ndseg SEGMENT WORD PUBLIC 'DATA'   ; local data segment\n\tvar1 WORD 1000h\ndseg ends\n\nsseg SEGMENT STACK 'STACK'\t; stack segment\n\tBYTE 100h dup('S')\nsseg ENDS\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\ch17\\Seg2\\seg2a.asm",
        "snippet": "TITLE Segment Example       (submodule, SEG2A.ASM)\n\n; External module for the Seg2 program. Build this program using\n; the make16.bat file located in the same directory.\n; Last update: 06/01/2006\n\nPUBLIC subroutine_1, var2\n\ncseg SEGMENT BYTE PUBLIC 'CODE'\nASSUME cs:cseg, ds:dseg\n\nsubroutine_1 PROC           ; called from MAIN\n\tmov ah,9\n\tmov dx,OFFSET msg\n\tint 21h\n\tret\nsubroutine_1 ENDP\ncseg ENDS\n\ndseg SEGMENT WORD PUBLIC 'DATA'\n\nvar2 WORD 2000h                ; accessed by MAIN\nmsg  BYTE 'Now in Subroutine_1'\n     BYTE 0Dh,0Ah,'$'\n\ndseg ENDS\nEND"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\Addem",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\Addem\\addem.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\Addem\\addMain.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\Addem\\addem.asm",
        "snippet": "; The addem Subroutine    (addem.asm)\n\n; This subroutine links to Visual C++.\n\n.386P\n.model flat\npublic _addem\n\n.code\n_addem proc near\n    push   ebp\n    mov    ebp,esp\n    mov    eax,[ebp+16]    ; first argument\n    add    eax,[ebp+12]    ; second argument\n    add    eax,[ebp+8]     ; third argument\n    pop    ebp\n    ret                   \n_addem endp\nend"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\Addem\\addMain.cpp",
        "snippet": "// Addem Main Program      (AddMain.cpp) \n\n#include <iostream>\nusing namespace std;\n\nextern \"C\" int addem(int p1, int p2, int p3);\n\nint main()\n{\n  int total = addem( 10, 15, 25 );\n  cout << \"Total = \" << total << endl;\n  \n  system(\"pause\");\n  return 0;\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\IndexOf_asm",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\IndexOf_asm\\indexof.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\IndexOf_asm\\main.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\IndexOf_asm\\indexof.asm",
        "snippet": "; IndexOf function      (IndexOf.asm)\n\n.586\n.model flat,C\nIndexOf PROTO,\n\tsrchVal:DWORD, arrayPtr:PTR DWORD, count:DWORD\n\n.code\n;-----------------------------------------------\nIndexOf PROC uses ecx esi edi,\n\tsrchVal:DWORD, arrayPtr:PTR DWORD, count:DWORD\n;\n; Performs a linear search of a 32-bit integer array,\n; looking for a specific value. If the value is found,\n; the matching index position is returned in EAX; \n; otherwise, EAX equals -1.\n;-----------------------------------------------\n\tNOT_FOUND = -1\n\n \tmov  eax,srchVal    \t\t\t; search value\n \tmov  ecx,count      \t\t\t; array size\n\tmov  esi,arrayPtr\n\tmov  edi,0\t\t\t\t\t\t; index\n\nL1: cmp  [esi+edi*4],eax\n\tje   found\n\tinc\t edi\n\tloop L1\n\nnotFound:\t\n     mov  eax,NOT_FOUND\n     jmp  short exit\n\nfound:\n     mov\teax,edi\n\nexit:\n\t ret\t\t\t; EDI contains the index\nIndexOf ENDP\nEND"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\IndexOf_asm\\main.cpp",
        "snippet": "// main.cpp - Testing the IndexOf function.\n\n#include <iostream>\n#include <time.h>\n#include \"indexof.h\"\nusing namespace std;\n\nint main()  {\n\t// Fill an array with pseudorandom integers.\n\tconst unsigned ARRAY_SIZE = 100000; \n\tconst unsigned LOOP_SIZE = 30000;\n\tchar* boolstr[] = {\"false\",\"true\"};\n\n\tlong array[ARRAY_SIZE]; \n\tfor(unsigned i = 0; i < ARRAY_SIZE; i++) {\n     array[i] = rand() % 50000;\n\t}\n\t\n\tlong searchVal;\n\ttime_t startTime, endTime;\n\tcout << \"Enter an integer value to find: \";\n\tcin >> searchVal;\n\tcout << \"Please wait...\\n\";\n\n\t// Test the Assembly language function.\n\ttime( &startTime );\n\tlong index = 0;\n\n\tfor( unsigned n = 0; n < LOOP_SIZE; n++)\n\t\t index = IndexOf( searchVal, array, ARRAY_SIZE );\n\n\tbool found = index != -1;\n\n\ttime( &endTime );\n\tcout << \"Elapsed ASM time: \" << long(endTime - startTime) \n\t\t  << \" seconds. Found = \" << boolstr[found] << endl;\n\n\treturn 0;\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\IndexOf_cpp",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\IndexOf_cpp\\IndexOf.cpp",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\IndexOf_cpp\\main.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\IndexOf_cpp\\IndexOf.cpp",
        "snippet": "// IndexOf.cpp\n\n// Implements a linear search of an array of\n// long integers.\n\n#include \"indexof.h\"\n\nlong IndexOf( long searchVal, long array[], unsigned count )\n{\n\tfor(unsigned i = 0; i < count; i++) {\n\t\tif( array[i] == searchVal )\n\t\t\treturn i;\n\t}\n  return -1;\n}"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\chapt_13_examples\\IndexOf_cpp\\main.cpp",
        "snippet": "// main.cpp - Testing the IndexOf function.\n\n#include <iostream>\n#include <time.h>\n#include \"indexof.h\"\nusing namespace std;\n\nint main()  {\n\t// Fill an array with pseudorandom integers.\n\tconst unsigned ARRAY_SIZE = 100000; \n\tconst unsigned LOOP_SIZE = 30000;\n\tchar* boolstr[] = {\"false\",\"true\"};\n\n\tlong array[ARRAY_SIZE]; \n\tfor(unsigned i = 0; i < ARRAY_SIZE; i++)\n     array[i] = rand();\n\n\tlong searchVal;\n\ttime_t startTime, endTime;\n\tcout << \"Enter an integer value to find: \";\n\tcin >> searchVal;\n\tcout << \"Please wait...\\n\";\n\n\t// Test the Assembly language function.\n\ttime( &startTime );\n\tlong count = 0;\n\n\tfor( unsigned n = 0; n < LOOP_SIZE; n++)\n\t\t count = IndexOf( searchVal, array, ARRAY_SIZE );\n\n\tbool found = count != -1;\n\n\ttime( &endTime );\n\tcout << \"Elapsed ASM time: \" << long(endTime - startTime) \n\t\t  << \" seconds. Found = \" << boolstr[found] << endl;\n\n\treturn 0;\n}"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib16",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib16\\floatio.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib16\\Irvine16.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib16\\floatio.asm",
        "snippet": "; Floating Point IO Procedures           (floatio.asm)\n\nCOMMENT @\n\nAuthors:  W. A. Barrett, San Jose State University,\n          James Brink, Pacific Lutheran University\nUsed by Permission (July 2005).\n\nRead and Write Float -- these work from keyboard or to screen, using\n  Irvine's character fetching and putting functions.\n\nReadFloat -- accept a float in various formats, returning it in the top\n             stack position of the FPU\n\nWriteFloat -- Top stack value in the FPU is written out in a standard\n              format.\n              \nShowFPUStack -- Displays the floating-point unit's stack.\n\nUpdates:\n7/18/05: Minor editing and formatting by Kip Irvine\n7/19/05  Added checks for infinity and NaN.  \n         James Brink, Pacific Lutheran University  (lines marked with *********)\n7/20/05  WriteFloat no longer pops the stack. Kip Irvine.\n7/22/05  Assembled in 16-bit mode.\n\n\nTHINGS TO FIX:\n\t\n1. If the exponent is over 999, it is shown incorrectly.\n2. If a negative exponent is over 3 digits, the procedure halts.\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2\n\nINCLUDE irvine16.inc\nINCLUDE macros.inc\n\n; set this to 1 to display the FPU stack TOS value:\nDOSHOWTOP=0"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib16\\Irvine16.asm",
        "snippet": "TITLE  Link Library Functions\t\t(Irvine16.asm)\n\nComment @\n\n**** TODO *****\nTEST ParseDecimal32, ParseInteger32, ReadDec\n\nAdd CloseFile, CreateOutputFile, OpenInputFile, ReadFromFile,\nWriteToFile, StrLength, \n\t\n\nThis library was created exlusively for use with the book,\n\"Assembly Language for Intel-Based Computers, 4th Edition & 5th Edition\",\nby Kip R. Irvine, 2002 & 2006.\n\nCopyright 2002-2006, Prentice-Hall Incorporated. No part of this file may be\nreproduced, in any form or by any other means, without permission in writing\nfrom the publisher.\n\nUpdates to this file will be posted on the book's site:\nwww.asmirvine.com\n\nRecent update history:\n\t06/28/2005: Added SetTextColor\n\t7/8/05: Moved mShowRegister to macros.inc\n\t1/23/2010: Added ParseDecimal32, ParseInteger32, ReadDec\n\nAcknowledgements:\n------------------------------\nMost of the code in this library was written by Kip Irvine.\nSpecial thanks to Gerald Cahill for his many insights, suggestions, and bug fixes.\nAlso to Courtney Amor, a student at UCLA, and Ben Schwartz.\n\nAlphabetical Listing of Procedures\n----------------------------------\n(Unless otherwise marked, all procedures are documented in Chapter 5.)\n\nClrscr\nCrlf\nDelay"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\floatio.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\LibTest.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\main.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\floatio.asm",
        "snippet": "; Floating Point IO Procedures           (floatio.asm)\n\nCOMMENT @\n\nAuthors:  W. A. Barrett, San Jose State University,\n          James Brink, Pacific Lutheran University\nUsed by Permission (July 2005).\n\nRead and Write Float -- these work from keyboard or to screen, using\n  Irvine's character fetching and putting functions.\n\nReadFloat -- accept a float in various formats, returning it in the top\n             stack position of the FPU\n\nWriteFloat -- Top stack value in the FPU is written out in a standard\n              format.\n              \nShowFPUStack -- Displays the floating-point unit's stack.\n\n\nRequires 32-bit protected mode\n\nUpdates:\n7/18/05: Minor editing and formatting by Kip Irvine\n7/19/05  Added checks for infinity and NaN.  \n         James Brink, Pacific Lutheran University  (lines marked with *********)\n7/20/05  WriteFloat no longer pops the stack. Kip Irvine.\n6/13/06  ShowFPUStack no longer displays empty stack positions\n7/20/09  Minor code change to ReadFloat (Kip Irvine)\n4/19/11  Removed ReadFloat_old\n\nTHINGS TO FIX:\n\t\n1. If the exponent is over 999, it is shown incorrectly.\n2. If a negative exponent is over 3 digits, the procedure halts.\n3. Increase the number of digits to 16 (for REAL8 types).\n4. Optional: Use FSTENV and FLDENV to check the Tag Word Register \n\tfor information about each register's contents.\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32.asm",
        "snippet": "Title Irvine32 Link Library Source Code         (Irvine32.asm)\n\nComment @\nTo view this file with proper indentation, set your \n\teditor's tab stops to columns 5, 11, 35, and 40.\n\nRecent Updates:\n05/02/09: Str_trim\n12/11/2011: StrLength\n\nThis library was created exlusively for use with the book,\n\"Assembly Language for Intel-Based Computers\", 4th, 5th, and 6th Editions,\nby Kip R. Irvine, 2002-2010.\n\nCopyright 2002-2012, Prentice-Hall Publishing. No part of this file may be\nreproduced, in any form or by any other means, without permission in writing\nfrom the author or publisher.\n\nAcknowledgements:\n------------------------------\nMost of the code in this library was written by Kip Irvine.\nSpecial thanks to Gerald Cahill for his many insights, suggestions, and bug fixes.\nThanks to Richard Stam for his development of Readkey-related procedures.\nThanks to James Brink for helping to test the library.\n\nAlphabetical Listing of Public Procedures\n----------------------------------\n(Unless otherwise marked, all procedures are documented in Chapter 5.)\n\nCloseFile\nClrscr\nCreateOutputFile\nCrlf\nDelay\nDumpMem\nDumpRegs\nGetCommandTail\nGetDateTime\tChapter 11\nGetMaxXY\nGetMseconds"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\LibTest.asm",
        "snippet": "TITLE Test the Irvine32 Link Library      (LibTest.asm)\n\n; Use this program to test the Irvine32.asm library.\n\nINCLUDE Irvine32.inc\nINCLUDE macros.inc\n\n.data\ntemp BYTE \"#H\",0         \ndelimiter BYTE \"#\"\n\n.code\nmain PROC\n     movzx eax,delimiter\n     push  eax\n     push  offset temp\n     call Str_trim2\n\n\n    exit\nmain ENDP\n\n;-----------------------------------------------------------\nStr_trim2 PROC USES eax ecx edi,\n\tpString:PTR BYTE,\t\t\t; points to string\n\tchar:BYTE\t\t\t\t\t; char to remove\n;\n; NEW VERSION, DOES NOT USE SCASB\n; Remove all occurences of a given character from\n; the end of a string. \n; Returns: nothing\n; Last update: 5/2/09\n;-----------------------------------------------------------\n\tmov  edi,pString\n\tINVOKE Str_length,edi         ; puts length in EAX\n\tcmp  eax,0                    ; length zero?\n\tje   L3                       ; yes: exit now\n\tmov  ecx,eax                  ; no: ECX = string length\n\tdec  eax                      \n\tadd  edi,eax                  ; point to null byte at end"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\main.asm",
        "snippet": "TITLE MASM Template\t\t\t\t\t\t(main.asm)\n\n; Description:\n; \n; Revision date:\n\nINCLUDE Irvine32.inc\n.data\n\n.code\n\nmain PROC\n\tcall Clrscr\n\tcall GetMaxXY\n\n\texit\nmain ENDP\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\ClassLibraryProject\\AssemblyInfo.cpp",
        "snippet": "#include \"stdafx.h\"\n\nusing namespace System;\nusing namespace System::Reflection;\nusing namespace System::Runtime::CompilerServices;\nusing namespace System::Runtime::InteropServices;\nusing namespace System::Security::Permissions;\n\n//\n// General Information about an assembly is controlled through the following\n// set of attributes. Change these attribute values to modify the information\n// associated with an assembly.\n//\n[assembly:AssemblyTitleAttribute(\"ClassLibraryProject\")];\n[assembly:AssemblyDescriptionAttribute(\"\")];\n[assembly:AssemblyConfigurationAttribute(\"\")];\n[assembly:AssemblyCompanyAttribute(\"\")];\n[assembly:AssemblyProductAttribute(\"ClassLibraryProject\")];\n[assembly:AssemblyCopyrightAttribute(\"Copyright (c)  2011\")];\n[assembly:AssemblyTrademarkAttribute(\"\")];\n[assembly:AssemblyCultureAttribute(\"\")];\n\n//\n// Version information for an assembly consists of the following four values:\n//\n//      Major Version\n//      Minor Version\n//      Build Number\n//      Revision\n//\n// You can specify all the value or you can default the Revision and Build Numbers\n// by using the '*' as shown below:\n\n[assembly:AssemblyVersionAttribute(\"1.0.*\")];\n\n[assembly:ComVisible(false)];\n\n[assembly:CLSCompliantAttribute(true)];\n\n[assembly:SecurityPermission(SecurityAction::RequestMinimum, UnmanagedCode = true)];"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\ClassLibraryProject\\ClassLibraryProject.cpp",
        "snippet": "// This is the main DLL file.\n\n#include \"stdafx.h\"\n\n#include \"ClassLibraryProject.h\""
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\ClassLibraryProject\\Stdafx.cpp",
        "snippet": "// stdafx.cpp : source file that includes just the standard includes\n// ClassLibraryProject.pch will be the pre-compiled header\n// stdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\""
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library\\cmdtest.asm",
        "snippet": "; cmdtest.asm\n\nINCLUDE Irvine32.inc\n\n.data\n    cmdline    BYTE    144 DUP(0)\n\n\n.code\nmain PROC\n\tcall  ReadFloat\n\n\n\n\n\n    ; get command-line arguments\n    mov    edx, OFFSET cmdline\n    call    GetCommandTail\n\n    ; display command-line string\n    call    Crlf\n    call    Crlf\n    mov    al, '>'\n    call    WriteChar\n    mov    edx, OFFSET cmdline\n    call    WriteString\n    mov    al, '<'\n    call    WriteChar\n    call    Crlf\n    call    Crlf\n    exit\nmain ENDP\n\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library\\floatio.asm",
        "snippet": "; Floating Point IO Procedures           (floatio.asm)\n\nCOMMENT @\n\nAuthors:  W. A. Barrett, San Jose State University,\n          James Brink, Pacific Lutheran University\nUsed by Permission (July 2005).\n\nRead and Write Float -- these work from keyboard or to screen, using\n  Irvine's character fetching and putting functions.\n\nReadFloat -- accept a float in various formats, returning it in the top\n             stack position of the FPU\n\nWriteFloat -- Top stack value in the FPU is written out in a standard\n              format.\n              \nShowFPUStack -- Displays the floating-point unit's stack.\n\n\nRequires 32-bit protected mode\n\nUpdates:\n7/18/05: Minor editing and formatting by Kip Irvine\n7/19/05  Added checks for infinity and NaN.  \n         James Brink, Pacific Lutheran University  (lines marked with *********)\n7/20/05  WriteFloat no longer pops the stack. Kip Irvine.\n6/13/06  ShowFPUStack no longer displays empty stack positions\n7/20/09  Minor code change to ReadFloat (Kip Irvine)\n4/19/11  Removed ReadFloat_old\n\nTHINGS TO FIX:\n\t\n1. If the exponent is over 999, it is shown incorrectly.\n2. If a negative exponent is over 3 digits, the procedure halts.\n3. Increase the number of digits to 16 (for REAL8 types).\n4. Optional: Use FSTENV and FLDENV to check the Tag Word Register \n\tfor information about each register's contents.\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library\\Irvine32.asm",
        "snippet": "Title Irvine32 Link Library Source Code         (Irvine32.asm)\n\nComment @\nTo view this file with proper indentation, set your \n\teditor's tab stops to columns 5, 11, 35, and 40.\n\nRecent Updates:\n05/02/09: Str_trim\n12/11/2011: StrLength\n\nThis library was created exlusively for use with the book,\n\"Assembly Language for Intel-Based Computers\", 4th, 5th, and 6th Editions,\nby Kip R. Irvine, 2002-2010.\n\nCopyright 2002-2012, Prentice-Hall Publishing. No part of this file may be\nreproduced, in any form or by any other means, without permission in writing\nfrom the author or publisher.\n\nAcknowledgements:\n------------------------------\nMost of the code in this library was written by Kip Irvine.\nSpecial thanks to Gerald Cahill for his many insights, suggestions, and bug fixes.\nThanks to Richard Stam for his development of Readkey-related procedures.\nThanks to James Brink for helping to test the library.\n\nAlphabetical Listing of Public Procedures\n----------------------------------\n(Unless otherwise marked, all procedures are documented in Chapter 5.)\n\nCloseFile\nClrscr\nCreateOutputFile\nCrlf\nDelay\nDumpMem\nDumpRegs\nGetCommandTail\nGetDateTime\tChapter 11\nGetMaxXY\nGetMseconds"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\ClassLibraryProject",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\ClassLibraryProject\\AssemblyInfo.cpp",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\ClassLibraryProject\\ClassLibraryProject.cpp",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\ClassLibraryProject\\Stdafx.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\ClassLibraryProject\\AssemblyInfo.cpp",
        "snippet": "#include \"stdafx.h\"\n\nusing namespace System;\nusing namespace System::Reflection;\nusing namespace System::Runtime::CompilerServices;\nusing namespace System::Runtime::InteropServices;\nusing namespace System::Security::Permissions;\n\n//\n// General Information about an assembly is controlled through the following\n// set of attributes. Change these attribute values to modify the information\n// associated with an assembly.\n//\n[assembly:AssemblyTitleAttribute(\"ClassLibraryProject\")];\n[assembly:AssemblyDescriptionAttribute(\"\")];\n[assembly:AssemblyConfigurationAttribute(\"\")];\n[assembly:AssemblyCompanyAttribute(\"\")];\n[assembly:AssemblyProductAttribute(\"ClassLibraryProject\")];\n[assembly:AssemblyCopyrightAttribute(\"Copyright (c)  2011\")];\n[assembly:AssemblyTrademarkAttribute(\"\")];\n[assembly:AssemblyCultureAttribute(\"\")];\n\n//\n// Version information for an assembly consists of the following four values:\n//\n//      Major Version\n//      Minor Version\n//      Build Number\n//      Revision\n//\n// You can specify all the value or you can default the Revision and Build Numbers\n// by using the '*' as shown below:\n\n[assembly:AssemblyVersionAttribute(\"1.0.*\")];\n\n[assembly:ComVisible(false)];\n\n[assembly:CLSCompliantAttribute(true)];\n\n[assembly:SecurityPermission(SecurityAction::RequestMinimum, UnmanagedCode = true)];"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\ClassLibraryProject\\ClassLibraryProject.cpp",
        "snippet": "// This is the main DLL file.\n\n#include \"stdafx.h\"\n\n#include \"ClassLibraryProject.h\""
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\ClassLibraryProject\\Stdafx.cpp",
        "snippet": "// stdafx.cpp : source file that includes just the standard includes\n// ClassLibraryProject.pch will be the pre-compiled header\n// stdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\""
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library\\cmdtest.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library\\floatio.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library\\Irvine32.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library\\LibTest.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library\\cmdtest.asm",
        "snippet": "; cmdtest.asm\n\nINCLUDE Irvine32.inc\n\n.data\n    cmdline    BYTE    144 DUP(0)\n\n\n.code\nmain PROC\n\tcall  ReadFloat\n\n\n\n\n\n    ; get command-line arguments\n    mov    edx, OFFSET cmdline\n    call    GetCommandTail\n\n    ; display command-line string\n    call    Crlf\n    call    Crlf\n    mov    al, '>'\n    call    WriteChar\n    mov    edx, OFFSET cmdline\n    call    WriteString\n    mov    al, '<'\n    call    WriteChar\n    call    Crlf\n    call    Crlf\n    exit\nmain ENDP\n\n\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library\\floatio.asm",
        "snippet": "; Floating Point IO Procedures           (floatio.asm)\n\nCOMMENT @\n\nAuthors:  W. A. Barrett, San Jose State University,\n          James Brink, Pacific Lutheran University\nUsed by Permission (July 2005).\n\nRead and Write Float -- these work from keyboard or to screen, using\n  Irvine's character fetching and putting functions.\n\nReadFloat -- accept a float in various formats, returning it in the top\n             stack position of the FPU\n\nWriteFloat -- Top stack value in the FPU is written out in a standard\n              format.\n              \nShowFPUStack -- Displays the floating-point unit's stack.\n\n\nRequires 32-bit protected mode\n\nUpdates:\n7/18/05: Minor editing and formatting by Kip Irvine\n7/19/05  Added checks for infinity and NaN.  \n         James Brink, Pacific Lutheran University  (lines marked with *********)\n7/20/05  WriteFloat no longer pops the stack. Kip Irvine.\n6/13/06  ShowFPUStack no longer displays empty stack positions\n7/20/09  Minor code change to ReadFloat (Kip Irvine)\n4/19/11  Removed ReadFloat_old\n\nTHINGS TO FIX:\n\t\n1. If the exponent is over 999, it is shown incorrectly.\n2. If a negative exponent is over 3 digits, the procedure halts.\n3. Increase the number of digits to 16 (for REAL8 types).\n4. Optional: Use FSTENV and FLDENV to check the Tag Word Register \n\tfor information about each register's contents.\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library\\Irvine32.asm",
        "snippet": "Title Irvine32 Link Library Source Code         (Irvine32.asm)\n\nComment @\nTo view this file with proper indentation, set your \n\teditor's tab stops to columns 5, 11, 35, and 40.\n\nRecent Updates:\n05/02/09: Str_trim\n12/11/2011: StrLength\n\nThis library was created exlusively for use with the book,\n\"Assembly Language for Intel-Based Computers\", 4th, 5th, and 6th Editions,\nby Kip R. Irvine, 2002-2010.\n\nCopyright 2002-2012, Prentice-Hall Publishing. No part of this file may be\nreproduced, in any form or by any other means, without permission in writing\nfrom the author or publisher.\n\nAcknowledgements:\n------------------------------\nMost of the code in this library was written by Kip Irvine.\nSpecial thanks to Gerald Cahill for his many insights, suggestions, and bug fixes.\nThanks to Richard Stam for his development of Readkey-related procedures.\nThanks to James Brink for helping to test the library.\n\nAlphabetical Listing of Public Procedures\n----------------------------------\n(Unless otherwise marked, all procedures are documented in Chapter 5.)\n\nCloseFile\nClrscr\nCreateOutputFile\nCrlf\nDelay\nDumpMem\nDumpRegs\nGetCommandTail\nGetDateTime\tChapter 11\nGetMaxXY\nGetMseconds"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib32\\Irvine32_Library\\LibTest.asm",
        "snippet": "TITLE Test the Irvine32 Link Library      (LibTest.asm)\n\n; Use this program to test the Irvine32.asm library.\n\nINCLUDE Irvine32.inc\nINCLUDE macros.inc\n\n.data\nval1 REAL8\t1.2\nval2 REAL8\t3.4\n\n.code\nmain PROC\n\n\tfld\tval1\n\tfld\tval2\n\tcall\tShowFPUStack\n\t\n\tfmul\n\tcall\tShowFPUStack\n\n    exit\nmain ENDP\n\nEND main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib64",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib64\\Irvine64.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib64\\Lib64test.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib64\\Irvine64.asm",
        "snippet": "; 64-bit Library (Irvine64.asm)\n\n; Version 1.1, 7/2/2015\n\nCOMMENT !\nThis library was created exlusively for use with the book,\n\"Assembly Language for Intel-Based Computers\", 7th Edition,\nby Kip R. Irvine, 2014.\n\nCopyright 2014, Prentice-Hall Publishing. No part of this file may be\nreproduced, in any form or by any other means, without permission in writing\nfrom the author or publisher.\n\nWin64 API classifies RAX,RCX,RDX,R8,R9,R10,and R11 as volatile,\nso their values are not preserved across API function calls.\n\nBug fixes:\n7/2/2015: corrected the ReadString procedure.\n\n\n!\n\n; Public procedures:\n; Crlf\n; Randomize\n; Random64\n; RandomRange\n; ReadInt64\n; ReadString\n; Str_compare\n; Str_copy\n; Str_length\n; WriteHexB\n; WriteHex32\n; WriteHex64\n; WriteInt64\n; WriteString\n\n; This library calls the following external procedures from the Windows API:\nGetConsoleMode proto"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Lib64\\Lib64test.asm",
        "snippet": "; testing 64-bit Windows API\t\t\t(Lib64test.asm)\n;  Chapter 5 example\n\nExitProcess \tproto\nReadInt64       proto\nReadString      proto\nWriteString\t\tproto\nWriteInt64\t\tproto\nWriteHex32\t\tproto\nWriteHex64\t\tproto\nCrlf \t\t\t\tproto\n\n.data\nmessage BYTE \"Testing the Irvine64 library\",0\nmaxval qword 9223372036854775807\nminval qword -9223372036854775808\nhexval qword 0123456789ABCDEFh\ninbuf  BYTE  50 dup(0),0\ninbuf_size = $ - inbuf\n\n.code\nmain proc\n\n\tmov   rdx,offset inbuf\n\tmov   rcx,inbuf_size\n\tcall  ReadString\t\t\t; read a string (RAX = length)\n\n\tmov\t  rdx,offset message\n\tcall  WriteString\n\tcall  Crlf\n\n\tcall  ReadInt64\t\t\t\t; read value into rax\n\tcall  Crlf\n\tcall  WriteInt64\t\t\t; display rax \n\tcall  Crlf\n\n\tmov   rdx,offset inbuf\n\tmov   rcx,inbuf_size\n\tcall  ReadString\t\t\t; read a string (RAX = length)\n\tcall  WriteInt64\t\t\t; display the string length"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2017",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2017\\AddTwo.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2017\\StructExample.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2017\\test.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2017\\AddTwo.asm",
        "snippet": "; AddTwo.asm - adds two 32-bit integers.\n; Chapter 3 example\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2017\\StructExample.asm",
        "snippet": "; Structure example(32 - bit)\n\n.386\n.model flat, stdcall\n.stack 4096\nExitProcess proto, dwExitCode:dword\n\nEmployee STRUCT                            \n     IdNum BYTE \"000000000\"                \n     LastName BYTE 30 DUP(0)               \n     ;ALIGN WORD                           \n     Years WORD 30                         \n     ;ALIGN DWORD                          \n     SalaryHistory DWORD 0, 0, 0, 0        \nEmployee ENDS\n\n;// size of structure: 0x39, or 57 bytes\n\n.data\nemployees Employee 5 DUP(<\"111111111\", \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", 0FFh, 4 DUP(0EEEEEEEEh)>)\n; hex offsets:  00--08, 09-26, 27, 29-38.\n\n\n.code\nmain proc\n\tmov esi,0\n     mov eax,0\n     mov ax, employees[esi].Years         ; AX = 0xFF\n\n     mov edx,SIZEOF Employee\n\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2017\\test.asm",
        "snippet": "; Test.asm\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n.data\nwordVal SWORD -101\t\t\t; FF9Bh\n\n.code\nmain proc\n\tmov\tdx, 0\n\tmov \tax, wordVal\t\t\t; DX:AX = 0000FF9Bh (+65, 435)\n\tcwd\n\tmov \tbx, 2\t\t\t\t; BX is the divisor\n\tidiv\tbx\t\t\t\t\t; divide DX : AX by BX (signed operation)\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2019",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2019\\AddSub2.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2019\\AddTwo.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2019\\AddTwoProgram_DemetriusJohnson.asm",
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2019\\StructExample.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2019\\AddSub2.asm",
        "snippet": "TITLE Add and Subtract, Version 2         (AddSub2.asm)\n\n; This program adds and subtracts 32-bit integers\n; and stores the sum in a variable.\n\nINCLUDE Irvine32.inc\n\n.data\nval1     dword  10000h\nval2     dword  40000h\nval3     dword  20000h\nfinalVal dword  ?\n\n.code\nmain PROC\n\n\tmov\teax,val1\t\t\t; start with 10000h\n\tadd\teax,val2\t\t\t; add 40000h\n\tsub\teax,val3\t\t\t; subtract 20000h\n\tmov\tfinalVal,eax\t\t; store the result (30000h)\n\tcall\tDumpRegs\t\t\t; display the registers\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2019\\AddTwo.asm",
        "snippet": "; AddTwo.asm - adds two 32-bit integers.\n; Chapter 3 example\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2019\\AddTwoProgram_DemetriusJohnson.asm",
        "snippet": "; AddTwo.asm - adds two 32-bit integers.\n; Chapter 3 example\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n\n.data\n\tA DWORD 30 ;initalize variable A to 30d\n\tB DWORD 20 ;initialize variable B to 20d\n\tC1 DWORD 10 ;intialize variable C1 to 10d\n\tD DWORD 5 ;initialize variable D to 5d\n\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project32_VS2019\\StructExample.asm",
        "snippet": "; Structure example(32 - bit)\n\n.386\n.model flat, stdcall\n.stack 4096\nExitProcess proto, dwExitCode:dword\n\nEmployee STRUCT                            \n     IdNum BYTE \"000000000\"                \n     LastName BYTE 30 DUP(0)               \n     ;ALIGN WORD                           \n     Years WORD 30                         \n     ;ALIGN DWORD                          \n     SalaryHistory DWORD 0, 0, 0, 0        \nEmployee ENDS\n\n;// size of structure: 0x39, or 57 bytes\n\n.data\nemployees Employee 5 DUP(<\"111111111\", \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", 0FFh, 4 DUP(0EEEEEEEEh)>)\n; hex offsets:  00--08, 09-26, 27, 29-38.\n\n\n.code\nmain proc\n\tmov esi,0\n     mov eax,0\n     mov ax, employees[esi].Years         ; AX = 0xFF\n\n     mov edx,SIZEOF Employee\n\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project64_VS2019",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project64_VS2019\\AddTwoSum_64.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\Project64_VS2019\\AddTwoSum_64.asm",
        "snippet": "; AddTwoSum_64.asm - Chapter 3 example.\n\nExitProcess proto\n\n.data\nsum qword 0\n\n.code\nmain proc\n\tmov\trax,5\n\tadd\trax,6\n\tmov   sum,rax\n\n\tmov   ecx,0\n\tcall  ExitProcess\n\nmain endp\nend"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\test",
    "code_files": [
      "ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\test\\16-bit.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\ExampleProgs_Irvine_32bitAND64bit\\irvine\\examples\\test\\16-bit.asm",
        "snippet": "TITLE Add and Subtract              (16-bit.asm)\n\n; This program adds and subtracts 32-bit integers.\n\nINCLUDE Irvine16.inc\n\n.code\nmain PROC\n\tmov\tax,@data\n\tmov\tds,ax\n\n\tmov\teax,10000h\t\t; EAX = 10000h\n\tadd\teax,40000h\t\t; EAX = 50000h\n\tsub\teax,20000h\t\t; EAX = 30000h\n\tcall\tDumpRegs\n\n\texit\nmain ENDP\nEND main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "Program1_CIS-310_DemetriusJohnson\\Project32_VS2019",
    "code_files": [
      "Program1_CIS-310_DemetriusJohnson\\Project32_VS2019\\AddSub2.asm",
      "Program1_CIS-310_DemetriusJohnson\\Project32_VS2019\\AddTwo.asm",
      "Program1_CIS-310_DemetriusJohnson\\Project32_VS2019\\AddTwoProgram_DemetriusJohnson.asm",
      "Program1_CIS-310_DemetriusJohnson\\Project32_VS2019\\StructExample.asm"
    ],
    "snippets": [
      {
        "file": "CIS-310\\Program1_CIS-310_DemetriusJohnson\\Project32_VS2019\\AddSub2.asm",
        "snippet": "TITLE Add and Subtract, Version 2         (AddSub2.asm)\n\n; This program adds and subtracts 32-bit integers\n; and stores the sum in a variable.\n\nINCLUDE Irvine32.inc\n\n.data\nval1     dword  10000h\nval2     dword  40000h\nval3     dword  20000h\nfinalVal dword  ?\n\n.code\nmain PROC\n\n\tmov\teax,val1\t\t\t; start with 10000h\n\tadd\teax,val2\t\t\t; add 40000h\n\tsub\teax,val3\t\t\t; subtract 20000h\n\tmov\tfinalVal,eax\t\t; store the result (30000h)\n\tcall\tDumpRegs\t\t\t; display the registers\n\n\texit\nmain ENDP\nEND main"
      },
      {
        "file": "CIS-310\\Program1_CIS-310_DemetriusJohnson\\Project32_VS2019\\AddTwo.asm",
        "snippet": "; AddTwo.asm - adds two 32-bit integers.\n; Chapter 3 example\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\Program1_CIS-310_DemetriusJohnson\\Project32_VS2019\\AddTwoProgram_DemetriusJohnson.asm",
        "snippet": "; AddTwo.asm - adds two 32-bit integers.\n; Chapter 3 example\n\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n\n.data\n\tA DWORD 30 ;initalize variable A to 30d\n\tB DWORD 20 ;initialize variable B to 20d\n\tC1 DWORD 10 ;intialize variable C1 to 10d\n\tD DWORD 5 ;initialize variable D to 5d\n\n\n.code\nmain proc\n\tmov\teax,5\t\t\t\t\n\tadd\teax,6\t\t\t\t\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      },
      {
        "file": "CIS-310\\Program1_CIS-310_DemetriusJohnson\\Project32_VS2019\\StructExample.asm",
        "snippet": "; Structure example(32 - bit)\n\n.386\n.model flat, stdcall\n.stack 4096\nExitProcess proto, dwExitCode:dword\n\nEmployee STRUCT                            \n     IdNum BYTE \"000000000\"                \n     LastName BYTE 30 DUP(0)               \n     ;ALIGN WORD                           \n     Years WORD 30                         \n     ;ALIGN DWORD                          \n     SalaryHistory DWORD 0, 0, 0, 0        \nEmployee ENDS\n\n;// size of structure: 0x39, or 57 bytes\n\n.data\nemployees Employee 5 DUP(<\"111111111\", \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", 0FFh, 4 DUP(0EEEEEEEEh)>)\n; hex offsets:  00--08, 09-26, 27, 29-38.\n\n\n.code\nmain proc\n\tmov esi,0\n     mov eax,0\n     mov ax, employees[esi].Years         ; AX = 0xFF\n\n     mov edx,SIZEOF Employee\n\n\n\tinvoke ExitProcess,0\nmain endp\nend main"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "WEEK_1-1\\PROG#0\\Program0_CIS-310_DemetriusJohnson",
    "code_files": [
      "WEEK_1-1\\PROG#0\\Program0_CIS-310_DemetriusJohnson\\BinaryClass.cpp",
      "WEEK_1-1\\PROG#0\\Program0_CIS-310_DemetriusJohnson\\HexidecimalClass.cpp",
      "WEEK_1-1\\PROG#0\\Program0_CIS-310_DemetriusJohnson\\MAIN_Program0_CIS-310_DemetriusJohnson.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\WEEK_1-1\\PROG#0\\Program0_CIS-310_DemetriusJohnson\\BinaryClass.cpp",
        "snippet": "#include \"BinaryClass.h\"\n\nBinaryClass::BinaryClass() {\n\n\tdecimalVal = 0; //used to store the object's decimal value\n\tbinaryVal = 0;//used to store the object's binary value\n\twholeNum = 0; //use this variable to capture only the digits greater than or equal to 1 (whole numbers/digits to the left of the decimal)\n\tfractionDigits = 0; //use this variable to store the decimal digits (if any) of the passed decimal value \n\n\n\n}\nBinaryClass& BinaryClass::operator=(double decimalNumber) {\n\n\tbinaryVal = 0; //need to reset the binary value everytime the =operator is called otherwise it will be manipulated while old data is still stored in the variable\n\twholeNum = decimalNumber; //use this variable to store the non fractional portion of the decimal number\n\tfractionDigits = decimalNumber - wholeNum; //use this variable to store the decimal digits (if any) of the passed decimal value \n\n\t//I made the above in such a way as for if I ever extend this program to convert decimal digits with digits in place values to the right of the decimal as well\n\n\tfor (int i = 0; i < 8; i++) { //reset output array values to all 0s\n\n\t\toutputArray[i] = 0;\n\n\t}\n\n\tdecimalVal = decimalNumber; //set decimal value for the binary object to the passed-in decimal number simply for storage purposes of the object's decimal equivalent\n\tint powerOf_10 = 1; //use this to go to the next power of 10 for each time we have to divide the decimal by 2 when converting ot binary\n\tint remainder = 0; //use this to keep track of wether or not a division will leave a remainder\n\tint counter = 7; //use this to keep track of counter for the outputArray to store the binary values\n\n\twhile (wholeNum != 0) {\n\n\t\t\n\t\tremainder = wholeNum % 2; //obtain remainder of a division by 2\n\t\twholeNum /= 2; //perform integer division by 2\n\t\tif (remainder != 0) { \n\t\t\t//if remainder exists, then we use the algorithm for converting to binary; that is, when there is a remainder after dividing by two, we place a '1' in the next binary place value"
      },
      {
        "file": "CIS-310\\WEEK_1-1\\PROG#0\\Program0_CIS-310_DemetriusJohnson\\HexidecimalClass.cpp",
        "snippet": "#include \"HexidecimalClass.h\"\n\n\nHexidecimalClass::HexidecimalClass() { //default constructor\n\t\n\n}\nHexidecimalClass& HexidecimalClass::operator=(float decimalNumber) {\n\n\thexVal[0] = 48; //from ASCII, decimal 30 is the equivalent of char '0'\n\thexVal[1] = 48;\n\t//use the above to reset the hex digits to 00 (char characters '0')\n\n\twholeNum = decimalNumber; //use this variable to store the non fractional portion of the decimal number\n\tfractionDigits = decimalNumber - wholeNum; //use this variable to store the decimal digits (if any) of the passed decimal value \n\n\t//I made the above in such a way as for if I ever extend this program to convert decimal digits with digits in place values to the right of the decimal as well\n\n\tdecimalVal = decimalNumber; //set decimal value for the Hex object to the passed-in decimal number simply for storage purposes of the object's decimal equivalent\n\tint remainder = 0; //use this to keep track of wether or not a division will leave a remainder\n\tint elementPos = 1; //element position variable used to keep track of where to input the next value (0-F) into the Hexidecimal number (the char array)\n\n\twhile (wholeNum != 0) {\n\n\n\t\tremainder = (wholeNum % 16) + 48; //obtain remainder of a division by 16 \n\t\t\t\t\t\t\t\t\t//using ASCII we add 48 (48-57 is '0'-'9' char, since a char data structure defines its output based on this standard\n\t\tif (remainder > 57) { //execute this loop to obtain digits 10-15 (characters A-F) of base 16 place value numbers\n\n\t\t\tremainder += 7; //58+7 == 65 which is 'A' for the char data type\n\n\t\t}\n\t\t\n\t\thexVal[elementPos] = remainder; //set the proper place value to the appropriate number (0-F)\n\t\t\t\t\t\t\t\t\t\t  \n\t\twholeNum /= 16; //perform integer division by 16 (finishing the last step in this iteration of the algorithm)\n\t\n\t\telementPos--; //decrement place value to go to the next place value (moving from right to left according to the algorithm)"
      },
      {
        "file": "CIS-310\\WEEK_1-1\\PROG#0\\Program0_CIS-310_DemetriusJohnson\\MAIN_Program0_CIS-310_DemetriusJohnson.cpp",
        "snippet": "// Program0_CIS-310_DemetriusJohnson.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n/*\n\nProgram # 0\nCIS 310 (Yoon)\nWinter 2021\nUpload it by Mid-night, 1/24/21 (Sun)\n\nWrite a program in C or C++  that converts decimal numbers to binary, hexadecimal, and BCD (Binary Coded Decimal). \nYou are not allowed to use library functions to do conversion.  The output should look as follows.  \nSend the output to a file and upload it along with your source file.\n\n\nDECIMAL \tBINARY\t\tHEXDECIMAL\t\t        BCD\n0\t\t    0000 0000\t\t00\t\t\t\t0000 0000 0000\n1\t\t    0000 0001\t\t01\t\t\t\t0000 0000 0001\n2\t\t    0000 0010\t\t02\t\t\t\t0000 0000 0010\n.\t\t    .\t\t         .\t\t\t\t   .\n.\t\t    .\t\t         .\t\t           .\n255\t\t    1111 1111       FF\t\t        0010 0101 0101\n\n\nFor uploading information, see the file called SYLLABUS/GUIDELINE.\n\n\n\n\n\n\n*/\n\n\n#include <iostream>\n#include <fstream>\n#include \"BinaryClass.h\"\n#include \"HexidecimalClass.h\"\n#include <string>\n#include <iomanip> //use this to output a table"
      }
    ]
  },
  {
    "repo": "CIS-310",
    "folder": "WEEK_1-1\\PROG#0\\Program0_finished_DemetriusJohnson-CIS-310",
    "code_files": [
      "WEEK_1-1\\PROG#0\\Program0_finished_DemetriusJohnson-CIS-310\\BinaryClass.cpp",
      "WEEK_1-1\\PROG#0\\Program0_finished_DemetriusJohnson-CIS-310\\HexidecimalClass.cpp",
      "WEEK_1-1\\PROG#0\\Program0_finished_DemetriusJohnson-CIS-310\\MAIN_Program0_CIS-310_DemetriusJohnson.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-310\\WEEK_1-1\\PROG#0\\Program0_finished_DemetriusJohnson-CIS-310\\BinaryClass.cpp",
        "snippet": "#include \"BinaryClass.h\"\n\nBinaryClass::BinaryClass() {\n\n\tdecimalVal = 0; //used to store the object's decimal value\n\tbinaryVal = 0;//used to store the object's binary value\n\twholeNum = 0; //use this variable to capture only the digits greater than or equal to 1 (whole numbers/digits to the left of the decimal)\n\tfractionDigits = 0; //use this variable to store the decimal digits (if any) of the passed decimal value \n\n\n\n}\nBinaryClass& BinaryClass::operator=(double decimalNumber) {\n\n\tbinaryVal = 0; //need to reset the binary value everytime the =operator is called otherwise it will be manipulated while old data is still stored in the variable\n\twholeNum = decimalNumber; //use this variable to store the non fractional portion of the decimal number\n\tfractionDigits = decimalNumber - wholeNum; //use this variable to store the decimal digits (if any) of the passed decimal value \n\n\t//I made the above in such a way as for if I ever extend this program to convert decimal digits with digits in place values to the right of the decimal as well\n\n\tfor (int i = 0; i < 8; i++) { //reset output array values to all 0s\n\n\t\toutputArray[i] = 0;\n\n\t}\n\n\tdecimalVal = decimalNumber; //set decimal value for the binary object to the passed-in decimal number simply for storage purposes of the object's decimal equivalent\n\tint powerOf_10 = 1; //use this to go to the next power of 10 for each time we have to divide the decimal by 2 when converting ot binary\n\tint remainder = 0; //use this to keep track of wether or not a division will leave a remainder\n\tint counter = 7; //use this to keep track of counter for the outputArray to store the binary values\n\n\twhile (wholeNum != 0) {\n\n\t\t\n\t\tremainder = wholeNum % 2; //obtain remainder of a division by 2\n\t\twholeNum /= 2; //perform integer division by 2\n\t\tif (remainder != 0) { \n\t\t\t//if remainder exists, then we use the algorithm for converting to binary; that is, when there is a remainder after dividing by two, we place a '1' in the next binary place value"
      },
      {
        "file": "CIS-310\\WEEK_1-1\\PROG#0\\Program0_finished_DemetriusJohnson-CIS-310\\HexidecimalClass.cpp",
        "snippet": "#include \"HexidecimalClass.h\"\n\n\nHexidecimalClass::HexidecimalClass() { //default constructor\n\t\n\n}\nHexidecimalClass& HexidecimalClass::operator=(float decimalNumber) {\n\n\thexVal[0] = 48; //from ASCII, decimal 30 is the equivalent of char '0'\n\thexVal[1] = 48;\n\t//use the above to reset the hex digits to 00 (char characters '0')\n\n\twholeNum = decimalNumber; //use this variable to store the non fractional portion of the decimal number\n\tfractionDigits = decimalNumber - wholeNum; //use this variable to store the decimal digits (if any) of the passed decimal value \n\n\t//I made the above in such a way as for if I ever extend this program to convert decimal digits with digits in place values to the right of the decimal as well\n\n\tdecimalVal = decimalNumber; //set decimal value for the Hex object to the passed-in decimal number simply for storage purposes of the object's decimal equivalent\n\tint remainder = 0; //use this to keep track of wether or not a division will leave a remainder\n\tint elementPos = 1; //element position variable used to keep track of where to input the next value (0-F) into the Hexidecimal number (the char array)\n\n\twhile (wholeNum != 0) {\n\n\n\t\tremainder = (wholeNum % 16) + 48; //obtain remainder of a division by 16 \n\t\t\t\t\t\t\t\t\t//using ASCII we add 48 (48-57 is '0'-'9' char, since a char data structure defines its output based on this standard\n\t\tif (remainder > 57) { //execute this loop to obtain digits 10-15 (characters A-F) of base 16 place value numbers\n\n\t\t\tremainder += 7; //58+7 == 65 which is 'A' for the char data type\n\n\t\t}\n\t\t\n\t\thexVal[elementPos] = remainder; //set the proper place value to the appropriate number (0-F)\n\t\t\t\t\t\t\t\t\t\t  \n\t\twholeNum /= 16; //perform integer division by 16 (finishing the last step in this iteration of the algorithm)\n\t\n\t\telementPos--; //decrement place value to go to the next place value (moving from right to left according to the algorithm)"
      },
      {
        "file": "CIS-310\\WEEK_1-1\\PROG#0\\Program0_finished_DemetriusJohnson-CIS-310\\MAIN_Program0_CIS-310_DemetriusJohnson.cpp",
        "snippet": "// Program0_CIS-310_DemetriusJohnson.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n/*\n\nProgram # 0\nCIS 310 (Yoon)\nWinter 2021\nUpload it by Mid-night, 1/24/21 (Sun)\n\nWrite a program in C or C++  that converts decimal numbers to binary, hexadecimal, and BCD (Binary Coded Decimal). \nYou are not allowed to use library functions to do conversion.  The output should look as follows.  \nSend the output to a file and upload it along with your source file.\n\n\nDECIMAL \tBINARY\t\tHEXDECIMAL\t\t        BCD\n0\t\t    0000 0000\t\t00\t\t\t\t0000 0000 0000\n1\t\t    0000 0001\t\t01\t\t\t\t0000 0000 0001\n2\t\t    0000 0010\t\t02\t\t\t\t0000 0000 0010\n.\t\t    .\t\t         .\t\t\t\t   .\n.\t\t    .\t\t         .\t\t           .\n255\t\t    1111 1111       FF\t\t        0010 0101 0101\n\n\nFor uploading information, see the file called SYLLABUS/GUIDELINE.\n\n\n\n\n\n\n*/\n\n\n#include <iostream>\n#include <fstream>\n#include \"BinaryClass.h\"\n#include \"HexidecimalClass.h\"\n#include <string>\n#include <iomanip> //use this to output a table"
      }
    ]
  }
]