[
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "class notes and resources",
    "code_files": [
      "class notes and resources\\Idiot Proofing Functions.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\class notes and resources\\Idiot Proofing Functions.cpp",
        "snippet": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/***************************************\n\t\t  FUNCTION PROTOTYPES\n****************************************/\n\nint getInt( string message = \"Please enter an integer: \");\nbool getInt(int& userVal, const int maxAttempts,  string message = \"Please enter an integer: \");\nint getInt(bool minOrMax, int minMaxVal, string message = \"Please input an integer in range: \");\nint getInt(bool inside, int minVal, int maxVal, string message = \"Please input an integer for range: \");\nbool getInt(bool minOrMax, int minMaxVal, int & userVal, int maxAttempts, string message = \"Please input an integer for range : \");\nbool getInt(bool inside, int minVal, int maxVal, int& userVal, int maxAttempts, string message = \"Please input an integer for range : \");\n\n\nlong getLong(string message = \"Please enter a long: \");\nbool getLong(long & userVal, const int maxAttempts, string message = \"Please enter a long: \");\nlong getLong(bool minOrMax, long minMaxVal, string message = \"Please input a long in range: \");\nlong getLong(bool inside, long minVal, long maxVal, string message = \"Please input a long for range: \");\nbool getLong(bool minOrMax, long minMaxVal, long & userVal, int maxAttempts, string message = \"Please input a long for range : \");\nbool getLong(bool inside, long minVal, long maxVal, long & userVal, int maxAttempts, string message = \"Please input a long for range : \");\n\n\nfloat getFloat(string message = \"Please enter a float: \");\nbool getFloat(float & userVal, const int maxAttempts, string message = \"Please enter n float: \");\nfloat getFloat(bool minOrMax, float minMaxVal, string message = \"Please input a float in range: \");\nfloat getFloat(bool inside, float minVal, float maxVal, string message = \"Please input a float for range: \");\nbool getFloat(bool minOrMax, float minMaxVal, float & userVal, int maxAttempts, string message = \"Please input a float for range : \");\nbool getFloat(bool inside, float minVal, float maxVal, float& userVal, int maxAttempts, string message = \"Please input a float for range : \");\n\n\ndouble getDouble(string message = \"Please enter a double: \");\nbool getDouble(double & userVal, const int maxAttempts, string message = \"Please enter n double: \");\ndouble getDouble(bool minOrMax, double minMaxVal, string message = \"Please input a double in range: \");\ndouble getDouble(bool inside, double minVal, double maxVal, string message = \"Please input a double for range: \");\nbool getDouble(bool minOrMax, double minMaxVal, double & userVal, int maxAttempts, string message = \"Please input a double for range : \");\nbool getDouble(bool inside, double minVal, double maxVal, double & userVal, int maxAttempts, string message = \"Please input a double for range : \");"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "labs\\CIS 200 LAB 1\\JohnsonDemetriusLab01",
    "code_files": [
      "labs\\CIS 200 LAB 1\\JohnsonDemetriusLab01\\JohnsonDemetriusLab01-MAIN.cpp",
      "labs\\CIS 200 LAB 1\\JohnsonDemetriusLab01\\student.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 1\\JohnsonDemetriusLab01\\JohnsonDemetriusLab01-MAIN.cpp",
        "snippet": "/*\n\t*Author: Demetrius Johnson\n\t*Creation Date: 13 Sept 2020\n\t*Modification Date: 13 Sept 2020\n\t*Purpose: review CIS 150 by using files, pass by reference, constructors, and destructors\n\n\t// LAB 1 - CIS 200\n\n\tQuestion 1\n\t-------------------------\n\tProgram:\n\nUse separate source files and header files to create a class to represent students.\na.\tA student object has attributes of major (string) and credit hours taken (integer).  \nb.\tMember functions (methods) are as follows (no additional ones may be created):\ni.\tUsing a constructor initializer list, create a constructor with default parameter values of General Studies and -1, and that displays \\n\\tConstructor called for major <major> and hours <hours>\\n, replacing <major> and <hours> with attribute values.\nii.\tindividual const get methods (in-line definition) for each attribute\niii.\ta const get method (NOT in-line) that uses pass-by-reference for both parameters and has return-type void\niv.\tone set method (NOT in-line) that sets both attributes\nv.\tPrintMe method (NOT in-line) that returns string Im a <major> major and have completed <x> credit hours., replacing <major> and <x> with the appropriate attribute values\nvi.\tDestructor (in-line) that displays \\n\\tDestructor called for <major> major.\\n, replacing <major> with the appropriate attribute value\n\n\n\n\nWrite a complete program that uses the student class you created and tests its functionality\nb.\tDeclare a single student object and during declaration initialize it to have major Astrophysics; do not provide a value for number of credit hours\nc.\tCall the PrintMe method of the single student object and display to the screen/console\nd.\tAsk the user for the name of a file to which output should be written\ne.\tDeclare a vector of 5 objects of student class\ni.\tAsk the user for 5 majors and 5 credit hours and assign them to each student in the vector. The credit hours must be verified as non-negative or else get another number. This must be tested in your output.\nii.\tOpen the file and write to it using the value returned by PrintMe for every student in your vector\nf.\tExplicitly close the output file\ng.\tAny other tests you deem appropriate to prove your program works perfectly\n\nIn order to properly capture the destructor messages, put a breakpoint on the return statement in main. When the program pauses at that line, press F10 once, capture the output screen as a snippet, then press F5 to finish execution."
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 1\\JohnsonDemetriusLab01\\student.cpp",
        "snippet": "#include \"student.h\"\n\n\n\n\n//constructor initializer list\nstudent::student(string userInputMajor, int userInputCredits):major(userInputMajor), creditHrsCompleted(userInputCredits) { \n\n\tcout << \"\\n\\t***Constructor called for major '\" << major << \"' and hours \" << creditHrsCompleted << \".***\\n\"; //this will show in the program how subobjects are created when the constructor is called\n\n}\n\nstudent::~student() {\n\tcout << \"\\n***destrcutor has been called, object and all subobjects destroyed; memory reallocated successfully.***\\n\";\n\tsystem (\"pause\"); //put in a system pause so that we can see destructor message easily\n}\n\n\nvoid student::setMajorAndHrs(string userInputMajor, int userInputHrs) { //defined NOT INLINE per instructions\n\t\n\tmajor = userInputMajor;\n\tcreditHrsCompleted = userInputHrs;\n}\n\nvoid student::getMajorAndHrsByRef(string& majorstring, int& creditHrs) { //use this by reference getter function to write to a file\n\t\n\tmajorstring = major;\n\tcreditHrs = creditHrsCompleted;\n}\n\nstring student::PrintMe_MajorAndHrs() {\n\tstringstream ss; //will use streamstring to turn creditHrs integer into a string so that I can use addition of strings operands.\n\tstring creditHrsString;\n\n\tss << creditHrsCompleted;\n\tss >> creditHrsString;\n\n\tstring PRINTstring = \"\\nI'm a \" + major +\" and have completed \" + creditHrsString + \" credit hours.\\n\";"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "labs\\CIS 200 LAB 10\\LAB 10 CIS 200",
    "code_files": [
      "labs\\CIS 200 LAB 10\\LAB 10 CIS 200\\LAB 10 CIS 200.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 10\\LAB 10 CIS 200\\LAB 10 CIS 200.cpp",
        "snippet": "// LAB 10 CIS 200.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n}\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "labs\\CIS 200 LAB 2\\CIS-200-LAB2-DemetriusJohnson",
    "code_files": [
      "labs\\CIS 200 LAB 2\\CIS-200-LAB2-DemetriusJohnson\\Q1_CIS-200-LAB2-DemetriusJohnson.cpp",
      "labs\\CIS 200 LAB 2\\CIS-200-LAB2-DemetriusJohnson\\Q2_CIS-200-LAB2-DemetriusJohnson.cpp",
      "labs\\CIS 200 LAB 2\\CIS-200-LAB2-DemetriusJohnson\\Q3_CIS-200-LAB2-DemetriusJohnson.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 2\\CIS-200-LAB2-DemetriusJohnson\\Q1_CIS-200-LAB2-DemetriusJohnson.cpp",
        "snippet": "/*  *Author: Demetrius Johnson\n\t*Creation Date: 20 Sept. 2020\n\t*Modification Date: 22 Sept. 2020\n\t*Purpose: *****\n\n\tQuestion 1:\n\n\tUse the following code snippet as the basis for a program to test all possible combinations of pointer manipulation.\n\tEach of the 10 combinations must be tested separately since the pointer may move and array values may be changed:\n\n\tint X[] = { 3, 7, 11, 17, 23 };\n\tint * xPtr = & X[2];\n\tcout << X[1] << ' ' << X[2] << ' ' << X[3] << ' ' << xPtr << \" : \" << *xPtr << endl;\n\n\tcout << \"Array content prior to pointer manipulation\\n\";\n\t// replace AAA in the following statement with selection from list of 10 pointer actions below, one at a time\n\tcout << AAA << endl;\n\tcout << endl << \"Array content after ptr manipulation\" << endl;\n\tcout << X[1] << ' ' << X[2] << ' ' << X[3] << ' ' << xPtr << \" : \" << *xPtr << endl;\n\n\n\tGenerate a concise summary report explaining the result of each of these pointer actions when inserted in place of AAA above.\n\tThe report must identify if any array values were changed and, if the pointer moved, where and when it moved.\n\n\t*xPtr++\n\t(*xPtr)++\n\t*(xPtr)++\n\t*(xPtr++)\n\t*(++xPtr)\n\t*++xPtr\n\t(*++)xPtr\n\t++*xPtr\n\t++ (*xPtr)\n\t(++*)xPtr\n\t\n*/\n\n\n#include <iostream>"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 2\\CIS-200-LAB2-DemetriusJohnson\\Q2_CIS-200-LAB2-DemetriusJohnson.cpp",
        "snippet": "/*  *Author: Demetrius Johnson\n\t*Creation Date: 20 Sept. 2020\n\t*Modification Date: 23 Sept. 2020\n\t*Purpose: Learn how pointer and arrays work and how to take advantage of offsetting them\n\n\tQuestion 2:\n\n\tCreate an array of 100 integers, randomly generated to be in the range of -50 to +72.  \n\t1.\tUsing standard array notation, print all values in the array on one line, separated by a space\n\t2.\tUsing array offset notation, print all values in the arrayfrom last index to first, on one line, each separated by a space\n\t3.\tUsing pointer notation, print all negative values on one line, separated by a space\n\t4.\tUsing pointer offset notation, print all positive values on one line, separated by a space\n\n\tReminder:\n\tarray notation\t\tmyArray[ x ];\n\tarray offset notation\t*(myArray + x);\n\tpointer notation\t* integerArrayPtr;\n\tpointer offset notation\t*(integerArrayPtr + x);\n\n\t\n*/\n\n\n#include <iostream>\n#include <ctime>\t\t //need this library to use inside of srand function to generate random numbers based on the time..a better way to get random numbers\n#include <cstdlib>\t\t//need this library for random number function\n\nusing namespace std;\n\nint main()\n{\n\tsrand(time(NULL)); //set seed based on time so the algorithm for the psuedorandom numbers never calculates same values based on same seed upon program execution\n\n\tint arrayOneHunRanNum[100];\n\tint randomNum = 0;\n\tint integerCounter;\n\tint* integerArrayPtr = arrayOneHunRanNum;"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 2\\CIS-200-LAB2-DemetriusJohnson\\Q3_CIS-200-LAB2-DemetriusJohnson.cpp",
        "snippet": "/*  *Author: Demetrius Johnson\n\t*Creation Date: 20 Sept. 2020\n\t*Modification Date: 20 Sept. 2020\n\t*Purpose: *****\n\n\tQuestion 3:\n\n\tStarting with the shortest possible C++ program, \n\thave it display to the console the name of the executable \n\tthat is running and how many arguments it has.\n\n\t\n*/\n\n \n//NOTE: by defualt, the main function has defualt member functions that includes:\n// 1) the number of arguments, and \n// 2)a pointer to an array of character strings that contain the arguments, one per string. The value argv[argc] is a null pointer.\n\n#include <iostream>\nusing namespace std;\n\t\t\t\t\t\t\t\t\t//argc is the number of arguments the program has\nint main(int argc, char* argv[]) // argv[0] is the name of the program (string) , After that till argv[argc-1] every element (strings) is command-line arguments.\n{\n\tcout << \"Name of executbale running...(argv[0]):\\n\\n\" << \"...\\n\\n\" << argv[0] << endl << \"...\" << endl << endl;  //This will give you the exe name\n\tcout << \"Number of arguments passed by user (argc) (including default .EXE filename argument): \" << argc << endl << endl;\n\tcout << endl << \"Total arguments is \" << argc << \"; only the defualt .EXE user filename parameter is used in this program. Thank you(:. \\nProgram will Exit...\\n\\n\";\n}"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "labs\\CIS 200 LAB 3\\CIS-200-LAB3-DemetriusJohnson",
    "code_files": [
      "labs\\CIS 200 LAB 3\\CIS-200-LAB3-DemetriusJohnson\\CIS-200-DemetriusJohnson_Lab3Q2_MAIN.cpp",
      "labs\\CIS 200 LAB 3\\CIS-200-LAB3-DemetriusJohnson\\CIS-200-LAB3-DemetriusJohnson_Q1.cpp",
      "labs\\CIS 200 LAB 3\\CIS-200-LAB3-DemetriusJohnson\\ColorClass.cpp",
      "labs\\CIS 200 LAB 3\\CIS-200-LAB3-DemetriusJohnson\\HeightClass.cpp",
      "labs\\CIS 200 LAB 3\\CIS-200-LAB3-DemetriusJohnson\\LengthWidthClass.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 3\\CIS-200-LAB3-DemetriusJohnson\\CIS-200-DemetriusJohnson_Lab3Q2_MAIN.cpp",
        "snippet": "/*\n\t*Author: Demetrius Johnson\n\t*Creation Date: 29 Sept. 2020\n\t*Modification Date: 7 Oct. 2020\n\t*Purpose: Main function for testing and using inhertiance using 3 classes\n*/\n\n\n#include <iostream>\n#include <string>\n#include \"HeightClass.h\"\n\nusing namespace std;\n\nvoid testFunction(HeightClass HC);\n\n\nint main(){\n\n\tColorClass C1;\n\tColorClass C2(C1);\n\tColorClass C3(\"Orange\");\n\t//ColorClass C4;\n\t//C4 = C3;\n\n\tLengthWidthClass LW1;\n\tLengthWidthClass LW2(LW1);\n\t//LengthWidthClass LW3 = LW2;\n\tLengthWidthClass LW4(9, 10);\n\t//cout << LW1.length << LW2.length << LW3.length << LW4.length;\n\n\tHeightClass HC1;\n\t//HeightClass HC2;\n\tHeightClass HC3(HC1);\n\tHeightClass HC4(232);\n\n\n\tHeightClass thing1;\n\tHeightClass thing2;"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 3\\CIS-200-LAB3-DemetriusJohnson\\CIS-200-LAB3-DemetriusJohnson_Q1.cpp",
        "snippet": "/*\n    *Author: Demetrius Johnson\n    *Creation Date: 29 Sept. 2020\n    *Modification Date: 7 Oct. 2020\n    *Purpose: Practice using the VIS STUD debugger\n*/\n\n// CIS-200-LAB3-DemetriusJohnson.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Data\n{\npublic:\n    Data()\n    {\n        _values.push_back(1);\n        _values.push_back(2);\n    }\n    int getSum()\n    {\n        int total = -1;\n        for (vector<int>::iterator itr = _values.begin(), end = _values.end(); itr != end; ++itr)\n        {\n            total += *itr;\n        }\n        return total;\n    }\n    int getCount() { return _values.size(); }\nprivate:\n    vector<int> _values;\n};\n\ndouble compute_average(int sum, int count)\n{\n    return sum / (double)count;\n}"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 3\\CIS-200-LAB3-DemetriusJohnson\\ColorClass.cpp",
        "snippet": "/*\n\t*Author: Demetrius Johnson\n\t*Creation Date: 29 Sept. 2020\n\t*Modification Date: 7 Oct. 2020\n\t*Purpose: Base class\n*/\n\n\n/*\n1st class: has one private attribute, color, which is a string, and another which is a pointer to an int. One constructor, \nwith a string parameter with default value Purple. The constructor will create a new int and assign it to the pointer variable, \nthen give it value    -13. The constructor displays message Class created with color ccc, replacing ccc with the color variable. \nDestructor, which displays message Class destroyed with color ccc and number nnn, \nreplacing ccc with the color variable and nnn with the value the pointer points to, and deleting the pointer.  \nAlso create appropriate get and set methods for color.  Youll have to write a copy constructor for the class as well as overloading operator=.  \nHave the copy constructor increase the value the new pointer points to by 1 (only the copy will increase, not the original) and display message Class created with color ccc and number nnn, \nreplacing ccc with the color variable and nnn with the value the pointer points to.\n\n*/\n#include <iostream>\n#include <string>\n#include \"ColorClass.h\"\nusing namespace std;\n\n//return a reference in the overload function so that the left-side values can be referenced again to use in a function with multiple = operators.\nColorClass& ColorClass::operator=(const ColorClass &OriginalObject) {//use by-reference so that a new object is not unnecessarily created and to avoid pointer memory errors\n\n\tcolor = OriginalObject.color; //set the colors equal\n\t*intPtr = *OriginalObject.intPtr; //set new ptr location of new, copied object to store the same value as original object.\n\t//intPtr will be left alone in this overloaded function because we do not want the memory location of this pointer to equal the pointer of the right side object.\n\treturn *this;\n} //define overload function for =operator since the object contains a pointer, to ensure memory locations don't overlap\n\n\nColorClass::ColorClass(const ColorClass &OriginalObject) { //copy constructor\n\n\tcolor = OriginalObject.color; //set the colors equal\n\tintPtr = new int; //allocate new memory to the pointer variable\n\t*intPtr = *(OriginalObject.intPtr) + 1; //set new ptr location of new, copied object to store the same value as original object and add 1.\n\tcout << \"\\n--ColorClass created with color <\" << color << \"> and value \" << *intPtr << \" with intPtr located at \" << intPtr << \"\\n\\n\";"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 3\\CIS-200-LAB3-DemetriusJohnson\\HeightClass.cpp",
        "snippet": "/*\n\t*Author: Demetrius Johnson\n\t*Creation Date: 29 Sept. 2020\n\t*Modification Date: 7 Oct. 2020\n\t*Purpose: level 3 class to use for inheritance\n*/\n\n\n/*\n\n\n3rd class: \n\ninherits public from 2nd class. It has private int attribute of height. \nOne constructor, with an int parameter with default value of 2.  \nThe constructor displays message Class created with color ccc, \nlength lll, width www, and height hhh, replacing ccc, lll, www, \nand hhh with the appropriate variable values. Destructor, \nwhich displays message Class destroyed with color ccc, length lll, \nwidth www, and height hhh, replacing ccc, lll, www, and hhh with the appropriate variable values. \nCreate appropriate get and set methods for the attribute. \nCreate a PrintMe method that prints ccc object with lll x www x hhh (volume = vvv) replacing ccc, lll, www, \nand hhh with the appropriate variable values and vvv with length multiplied by width multiplied by height.\n\n*/\n\n#include <iostream>\n#include <string>\n#include \"HeightClass.h\"\nusing namespace std;\n\n\nHeightClass::HeightClass(int h) {\n\n\theight = h;\n\tcout << \"--HeightClass created with color <\" << color << \">, length <\" << length << \"> width <\" << width << \">, and height <\" << height << \">.\\n\\n\";\n\t\n} // constructor initializer\n\nint HeightClass::getHeight() { return height; }"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 3\\CIS-200-LAB3-DemetriusJohnson\\LengthWidthClass.cpp",
        "snippet": "/*\n\t*Author: Demetrius Johnson\n\t*Creation Date: 29 Sept. 2020\n\t*Modification Date: 7 Oct. 2020\n\t*Purpose: level 3 class to use for inheritance\n*/\n\n/*\n\n2nd class: \ninherits public from 1st class.  \nIt has private attributes of length and width, both int. One constructor, with int parameters with default values of 3 and 5. \nThe constructor displays message Class created with color ccc, length lll, and width www, replacing ccc, lll, \nand www with the appropriate variable values. Destructor, which displays message Class destroyed with color ccc, length lll, and width www, \nreplacing ccc, lll, and www with the appropriate variable values.  \nCreate appropriate get and set methods for the two attributes. \nCreate a PrintMe method that prints ccc object with lll x www (area = aaa) replacing ccc, lll, \nand www with the appropriate variable values and aaa with length multiplied by width.\n\n*/\n\n#include <iostream>\n#include <string>\n#include \"ColorClass.h\"\n#include \"LengthWidthClass.h\"\nusing namespace std;\n\n\nLengthWidthClass::LengthWidthClass(int l, int w) {\n\n\tlength = l;\n\twidth = w;\n\n\tcout << \"--LengthWidthClass created with color <\" << color << \">, length <\" << length << \"> and width <\" << width << \">.\\n\\n\";\n\n\n}// constructor initializer and useable as a default constructor\n\nLengthWidthClass::LengthWidthClass(const LengthWidthClass& OriginalObject) : ColorClass(OriginalObject) { //copy constructor specifying that the base-class constructor to be called should be the base-class copy constructor as well"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "labs\\CIS 200 LAB 4\\DEMETRIUS JOHNSON --LAB 4 CIS 200",
    "code_files": [
      "labs\\CIS 200 LAB 4\\DEMETRIUS JOHNSON --LAB 4 CIS 200\\hello.cpp",
      "labs\\CIS 200 LAB 4\\DEMETRIUS JOHNSON --LAB 4 CIS 200\\Question1_DEMETRIUS JOHNSON --LAB 4 CIS 200.cpp",
      "labs\\CIS 200 LAB 4\\DEMETRIUS JOHNSON --LAB 4 CIS 200\\Question2_DEMETRIUS JOHNSON --LAB 4 CIS 200.cpp",
      "labs\\CIS 200 LAB 4\\DEMETRIUS JOHNSON --LAB 4 CIS 200\\Vector.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 4\\DEMETRIUS JOHNSON --LAB 4 CIS 200\\hello.cpp",
        "snippet": "//Demetrius Johnson hello.cpp  13 Oct 2020\n//basic cout << \"hello world\" program for LAB 5 CIS 200 ASSIGNMENT\n\n\n#include <iostream>\n\nusing namespace std;\n\n\nint main() {\n\n\tcout << \"\\n\\nhello world\\n\\n\";\n\n\treturn 0;\n}"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 4\\DEMETRIUS JOHNSON --LAB 4 CIS 200\\Question1_DEMETRIUS JOHNSON --LAB 4 CIS 200.cpp",
        "snippet": "//\n\n/*\n\n/*\n\t*Author: Demetrius Johnson\n\t*Creation Date: 12 Oct 2020\n\t*Modification Date: 12 Oct 2020\n\t*Purpose: override Vector function and practice writing a copy constructor using deep copy\n\n*/\n\n//Write methods defined in header fileand use the following stub Main to test header file\n\n#include \"Vector.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\n\t// REQUIRED CODE\n\n\tVector a, b(3), c(3);\n\n\ta.print(); \t// outputs []\n\tb.print(); \t// outputs [ 0 0 0 ]\n\tc.set(0, -1);        // output error message\n\tc.set(1, 0);\n\tc.set(2, 1);\n\tc.set(3, 2);\n\tc.set(4, 3);          // outputs error message \n\tc.print(); \t// outputs [ 1 2 3 ]\n\n\tVector d(c);\n\td.print(); \t // outputs [ 1 2 3 ]\n\n\td.set(0, 1);\n\td.print();\t// outputs [ 1 0 3 ]"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 4\\DEMETRIUS JOHNSON --LAB 4 CIS 200\\Question2_DEMETRIUS JOHNSON --LAB 4 CIS 200.cpp",
        "snippet": "/*\n////Program 2.\n\n\n\t*Author: Demetrius Johnson\n\t*Creation Date: 12 Oct 2020\n\t*Modification Date: 12 Oct 2020\n\t*Purpose: write a recursive function to calculate the the sqr root of a number using series approximation\n\n\n\nWrite a function to calculate the square root of a float number with the following interface :\n\n\tdouble squareRoot(double x)\n{\n\t// assert that x is not negative\n\t...\n\n}\n\nThe function should return an approximation to sqrt(x) using series approximation.\nLet x0 = x / 2.  Then xn + 1 = (xn + x / xn) / 2.  Keep computing terms until the difference between xn and xn + 1 is less than 0.0001.\nIn addition, if the input variable x is negative, your function should stop the execution via the assert() function, which is a built - in C++ function.\nYou need to add a function call to assert() at the beginning of the above function to guarantee the precondition of this function is correct.\n\nIn your main function, design it to request the user to enter as many numbers as they want(continue to enter values ? \"y\" or \"n\").\nTest cases must include values 3, 0, and -3, as well as others you think are appropriate.\n\nThe specifics of the assert message shown depends on the specific implementation in the compiler, \nbut it should include : the <bool exp> whose assertion failed, the name of the source file, \nand the line number where it happened.A usual expression format is :\n\nAssertion failed : <bool exp> file filename, line line number\n\n#include <cassert>\n\nvoid print_number(int myInt) {\n\tassert(myInt > 5);\n\n\tThis sample snippet will abort when myInt has value of 5 or less because myInt > 5 evaluates to false."
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 4\\DEMETRIUS JOHNSON --LAB 4 CIS 200\\Vector.cpp",
        "snippet": "//Header File Definition  override C++ vector definition\n\n#include \"Vector.h\"\n\n    Vector::Vector() {\n    \n        size = 0;\n        entries = new int[size];\n    \n    \n    }         \t\t// default constructor\n\n\n    Vector::Vector(int s) {\n\n        size = s;\n        entries = new int[size];\n        for (int count = (size-1); count >= 0; count--) { //use for loop in order to set all elements equal to 0\n\n            entries[count] = 0;\n        }\n    \n    \n    }\t\t// makes size = s, \n                                   //allocates s space\n               //   e.g. entries = new int[size], \n                                   // makes all entries 0\n    Vector::Vector(const Vector &other) {\n    \n        size = other.size;\n        entries = new int[size];\n\n        for (int count = (size-1); count >= 0; count--) { //use for loop in order to copy all array elements\n\n            entries[count] = other.entries[count];\n        }\n    \n    }\n    // copy constructor\n    // makes a deep copy"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "labs\\CIS 200 LAB 5",
    "code_files": [
      "labs\\CIS 200 LAB 5\\hello.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 5\\hello.cpp",
        "snippet": "//Demetrius Johnson hello.cpp  13 Oct 2020\n//basic cout << \"hello world\" program for LAB 5 CIS 200 ASSIGNMENT\n\n\n#include <iostream>\n\nusing namespace std;\n\n\nint main() {\n\n\tcout << \"\\n\\nhello world\\n\\n\";\n\n\treturn 0;\n}"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "labs\\CIS 200 LAB 6\\DemetriusJohnson-Lab6_CIS-200",
    "code_files": [
      "labs\\CIS 200 LAB 6\\DemetriusJohnson-Lab6_CIS-200\\Lab6_CIS-200_Program1_MAIN.cpp",
      "labs\\CIS 200 LAB 6\\DemetriusJohnson-Lab6_CIS-200\\Lab6_CIS-200_Program2_MAIN.cpp",
      "labs\\CIS 200 LAB 6\\DemetriusJohnson-Lab6_CIS-200\\P1functions.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 6\\DemetriusJohnson-Lab6_CIS-200\\Lab6_CIS-200_Program1_MAIN.cpp",
        "snippet": "// DemetriusJohnson-Lab6_CIS-200.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n/*\n\n\t*Author: Demetrius Johnson\n\t*Creation Date: 20 Oct 2020\n\t*Modification Date: 20 Oct 2020\n\t*Purpose:  *******\n\n\nProgram 1\n\nGiven that arrayIntValues [MAX_ROWS][MAX_COLUMNS] is a 2 dimensional array of positive integers, \nwrite a C++ function howManyEven to find the total number of even elements in the array. \nIt should have input parameter array arrayIntValues. The function should return an integer. \nAlso create a C++ function called printArray, with the input parameter array arrayIntValues, \nto print out the elements in the array (be sure to have row and column labels and proper formatting (i.e. column values line up). \nMain must be in one source file and all other functions in a second source file.\nThe constants MAX_ROWS and MAX_COLUMNS must be accessed globally by defining the following global variables:\n\nconst int MAX_ROWS = 3;\t\t\tor\t\t#define MAX_ROWS 3\nconst int MAX_COLUMNS = 2;\t\t\tor\t\t#define MAX_COLUMNS 2\n\nThe array arrayIntValues is initialized by the following statement within main():\nint arrayIntValues [MAX_ROWS][ MAX_COLUMNS] =  { {3 , 2}, {4, 5}, {2, 2} };\n\nPrint out the array and the count of positive even numbers (label appropriately) in function printArray.\n\nUser enters a new set of values into the array (must do it at least once) as many times as\nthey wish and runs printArray against the new array values each time. Be sure to validate input is positive integers.\n\nValidate user input (y or n) when asking if the user wants to enter a new set of values.\n\n\n\n//side note: remember that the each ROW CONTAINS its own COLUMNS in a 2D array; for example (columns DO NOT contain the rows; therefore they are IN or owned by rows):\n\t\t\t\t\t\t\t\t\t\t\t\tROW1\tROW2\tROW3\nint arrayIntValues[MAX_ROWS][MAX_COLUMNS] = { {3 , 2}, {4, 5}, {2, 2} }; notice how each row has (contains in itself) multiple columns; but each column is only apart of 1 row.\n*/"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 6\\DemetriusJohnson-Lab6_CIS-200\\Lab6_CIS-200_Program2_MAIN.cpp",
        "snippet": "// DemetriusJohnson-Lab6_CIS-200.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n/*\n\n\t*Author: Demetrius Johnson\n\t*Creation Date: 20 Oct 2020\n\t*Modification Date: 20 Oct 2020\n\t*Purpose:  *******\n\n\nProgram 2\n\nGiven storeMonthlySales[NUM_STORES][NUM_MONTHS][NUM_DEPTS] is a three-dimensional array of floating point values.\nWrite a C++ function, printMonthlySales, to calculate and print the total value of sales during a specific month by \neach department and in each store plus totals by store and department and overall sales.\nThe return type of the function is void and the function must have 2 input parameters: Sales array and the month the user specified (edit for correct month values!).  \nThe constants NUM_STORES, NUM_MONTHS, and NUM_DEPTS must be accessed globally by defining the following global variables:\n\n#define NUM_DEPTS  2    \tor const in NUM_DEPTS = 2;\n#define NUM_STORES 2\t\tor const int NUM_STORES = 2;\n#define NUM_MONTHS 12\tor const int NUM_MONTHS = 12;\n\nThe array Sales is initialized by the following statement within main():\nfloat storeMonthlySales[NUM_STORES][NUM_MONTHS][NUM_DEPTS] =\n{ \t 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1, 2.2,\n             2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3.0, 3.1, 3.2,\n             3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4.0, 4.1, 4.2,\n             2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3.0, 3.1, 3.2\n};\n\nOutput:                                 Sales for month of value (where value represents January, March, etc.)\n                                                                 Dept #                      Dept #                           Store Total\n                                               Store #         value                        value                             row value sum\n                                               Store #         value                        value                             row value sum\n                                               Dept Total   col value sum                       col value sum                 total overall sales\n\nUser enters a new month as many times as they wish and run printMonthlySales against the new month value.\nValidate user input (y or n) when asking if the user wants to enter a new set of values."
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 6\\DemetriusJohnson-Lab6_CIS-200\\P1functions.cpp",
        "snippet": "#include \"P1functions.h\"\n\n\nvoid openingMenu(void) {\n\t\n\tcout << \"-------------------------------WELCOME-----------------------------------\\n\\n\";\n\tcout << \"This program reads the number of Positive values that a user enters for a 2D array.\\n\";\n\tcout << \"Total number of input values accepted from user is 3x2 = 6 values; values may only be POSITIVE.\\n\\n\";\n\tcout << \"The array is of size 3x2(3 rows, 2 columns in each row),\\nand input gathers all columns of a row before moving to next row's input.\\n\\n\";\n\tcout << \"In addition, the program will output a display table of the current user 2D array.\\n\\n\";\n\tcout << \"As an example, the default 2D array in this program is:\\n\\nint arrayIntValues[MAX_ROWS][MAX_COLUMNS] = { {3 , 2}, {4, 5}, {2, 2} }\\n\";\n\tcout << \"The total number of positive even numbers in the array is:\\n\\n\";\n\n\n}\n\nint numPosAndEven_InArray(int arrayIntValues[ROWS][COLUMNS]) {\n\n\tint evenNumCounter = 0, rCount = 0, cCount = 0;\n\n\twhile (rCount < ROWS) { // use this loop to iterate through each row of the 2D array\n\t\t\n\t\tfor (cCount = 0; cCount < COLUMNS; cCount++) { //use this loop to iterate through each column of each row of the 2D array\n\t\t\tif ((arrayIntValues[rCount][cCount] % 2) == 0)\n\t\t\t\tif (arrayIntValues[rCount][cCount] != 0)\n\t\t\t\t\tevenNumCounter++;\n\t\t}\n\t\trCount++;\n\t}\n\n\treturn evenNumCounter;\n}\n\n\nvoid printArray(int arrayIntValues[ROWS][COLUMNS]) {\n\tint rCount = 0;\n\tint cCount = 0;"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "labs\\CIS 200 LAB 7\\DemetriusJohnson-Lab7_CIS-200",
    "code_files": [
      "labs\\CIS 200 LAB 7\\DemetriusJohnson-Lab7_CIS-200\\DemetriusJohnson-Lab7_CIS-200_Program1.cpp",
      "labs\\CIS 200 LAB 7\\DemetriusJohnson-Lab7_CIS-200\\DemetriusJohnson-Lab7_CIS-200_Program2.cpp",
      "labs\\CIS 200 LAB 7\\DemetriusJohnson-Lab7_CIS-200\\Lab7P1functions.cpp",
      "labs\\CIS 200 LAB 7\\DemetriusJohnson-Lab7_CIS-200\\Lab7P2functions.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 7\\DemetriusJohnson-Lab7_CIS-200\\DemetriusJohnson-Lab7_CIS-200_Program1.cpp",
        "snippet": "// DemetriusJohnson-Lab7_CIS-200.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n/*\n\n\n*\t*Author: Demetrius Johnson\n\t*Creation Date: 26 Oct 2020\n\t*Modification Date: 26 Oct 2020\n\t*Purpose:  *******\n \n\nProgram 1:\n\nYou are to create a recursive function to perform a linear search through an array. -->(search every element in the array until a matching value (key) is found)\n\nHow Program Works\n\no\tProgram has array size of 5000\no\tLoad values into the array, equal to its index value. Index 5 has value 5, index 123 has value 123.\no\tPass array, key, and size to the recursive function:\no\tint recursiveLinearSearch(int array[],int key, const int size, bool & methodStatus)\no\tUser enters key to search for, recursive function calls itself until the key is found (methodStatus is true), \nprint out the key and number of function calls when control is returned to the main\no\tHandle situation of key not found (return number of function calls AND methodStatus of false)  print not found message and number of calls in the main\no\tFunction returns a count of how many recursive calls were made\no\tValue returned is the number of calls made to that point, that is, \nwhen item is found the value returned is 1 with preceding functions adding 1 to the return value until the actual number of recursive function calls are counted).\no\n\nDetermine smallest key value that causes stack-overflow to occur, even if you need to make array larger than 5000.\n\nTest cases need to include (not limited to) biggest possible key value, not found message, and a stack overflow condition.\n\n\n\n\n\n\n*/"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 7\\DemetriusJohnson-Lab7_CIS-200\\DemetriusJohnson-Lab7_CIS-200_Program2.cpp",
        "snippet": "// DemetriusJohnson-Lab7_CIS-200.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n/*\n\n\n*\t*Author: Demetrius Johnson\n\t*Creation Date: 26 Oct 2020\n\t*Modification Date: 26 Oct 2020\n\t*Purpose:  *******\n\n\nProgram 2:\n\nYou are to create a recursive function to perform a factorial calculation.\n\no\tint factorial(const int value)\no\treturn -1 if any negative number passed into the function\no\tCalculate the factorial of the number entered by the user\n\nDetermine value at which stack overflow occurs.\n\n\n*/\n\n#include <iostream>\n#include <string>\n#include \"Lab7P2functions.h\"\n\nusing namespace std;\n\n\n\nint main()\n{\n\tint userInt = 0;\n\tint FactorialCalculation = 0;\n\tchar userChoice = 'y';\n\n\tmain_Menu();"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 7\\DemetriusJohnson-Lab7_CIS-200\\Lab7P1functions.cpp",
        "snippet": "/*\n* Author: Demetrius Johnson\n* Creation Date : 26 Oct 2020\n* Modification Date : 26 Oct 2020\n* Purpose : .cpp file for program 1 (lab 7) functions\n*/\n\n#include \"Lab7P1functions.h\"\n\n\n\nvoid main_Menu(const int & arraySize) {\n\n\tcout << \"---------------------------------------------WELCOME-------------------------------------------\\n\";\n\tcout << \"This Program will perform a linear search through an array of size \" << arraySize<< \" for a given key (integer) provided by the user.\\n\";\n\tcout << \"\\nEnter an integer value to see if your key value is contained in one of the elements of the array: \";\n\t\n}\n\n\n\nint recursiveLinearSearch(int int_Array[], int userKey, const int array_Size, bool& methodStatus) {\n\n\tint elementCounter = 0;\n\n\tif (int_Array[elementCounter] == userKey) { //Best Case scenario; check to see if first element contains userKey\n\n\t\tmethodStatus = true;\n\n\t\treturn(0); //number of recursive calls is 0 since only MAIN called this first function and the key was found in the first element of the array\n\t}\n\n\twhile (int_Array[elementCounter] == NULL) {// set counter to next element position to be compared to userKey\n\t\telementCounter++;\n\t}\n\n\tif (elementCounter < array_Size && int_Array[elementCounter] == userKey) { //Base Case; check to see if element contains userKey; first statement in the if statement is to make sure we do not go out of scope of the array size\n\n\t\tmethodStatus = true;"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 7\\DemetriusJohnson-Lab7_CIS-200\\Lab7P2functions.cpp",
        "snippet": "/*\n* Author: Demetrius Johnson\n* Creation Date : 26 Oct 2020\n* Modification Date : 26 Oct 2020\n* Purpose : .cpp file for program 2 (lab 7) functions\n*/\n\n#include \"Lab7P2functions.h\"\n\n\n\nvoid main_Menu() {\n\n\tcout << \"---------------------------------------------WELCOME-------------------------------------------\\n\";\n\tcout << \"This Program will calculate the value of an integer factorial provided by the user (userIntger! = ....)\\n\";\n\tcout << \"Enter an integer value to be calculated (warning, too large a value will cause stack overflow): \";\n\t\n}\n\nint IntFactorialCalc(const int userValue) {\n\n\tint userValCopy = userValue;\n\n\tif (userValue < 0) //case: invalid user data\n\t\treturn -1;\n\n\n\tif (userValue == 0) //Base Case\n\t\treturn 1; //0! is equal to 1.\n\n\telse { //recursive Case\n\t\t\n\t\tuserValCopy--; //userValCopy = userVal - 1 --> factorial n*(n-1)....etc.\n\n\t\treturn (userValue * IntFactorialCalc(userValCopy)); //n* (n-1)...etc.\n\t}\n\n\treturn 0; //protection return in case above cases are deffective\n}"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "labs\\CIS 200 LAB 8\\LAB 8 CIS 200",
    "code_files": [
      "labs\\CIS 200 LAB 8\\LAB 8 CIS 200\\creditFileRandW.cpp",
      "labs\\CIS 200 LAB 8\\LAB 8 CIS 200\\L8functions.cpp",
      "labs\\CIS 200 LAB 8\\LAB 8 CIS 200\\LAB 8 CIS 200.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 8\\LAB 8 CIS 200\\creditFileRandW.cpp",
        "snippet": "#include \"creditFileRandW.h\"\n\n\nvoid creditFileRandW::openCreditFile_read(void) {\n\tcreditFile_read.open(\"credit.dat\", ios::in | ios::binary);\n\tif (!creditFile_read.is_open()) {\n\t\tcout << \"\\nunable to open 'credit.dat' file.\\n\";\n\t}\n\telse { cout << \"\\n~Random Access File 'credit.dat' opened successfully~\\n\"; }\n\n}\n\nvoid creditFileRandW::openCreditFile_write(void) {\n\n\tcreditFile_write.open(\"credit.dat\", ios::out | ios::binary);  //NOTE:if no file exists, you may not be able to open in binary or using any other addtional modes \n\t\t\t\t\t\t\t\t\t\t\t\t //must open the uncreated file first using only the default constructor (no additional paramters other than ios::out and the file name),\n\t\t\t\t\t\t\t\t\t\t\t\t // then close it and reopen (in binary for example) the newly created file. (idk if this is because of a c++ error but it worked as long as i didnt set the int mode (the last parameter)\n\tif (!creditFile_write.is_open()) {\n\t\tcout << \"\\nunable to open 'credit.dat' file.\\n\";\n\t}\n\telse { cout << \"\\n~Random Access File 'credit.dat' opened successfully~\\n\"; }\n\n}\nvoid creditFileRandW::clearAndClose_creditFile_read(void) {\n\n\tcreditFile_read.clear();\n\tcreditFile_read.close();\n}\nvoid creditFileRandW::clearAndClose_creditFile_write(void) {\n\n\tcreditFile_write.clear();\n\tcreditFile_write.close();\n}"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 8\\LAB 8 CIS 200\\L8functions.cpp",
        "snippet": "// DemetriusJohnson-Lab8_CIS-200.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n\n/*\n\nGiven:\nstruct clientData {\n   int accountNumber;\n   char lastName[ 16 ];\t\t// c-style string, not string\n   char firstName[ 11 ];\n   float balance;\n};\n\nCreate a random access file of 101 records named credit.dat using these code segments in a function to initialize the file to empty records:\nofstream creditFile( \"credit.dat\", ios::out);\nclientData blankClient = { 0, \"\", \"\", 0.0 };\n\nfor ( int i = 0; i <= 100; i++ )\n   creditFile.write( reinterpret_cast<const char *>( &blankClient ), sizeof( clientData ) );\ncreditFile.close();\n<ostream> member function write - outputs a fixed number of bytes beginning at a specific location in memory to the specific stream (file).\n\nThe write function expects the first argument of type const char *, hence the use of\nreinterpret_cast <const char *> to convert the address of blankClient to const char *.\nThe second argument of write is an integer specifying the number of bytes to be written. Thus the use of sizeof( clientData ).\nSince size will never change it must be declared as a constant variable; sizeof must only appear once in your program: for the constant declaration.\n\nThe first entry in the file will be skipped so that record 1 is at position 1 and not position 0.\n\nWrite data into the file [minimum of 15 records, not in 15 consecutive account numbers] getting all data from the user.\nTruncate user input if it is too long for the data field.\nRead data from the file. Loop, asking user for an account number to find (range 1 to 100, 0 to end input. (error message if not a valid account number and try again).\nPrint out all data fields for this account.\nUpdate an account. Loop, asking user for an account number to update (error message if not a valid account number and try again) or 0 to quit (do several updates).\nUpdate firstname, lastname, or balance (but NOT accountNumber).\nPrint out all records that do not have accountNumber of 0, formatting output into columns (label columns).\n\n\n*/"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\labs\\CIS 200 LAB 8\\LAB 8 CIS 200\\LAB 8 CIS 200.cpp",
        "snippet": "// DemetriusJohnson-Lab8_CIS-200.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n\n/*\n\nGiven:\nstruct clientData {\n   int accountNumber;\n   char lastName[ 16 ];\t\t// c-style string, not string\n   char firstName[ 11 ];\n   float balance;\n};\n\nCreate a random access file of 101 records named credit.dat using these code segments in a function to initialize the file to empty records:\nofstream creditFile( \"credit.dat\", ios::out);\nclientData blankClient = { 0, \"\", \"\", 0.0 };\n\nfor ( int i = 0; i <= 100; i++ )\n   creditFile.write( reinterpret_cast<const char *>( &blankClient ), sizeof( clientData ) );\ncreditFile.close();\n<ostream> member function write - outputs a fixed number of bytes beginning at a specific location in memory to the specific stream (file).\n\nThe write function expects the first argument of type const char *, hence the use of\nreinterpret_cast <const char *> to convert the address of blankClient to const char *.\nThe second argument of write is an integer specifying the number of bytes to be written. Thus the use of sizeof( clientData ).\nSince size will never change it must be declared as a constant variable; sizeof must only appear once in your program: for the constant declaration.\n\nThe first entry in the file will be skipped so that record 1 is at position 1 and not position 0.\n\nWrite data into the file [minimum of 15 records, not in 15 consecutive account numbers] getting all data from the user.\nTruncate user input if it is too long for the data field.\nRead data from the file. Loop, asking user for an account number to find (range 1 to 100, 0 to end input. (error message if not a valid account number and try again).\nPrint out all data fields for this account.\nUpdate an account. Loop, asking user for an account number to update (error message if not a valid account number and try again) or 0 to quit (do several updates).\nUpdate firstname, lastname, or balance (but NOT accountNumber).\nPrint out all records that do not have accountNumber of 0, formatting output into columns (label columns).\n\n\n*/"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "projects\\AlgorithmAnalysisTestProject\\TestingAndTimeComplexityAlgorithmAnalysis_DemetriusJohnson",
    "code_files": [
      "projects\\AlgorithmAnalysisTestProject\\TestingAndTimeComplexityAlgorithmAnalysis_DemetriusJohnson\\AnotherEuclideanAlgTest.cpp",
      "projects\\AlgorithmAnalysisTestProject\\TestingAndTimeComplexityAlgorithmAnalysis_DemetriusJohnson\\log_2(X)_Algorithm.cpp",
      "projects\\AlgorithmAnalysisTestProject\\TestingAndTimeComplexityAlgorithmAnalysis_DemetriusJohnson\\mainTest _EuclideanAlgorithm.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\projects\\AlgorithmAnalysisTestProject\\TestingAndTimeComplexityAlgorithmAnalysis_DemetriusJohnson\\AnotherEuclideanAlgTest.cpp",
        "snippet": "// TestingAndTimeComplexityAlgorithmAnalysis_DemetriusJohnson.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n\nusing namespace std;\n\nint function_Euclidean(int a, int b)\n{\n\tint holder = 0;\n\n\tif (a < b) {\n\n\t\tholder = a;\n\t\ta = b;\n\t\tb = holder;\n\t}\n\twhile (b != 0) {\n\t\n\t\tholder = a % b;\n\t\ta = b;\n\t\tb = holder;\n\t\n\t\n\t}\n\n\treturn a;\n}\n\n\nint main()\n{\n\tcout << endl << endl;\n\tcout << function_Euclidean(150, 128);\n\tcout << endl;\n\tcout << function_Euclidean(150, 129);\n\tcout << endl << endl;\n\t\n\n\treturn 0;"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\projects\\AlgorithmAnalysisTestProject\\TestingAndTimeComplexityAlgorithmAnalysis_DemetriusJohnson\\log_2(X)_Algorithm.cpp",
        "snippet": "// TestingAndTimeComplexityAlgorithmAnalysis_DemetriusJohnson.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n\nusing namespace std;\n\nvoid function(int n)\n{\n\tint j_counter = 0;\n\tint i_counter = 0;\n\tcout << \"\\nn = \" << n << endl;\n\tcout << \"i-j\\n\";\n\tfor (int i = n; i > 0; i/= 2) {\n\t\t\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\t//loop body\n\t\t\tcout << i << \"-\" << j;\n\t\t\t//cout << j;\n\t\t\tprintf(\"  j-loop-iteration\\n\");\n\t\t\tj_counter++;\n\t\t}\n\t\tif (i == 1)\n\t\t\tcout << \"total j-loops executed = \" << j_counter << endl;\n\t\ti_counter++;\n\t}\n\tcout << \"total i-loops executed = \" << i_counter << endl;\n\tcout << \"Total executions = \" << i_counter + j_counter;\n}\n\n\nint main()\n{\n\t\n\t\n\tfunction(1);\n\tprintf(\"\\n\\n\");\n\tfunction(2);\n\tprintf(\"\\n\\n\");\n\tfunction(3);"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\projects\\AlgorithmAnalysisTestProject\\TestingAndTimeComplexityAlgorithmAnalysis_DemetriusJohnson\\mainTest _EuclideanAlgorithm.cpp",
        "snippet": "// TestingAndTimeComplexityAlgorithmAnalysis_DemetriusJohnson.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n\nusing namespace std;\n\nvoid function(int n)\n{\n\tint j_counter = 0;\n\tcout << \"\\nn = \" << n << endl;\n\tcout << \"i-j\\n\";\n\tfor (int i = 0; i <= n - 1; i++) {\n\t\t\n\t\tfor (int j = (i + 1); j <= (n - 1); j++) {\n\t\t\t//loop body\n\t\t\tcout << i << \"-\" << j;\n\t\t\t//cout << j;\n\t\t\tprintf(\"  j-loop-iteration\\n\");\n\t\t\tj_counter++;\n\t\t}\n\t\tif(i == (n-1))\n\t\tcout << \"total j-loops executed = \" << j_counter;\n\t}\n}\n\n\nint main()\n{\n\t\n\t\n\tfunction(1);\n\tprintf(\"\\n\\n\");\n\tfunction(2);\n\tprintf(\"\\n\\n\");\n\tfunction(3);\n\tprintf(\"\\n\\n\");\n\tfunction(4);\n\tprintf(\"\\n\\n\");\n\tfunction(5);"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "projects\\CIS 200 SoloProject\\CIS-200-Project1-soloPRJ-DemetriusJohnson",
    "code_files": [
      "projects\\CIS 200 SoloProject\\CIS-200-Project1-soloPRJ-DemetriusJohnson\\CIS-200-Project1-soloPRJ_main.cpp",
      "projects\\CIS 200 SoloProject\\CIS-200-Project1-soloPRJ-DemetriusJohnson\\myString.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\projects\\CIS 200 SoloProject\\CIS-200-Project1-soloPRJ-DemetriusJohnson\\CIS-200-Project1-soloPRJ_main.cpp",
        "snippet": "// CIS-200-Project1-soloPRJ-DemetriusJohnson.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n/*\n* Author: Demetrius Johnson  --CIS200 UM-DEARBORN --PROF ROBERTMANN\n* Creation Date : 26 Oct 2020\n* Modification Date : 31 Oct 2020\n* Purpose : ***\n*/\n\n#include <iostream>\n#include \"myString.h\"\n\nusing namespace std;\n\nint main()\n{\n //TESTING//\n\n\tcout << \"///TEST 1: \\n\";\n\tmyString test1; //default constructor\n\tcout << \"test1 output should be nothing...couting test1:  ___no-output--nullstring \"<< test1.getString(); //defualt constructor --> is null so nothing will be output\n\n\tcout << \"\\n\\n\";\n\n\tcout << \"///TEST 2: \\n\";\n\tmyString test2(\"stringliteraltest\"); //test initializing with string literal.\n\tcout << test2.getString();//test initializing with string literal.\n\t\n\tcout << \"\\n\\n\";\n\n\tcout << \"///TEST 3: \\n\";\n\tstring stringtester = \"stringtester\";\n\tmyString test3(stringtester); //test initializing with std string\n\ttest3.printMyString_Screen(); //testing print string to screen function and testing initializing with std string\n\n\tcout << \"\\n\\n\";\n\n\tcout << \"///TEST 4: \\n\";\n\tmyString test4(\"hello\");"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\projects\\CIS 200 SoloProject\\CIS-200-Project1-soloPRJ-DemetriusJohnson\\myString.cpp",
        "snippet": "/*\n* Author: Demetrius Johnson  --CIS200 UM-DEARBORN --PROF ROBERTMANN\n* Creation Date : 26 Oct 2020\n* Modification Date : 31 Oct 2020\n* Purpose : ***\n*/\n\n\n\n#include \"myString.h\"\n\n\n//-------------RULE OF 3-----------------COPY CONSTRUCTOR, DESTRUCTOR, COPY ASSG OPERATOR-------THE BIG 3-----------------//\n\nmyString::~myString(){\n\n\tdelete[] dynamicArrayOfChar;\n\tcout << \"\\n\\t\\t~myString destructor has been called...array char[] deleted....destroying object~\\n\";\n\n}//destructor\nmyString::myString(const myString& myStringCopiedObject){\n\tif (myStringCopiedObject.myStringSize == 0) { //check to make sure that any object initialized with another object with an empty char array will simply cause function to act as defualt constructor\n\t\tthis->dynamicArrayOfChar[this->myStringSize] = nullchar;\n\t\treturn;\n\t}\n\telse { //else make the object have all the same members --> same size of char array with all the same elements\n\t\tthis->allocMemAndSetNewSize(myStringCopiedObject.myStringSize); // use allocFunction to set new size and to allocate new memory of the new size\n\t\tthis->setElementsEqual(myStringCopiedObject);\n\t}\n} //copy constructor\nmyString::myString(const string stdstring) {\n\n\tif (stdstring.size() == 0) { //if string is empty string, then just need to keep size to 0 and set the default (new char[1]) \"0\" element to nullchar\n\t\tthis->dynamicArrayOfChar[this->myStringSize] = nullchar;\n\t\treturn;\n\t}\n\n\telse {\n\t\tthis->allocMemAndSetNewSize(stdstring.size());//set new size and allocate memory of the new size"
      }
    ]
  },
  {
    "repo": "CIS-200_With_Robert_Mann",
    "folder": "projects\\CIS 200 TeamProject\\CIS_200_TEAM14_PRJ",
    "code_files": [
      "projects\\CIS 200 TeamProject\\CIS_200_TEAM14_PRJ\\CIS_200_TEAM14_PRJ_MAIN.cpp",
      "projects\\CIS 200 TeamProject\\CIS_200_TEAM14_PRJ\\CPU.cpp",
      "projects\\CIS 200 TeamProject\\CIS_200_TEAM14_PRJ\\CPU_Controller.cpp",
      "projects\\CIS 200 TeamProject\\CIS_200_TEAM14_PRJ\\JobType_ABC.cpp",
      "projects\\CIS 200 TeamProject\\CIS_200_TEAM14_PRJ\\ReadFromFile.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-200_With_Robert_Mann\\projects\\CIS 200 TeamProject\\CIS_200_TEAM14_PRJ\\CIS_200_TEAM14_PRJ_MAIN.cpp",
        "snippet": "// CIS_200_TEAM14_PRJ.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Demetrius Johnson \n//Jingzhou Fang\n\n//special note: We will use vectors for this project; even though a linked list is better to use when you have to delete elements from the container at the front of the list (element 0);\n//however, our vector will remain relatively small and so it will have an affect on the Big 0 time complexity (number of executions) of our project, but not enough in our judgement to use a linked list; we will use the ease of std vector class\n//In the future, we could easily revamp this program and replace any vectors and all vector functionality with a more efficient linked list\n\n//Another note: if any jobs in arrivalQueue match the clock they will move to a CPU to be processed --> if no CPU is available they will move into the jobQueue\n\n/*\n\nPrimary Logic (Clock Manager):\n\n  1) Check data file for any arrival times that match the clock and add it to the ArrivalQ vector\n\n  2) Flush the arrivalQueue vector --> send all jobs from arrival Queue to the CPU Vector to be processed (or to the CPU(s) with the smallest JobQ)\n\n  3) Run all processors\n\n  4) incremenet clock manager\n\n  5) repeat 1-4\n\n*/\n\n\n#include \"ReadFromFile.h\"\nusing namespace std;\n\nint main()\n{\n    cout << \"\\nProgram by: Demetrius Johnson && Jingzhou Fang --UM DEARBRON F2020 SEMESTER --PROF ROBERT MAN CIS 200\\n\";\n    int counter_logFile = 0;\n    int CPUtotalTime_Idle_Running = 0;\n    int nextArrivalTime_inFile = 0; //use this variable to store what is peeked as the next arrival time of the next job in the file\n    int CPUvec_smallestJobQ = 0; //use this variable for storing the smallest jobq in the CPU vector\n    int counter_CurrJobsReadFromFile = 0; //use this variable in order to keep track of the number of jobs that has been read from the data file --> this value will also be used to manipulate the pointer in a file stream variable reading the data file\n    int counter_ClockManager_TimeUnit = 0; //use this as the clock management variable in order to track and perform clock cycles\n    int counter_JobsCompleted_Total = 0; //use this to keep track of the total jobs completed by all processors in order that the clockManager Loop has a basis for which to exit and stop iterating through the while-loop"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\projects\\CIS 200 TeamProject\\CIS_200_TEAM14_PRJ\\CPU.cpp",
        "snippet": "//CPU CLASS HEADER FILE\n\n#include \"CPU.h\"\n\n\nvoid CPU::process_Job(void){ //special note: remember to use the private data members -- don't use set and get methods within the class since it is easier for the program to access the class members rather than call another function\n\n\n\tif (CPU_status_isEmpty == true && CPU_jobQ_status_isEmpty == true && currentJob.jobType == nullchar) { // CPU is idle; so increment idle clock and total idle time\n\n\t\tclock_CPU_IDLE++;\n\t\ttotalIdleTime++;\n\t\treturn; //exit function --> no need to check below statements and waste execution time since there is nothing on the processor or in the job queue\n\t}\n\tif(CPU_status_isEmpty == true && CPU_jobQ_status_isEmpty == false && currentJob.jobType == nullchar){ //enter this statement if the CPU is currently processing nothing --> get a new job and place it on processor from job q\n\t\n\t\tcurrentJob = CPUjobQueue_vector.at(CPUjobQueue_vector.size() - 1); //get the last element from the vector since we set the add_to_jobq function to add the newest arrivals to the front of the vector //-1 since size of vector included 0\n\t\tCPUjobQueue_vector.pop_back(); //delete job from the queue\n\t\tcurrentJobQueue_size--; //decrement job q size since we've added one to the CPU for processing\n\t\tif(currentJobQueue_size == 0) { CPU_jobQ_status_isEmpty = true; } //check to see if after taking the job from job Q if the job Q is now empty --> if it is then set the status to empty= true\n\t\tCPU_status_isEmpty = false; //job will be placed on the processor; thus, cpu is not empty/free\n\t}\n\n\tif (currentJob.processingTime != 0) { //use this loop as long as there is a job on the processcor --> processingTime != 0\n\t\tcurrentJob.processingTime--; //decrement the process time of the current job that the CPU is processing\n\t\tclock_CPU_RUNTIME++; //increment the runtime since the another job's processing unit has been processed by 1 time unit\n\t\ttotalRunTime++; //increment total runtime\n\t\tclock_CPU_IDLE = 0; //ensure that since a process has been completed on the processcor that idle time is at 0\n\t}\n\tif (currentJob.processingTime == 0 && currentJob.jobType != nullchar) { //execute this loop when processing time of a valid job reaches 0 --> now the job is finished processing\n\t\t\n\t\tif (currentJob.jobType == 'A') { totalJobsCompleted_A++; }\n\t\tif (currentJob.jobType == 'B') { totalJobsCompleted_B++; } //use these 3 statments to track job types completed\n\t\tif (currentJob.jobType == 'C') { totalJobsCompleted_C++; }\n\n\t\tCPU_status_isEmpty = true; //change status of CPU to empty state if the current job reaches 0 for processing time (thus it is done processing)\n\t\tcurrentJob = { nullchar, 0, 0 }; //use this to reset the job to empty Job since the current job has now been fully processed\n\t\tjobsCompleted++; //increment number of jobs completed by this CPU object\n\t\tclock_CPU_RUNTIME = 0; //reset runtime clock timer"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\projects\\CIS 200 TeamProject\\CIS_200_TEAM14_PRJ\\CPU_Controller.cpp",
        "snippet": "//CPU_Controller class CPP file\n\n#include \"CPU_Controller.h\"\n\n\n\n\nint CPU_Controller::findSmallest_CPUjobQueue(vector<CPU>& CPU_Vec) { //will use a 1-time binary split search to find smallest value //if program runs too slow we can easily add more binary splits\n\t//use this function to return the element (CPU number) with the smallest job Queue, while also setting the last_recordedSmallest Job queue data member equal to the smallest value to keep track and use in other functions\n\t\n\tint lowerElements_searchRange = 0; //use this to search the lower half of the vector during binary search\n\tint upperElements_searchRange = 0; //use this int to search the upper half of the vector during binary search\n\t\n\t//in the below 2 stamenets we will do a binary split and then proceed to search for the lowest value in each half of the CPU vector seprately \n\n\tlowerElements_searchRange = CPUsize / 2; //lower range is the 1st half of the CPUs in the CPU vector\n\tupperElements_searchRange = CPUsize - lowerElements_searchRange; //upper range is the last half of the CPUs in the CPU vector --> CPUsize - lowerRange == start of 2nd half of the CPU vector\n\t\n\tint i = 0;\n\tint j = upperElements_searchRange; //use these 2 variables for the for-loops\n\n\twhile (true) { //execute this while loop until a smallest value is found --> upon finding smallest value, one of the for-loops inside of this loop will return and thus exit this funciton \n\t\tfor (i = 0; i <= lowerElements_searchRange; i++) { //search the lower elements (lower CPU elements in the CPU vector) for the smallest job queue value //has to be less than or equal to to include that final lower half value\n\n\t\t\tif (CPU_Vec.at(i).get_CPU_JobQueue_size() < lastRecorded_smallestJobQ_value) {\n\n\t\t\t\tlastRecorded_smallestJobQ_value = CPU_Vec.at(i).get_CPU_JobQueue_size(); //set last recorded so that when this function is called again we have a better change of starting closer to the smallest value\n\n\t\t\t\treturn i; //return the element (CPU number) where the smallest job q value was found\n\t\t\t}\n\n\n\t\t}\n\n\t\tfor (j = upperElements_searchRange; j < CPUsize; j++) { //search the lower elements (lower CPU elements in the CPU vector) for the smallest job queue value\n\n\t\t\tif (CPU_Vec.at(j).get_CPU_JobQueue_size() < lastRecorded_smallestJobQ_value) {"
      },
      {
        "file": "CIS-200_With_Robert_Mann\\projects\\CIS 200 TeamProject\\CIS_200_TEAM14_PRJ\\JobType_ABC.cpp",
        "snippet": "#include \"JobType_ABC.h\""
      },
      {
        "file": "CIS-200_With_Robert_Mann\\projects\\CIS 200 TeamProject\\CIS_200_TEAM14_PRJ\\ReadFromFile.cpp",
        "snippet": "//READ FROM FILE class CPP FILE\n#include \"ReadFromFile.h\"\n#include <vector>\nusing namespace std;\n\n\n//\n//Job Type\t\tArrival Time\t\tProcessing Time\n//   A\t\t\t\t5 + / -1\t\t\t\t3 + / -2\n//   B\t\t\t\t10 + / -1\t\t\t\t8 + / -2\n//   C\t\t\t\t25 + / -1\t\t\t\t11 + / -2\n//Note: \n//5 +/- 1 is 4, 5, 6 --> 4 + rand() % 3\n//Arrival Time is time since the last job of the same Type\n\n\n\n\n\n\n\n\nvoid ReadFromFile::openingMenu(void) {\n\n\n\tcout << \"---------------------------------------WELCOME---------------------------------------------\\n\\n\";\n\tcout << \"The initialization of this program will read and write data to a JobDatabase binary file: 'JobDatabase.dat'.\\n\";\n\tcout << \"Below is a snippet of the current database on file for 4150 Jobs (2500 type A, 1200 type B, 450 type C) : \\n\";\n\n\n\n\n}\nvoid ReadFromFile::re_initFile_newDataSet(void) {\n\n\tint curr_SmallestClockVal = 0; //use this to find the smallest clock value to be written to the file for any specified job type that matches this value\n\tint jobCounter_A = 2500; //use this to write jobs to the file until total required number of A jobs have been written\n\tint jobCounter_B = 1200; //use this to write jobs to the file until total required number of B jobs have been written"
      }
    ]
  }
]