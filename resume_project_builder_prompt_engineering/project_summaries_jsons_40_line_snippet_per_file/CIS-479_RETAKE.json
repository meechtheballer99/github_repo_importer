[
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech",
    "code_files": [
      "CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\MAIN_Project1-CIS-479-Meech.cpp",
      "CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\minHeapPQ.cpp",
      "CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\QuadraticProbing.cpp",
      "CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\StateNode.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\MAIN_Project1-CIS-479-Meech.cpp",
        "snippet": "// Project1-CIS-479-Meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius E Johnson\n//Purpose: Implement the A* Search algorithm\n//Date Created: 7/15/22\n//Date Modified: \n\n//CIS-479: Windy Maze puzzle 8-tile program\n#include <iostream>\n#include \"StateNode.h\"\n#include \"minHeapPQ.h\"\n#include \"minHeapPQ.cpp\"\n#include \"QuadraticProbing.h\"\nusing namespace std;\n\n////////////////////////FUNCTION DECLARATIONS//////////////////////\nint getValueLocation_row(StateNode& state, int value);\nint getValueLocation_col(StateNode& state, int value);\nint calcHeuristic_full_state(StateNode& stateStart, StateNode& stateGoal);\nint calcHeuristic_single_tile(StateNode& stateStart, StateNode& stateGoal, int& rowStart, int& colStart);\nvoid calcHeuristic_based_on_parent(StateNode& parentNode, StateNode& childNode);\nvoid swap_blankTile_nonBlankTile(StateNode& parentNode, StateNode& childNode);\nvoid output_traced_solution(StateNode& terminal);\nvoid output_expansionOrder(void);\nint expandNode_WNES_order(StateNode& parentNode);\nbool A_Star_search(StateNode& solutionNode);\nvoid welcome_menu(void);\n//////////////GLOBAL VARIABLES//////////////\nint initialize_hashTableSize = 300; //use this to set hash table size in the event that solution is found but cannot be traced due to rehash() function needing to be called and making parent pointers bad\nminHeapPQ<StateNode> frontierSet_PQ;  //Frontier Set: all leaf nodes available for expansion at any given point (in time / during traversal).\nHashTable<StateNode> exploreSet_HashTable(initialize_hashTableSize);   //Use explored set to remember every expanded node to avoid redundant paths.\nStateNode stateGoal;\nStateNode stateStart;\nint searchLoop_Limitation;\nvector<StateNode> expansionOrder_vector; //track expansion order\n//////////////MAIN FUNCTION///////////////////\nint main()\n{\n    welcome_menu();\n    //initialize start state node"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\QuadraticProbing.cpp",
        "snippet": "//Hash Table function provided by Professor Dr. Junhua Guo -- UM-DEARBORN -- \n//Modfied by Demetrius Johnson --for CIS-350 Summer 2021 and CIS-479 Summer 2022\n//this version of the class was adapted for the Windy Puzzle Program 1 for CIS-479 with Doctor Shenquan Wang\n#include \"QuadraticProbing.h\"\n#include <iostream>\nusing namespace std;\n\n/**\n * Internal method to test if a positive number is prime.\n * Not an efficient algorithm.\n */\nbool isPrime( int n )\n{\n    if( n == 2 || n == 3 )\n        return true;\n\n    if( n == 1 || n % 2 == 0 )\n        return false;\n\n    for( int i = 3; i * i <= n; i += 2 )\n        if( n % i == 0 )\n            return false;\n\n    return true;\n}\n\n/**\n * Internal method to return a prime number at least as large as n.\n * Assumes n > 0.\n */\nint nextPrime( int n )\n{\n    if( n <= 0 )\n        n = 3;\n\n    if( n % 2 == 0 )\n        n++;\n\n    for( ; !isPrime( n ); n += 2 )\n        ;"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\StateNode.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: \n//Date Created: 7/15/22\n//Date Modified: \n\n\n#include \"StateNode.h\"\n\nStateNode::StateNode() {\n\n\theuristicVal = -1;\n\tpathCost = -1;\n\tEvalFunction = -1;\n\thash_string.resize(9);\n\tparent = nullptr; //pointer works so that you can trace back to root; but rehash function causes this program to fail; safegaurd placed in main program.\n\n}\nvoid StateNode::setEval_value(void) { EvalFunction = (pathCost + heuristicVal); }\n\n//convert table values for a given node to a uniquely ordered string value\n//so that it can be used in the hash function (a part of the Quadratic Probing class)\nvoid StateNode::setHash_string(void) {\n\n\t\n\tint string_location = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\n\t\t\thash_string[string_location] = table[i][j] + 48;  //ASCII characters '0' - '9' begin at decimal 48\n\t\t\tstring_location++;\n\t\t}\n\t}\n}\n\n/////OPERATOR OVERLOADING///////\nbool StateNode::operator< (const StateNode& RHoperand) {\n\n\tif (EvalFunction < RHoperand.EvalFunction)\n\t\treturn true;\n\telse"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files",
    "code_files": [
      "CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\P2_COMPLETED PROJECT\\Project2-CIS-479-Meech",
    "code_files": [
      "CIS-479_firstAttempt_programs\\P2_COMPLETED PROJECT\\Project2-CIS-479-Meech\\MAIN_Project2-CIS-479-Meech.cpp",
      "CIS-479_firstAttempt_programs\\P2_COMPLETED PROJECT\\Project2-CIS-479-Meech\\Value_Iteration_BellmanEquation_meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\P2_COMPLETED PROJECT\\Project2-CIS-479-Meech\\MAIN_Project2-CIS-479-Meech.cpp",
        "snippet": "\ufeff//MAIN_Project2-CIS-479-Meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius E Johnson\n//Purpose: Implement Robot Localization with the HMM (Hidden Markov Model) algorithm - CIS-479-Project2\n//Special Notes: Adapated some of my Value Iteration Bellman Equation Program\n//Date Created: 8/02/2022\n//Date Modified: 8/09/2022\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\n\n//note:\n//static keyword will make the variables go in the .DATA section at compile time and not on the run time stack --> which requires an instnace of table to be called\n//static variables therefore are shared by all objects of the class AND can be accessed even before an object of the class is declared.\nstruct table {\n\n    const static int numRows = 6; \n    const static int numCols = 7;\n    float tablePos_locationProb_prior[numRows][numCols];\n    float tablePos_locationProb_posterior[numRows][numCols];\n    void setPrior_toPosterior(void) {\n    \n        for (int i = 0; i < numRows; i++)\n            for (int j = 0; j < numCols; j++)\n                tablePos_locationProb_prior[i][j] = tablePos_locationProb_posterior[i][j];\n    }\n   \n};\n\nenum class Direction_Relative { NO_DIREC = 0, FORWARD = 1, LEFT = 2, RIGHT = 3 };\nenum class Direction_Cardinal { WEST = 1, NORTH = 2, EAST = 3, SOUTH = 4 };\nenum Location {OBSTACLE = 1, OPEN_SQUARE = 0};\n//////////////////GLOBAL VARIABLES//////////////////////////////////////////\ntable table_struct_global;\n\n//moving transition probabilities:\nconst float forward_probability = (float)0.8;     //move forward in desired direction = 80%"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\P2_COMPLETED PROJECT\\Project2-CIS-479-Meech\\Value_Iteration_BellmanEquation_meech.cpp",
        "snippet": "//Value_Iteration_BellmanEquation_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n//Purposse:     //Value Iteration Program using the Bellman Equation\\n-for CIS-479 with Doctor Shengquan Wang\n                //Program Written to demonstrate Lecutre Slide 7 - Planning and Decision Making (slides 42-50)\n                \n//Date Created: 7/28/22\n//Date Modified: 7/28/22\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\nstruct table {\n\n    int tablePos_reward[3][4];\n    float utility_val[3][4];\n    int rewardVal = -3;\n    int selected_utility_val = 0;\n};\n\nenum class Direction { NO_DIREC = 0, FORWARD = 1, LEFT = 2, RIGHT = 3 };\nenum class Direction_Cardinal { WEST = 1, NORTH = 2, EAST = 3, SOUTH = 4 };\n\n//////////////////GLOBAL VARIABLES//////////////////////////////////////////\ntable table_struct_global;\nfloat forward_probability = 0.8;\nfloat left_probability = 0.1;\nfloat right_probability = 0.1;\nint num_Bellman_iterations = 0;\nint endState_1 = 100;\nint endState_2 = -100;\n/////////////////////FUNCTION DECLARATIONS/////////////////////////////////\nvoid outputTable_reward(table &table_struct);\nvoid outputTable_utility(table &table_struct);\nfloat expected_utility_WEST(int row, int col);\nfloat expected_utility_NORTH(int row, int col);\nfloat expected_utility_EAST(int row, int col);\nfloat expected_utility_SOUTH(int row, int col);"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\CIS-479_HW4_Q1_MarkovChain_Meech",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\CIS-479_HW4_Q1_MarkovChain_Meech\\CIS-479_HW4_Q1_MarkovChain_Meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\CIS-479_HW4_Q1_MarkovChain_Meech\\CIS-479_HW4_Q1_MarkovChain_Meech.cpp",
        "snippet": "\ufeff// CIS-479_HW4_Q1_MarkovChain_Meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n// Purpose: Find probabilities from a Markov Chain data model; for CIS 479 SUMMER II With Dr. Shengquan Wang\n//Date Created: 8/13/22\n//Date Modified: 8/15/22\n\n\n/*\n\n\nWe consider a 3-state (a, b, c) Markov Chain. \n\nWe observe the following sequence of data: \nb a a b a b c c b c a b c c a b c c a c b c a b c c b b b a b c. (# of data points collected = 32).\n\nPlease use MLE and Laplace Smoothing with k = 2 to learn the following transition probabilities: \nP(a|a), P(b|a), P(c|a), P(a|b), P(b|b), P(c|b), P(a|c), P(b|c), P(c|c).\n\n\nMLE of \ud835\udc5d_\ud835\udc5a under Laplace Smoothing with k:\n\ud835\udc5d_\ud835\udc5a^\u2217=(\ud835\udc41_\ud835\udc5a+\ud835\udc58)/(\ud835\udc41+\ud835\udc58\u2217\ud835\udc40)\n\ud835\udc41_\ud835\udc5a is the occurrence of data in Category m.\u00a0\n\ud835\udc41 is the total number of data items.\n\n\n*/\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n\tcout << \"\\n HW4_Q1: Find probabilities from a Markov Chain data model; for CIS 479 SUMMER II With Dr. Shenguan Wang\\n--BY Demetrius Johnson\\n\\n\";\n\n\tstring data_string = \"b a a b a b c c b c a b c c a b c c a c b c a b c c b b b a b c\";\n\n\t//delete all spaces in the data squence:\n\tfor (int i = 0; i < data_string.size(); i++) {"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\EM_Algorithm_HW4_Q7-CIS-479_meech",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\EM_Algorithm_HW4_Q7-CIS-479_meech\\EM_Algorithm_HW4_Q7-CIS-479_meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\EM_Algorithm_HW4_Q7-CIS-479_meech\\EM_Algorithm_HW4_Q7-CIS-479_meech.cpp",
        "snippet": "\ufeff// EM_Algorithm_HW4_Q7-CIS-479_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson (Meech)\n//Purpose: Create the Exepectation Maximization (EM) algorithm in order to answer question 7 from HW4, CIS-479 SUMMER II with DR. Shengquan Wang\n//Date created: 8/17/22\n//Date Modified: 8/18/22\n\n#include <iostream>\n#include <stdlib.h>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\n\n/*\n\nWe have the following six 1D data_set points: 1.6, 2.1, 1.8, 5.3, 6.7, 4.7. \nWe consider EM with two components with the following initial setup: \n\u03c0_1 = 0.4, \u00b5_1 = 1, (\u03c3_1)^2 = 2, \u03c0_2 = 0.6, \u00b5_2 = 2, (\u03c3_2)^2 = 2, \nwhere \u03c0_k = weight of a cluster on all data_set pts, \u00b5_k = mean value of a cluster, \u03c3_k = standard deviation of a cluster.\nPlease find the updated values of these 6 variables after one iteration using EM.\n*/\n\n/*\n////////////////////NOTES BEGIN//////////////////////////////////////////////\n\nGuassian Distribution function with d demensions, where T is the transpose matrix (necessary for dimensions of d=3 or greater), \u00b5=mean, \ud835\udf2e=standard deviation:\n\nP(x | \u00b5, \ud835\udf2e) =  \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99) = (  exp\u2061( (\u22121/2) * (\ud835\udc99\u2212\ud835\udf41)^\ud835\udc47 * \u03a3^(\u22121) * (\ud835\udc99\u2212\ud835\udf41) )  ) / sqrt( (2\ud835\udf0b)^\ud835\udc51 * |\ud835\udf2e|) --> |\ud835\udf2e| = magintiude of matrix \ud835\udf2e, \u03a3^(\u22121) = inverse of matrix \u03a3\n\n-->for 1 dimension (d=1), the Gaussian Distribution Function simplifies to:\nP(x | \u00b5, \ud835\udf2e) =  \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99) = (  exp\u2061( (\u22121/2) * (\ud835\udc99\u2212\ud835\udf41)^(2) * \u03a3^(-2) )  ) / sqrt( (2\ud835\udf0b) * \ud835\udf2e^(2) )\n\n\nThus, for Guassian Learning with MLE (max likelihood estimation):\n\n\ud835\udc5d(\ud835\udc99_1,\u2026,\ud835\udc99_\ud835\udc41 ) = \u220f_\ud835\udc5b( \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99_\ud835\udc5b) ), where \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99_n) represents the distribution function given a population N as shown above.\n\nNOTE: N refers to distribution given a population for the above f(x), it is not multiplied; it just represents an f(x) given a mean and standard deviation for any input x essentially."
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\FINAL_EXAM_Programs_CIS-479-MEECH",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\FINAL_EXAM_Programs_CIS-479-MEECH\\CIS-479_HW4_Q1_MarkovChain_Meech.cpp",
      "CIS-479_firstAttempt_programs\\programming\\FINAL_EXAM_Programs_CIS-479-MEECH\\EM-Algorithm_FINALEXAMQ13_meech.cpp",
      "CIS-479_firstAttempt_programs\\programming\\FINAL_EXAM_Programs_CIS-479-MEECH\\K-MeansAlgorithm_FINALEXAMQ12_meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\FINAL_EXAM_Programs_CIS-479-MEECH\\CIS-479_HW4_Q1_MarkovChain_Meech.cpp",
        "snippet": "\ufeff// CIS-479_HW4_Q1_MarkovChain_Meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n// Purpose: Find probabilities from a Markov Chain data model; for CIS 479 SUMMER II With Dr. Shengquan Wang\n//Date Created: 8/13/22\n//Date Modified: 8/15/22\n\n\n/*\n\n\nWe consider a 3-state (a, b, c) Markov Chain. \n\nWe observe the following sequence of data: \nb a a b a b c c b c a b c c a b c c a c b c a b c c b b b a b c. (# of data points collected = 32).\n\nPlease use MLE and Laplace Smoothing with k = 2 to learn the following transition probabilities: \nP(a|a), P(b|a), P(c|a), P(a|b), P(b|b), P(c|b), P(a|c), P(b|c), P(c|c).\n\n\nMLE of \ud835\udc5d_\ud835\udc5a under Laplace Smoothing with k:\n\ud835\udc5d_\ud835\udc5a^\u2217=(\ud835\udc41_\ud835\udc5a+\ud835\udc58)/(\ud835\udc41+\ud835\udc58\u2217\ud835\udc40)\n\ud835\udc41_\ud835\udc5a is the occurrence of data in Category m.\u00a0\n\ud835\udc41 is the total number of data items.\n\n\n*/\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n\tcout << \"\\n HW4_Q1: Find probabilities from a Markov Chain data model; for CIS 479 SUMMER II With Dr. Shenguan Wang\\n--BY Demetrius Johnson\\n\\n\";\n\n\tstring data_string = \"b a a b a b c c b c a b c c a b c c a c b c a b c c b b b a b c\";\n\n\t//delete all spaces in the data squence:\n\tfor (int i = 0; i < data_string.size(); i++) {"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\FINAL_EXAM_Programs_CIS-479-MEECH\\EM-Algorithm_FINALEXAMQ13_meech.cpp",
        "snippet": "\ufeff// EM_Algorithm_HW4_Q7-CIS-479_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson (Meech)\n//Purpose: Create the Exepectation Maximization (EM) algorithm in order to answer question 7 from HW4, CIS-479 SUMMER II with DR. Shengquan Wang\n//Date created: 8/17/22\n//Date Modified: 8/18/22\n\n#include <iostream>\n#include <stdlib.h>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\n\n/*\n\nWe have the following six 1D data_set points: 1.6, 2.1, 1.8, 5.3, 6.7, 4.7. \nWe consider EM with two components with the following initial setup: \n\u03c0_1 = 0.4, \u00b5_1 = 1, (\u03c3_1)^2 = 2, \u03c0_2 = 0.6, \u00b5_2 = 2, (\u03c3_2)^2 = 2, \nwhere \u03c0_k = weight of a cluster on all data_set pts, \u00b5_k = mean value of a cluster, \u03c3_k = standard deviation of a cluster.\nPlease find the updated values of these 6 variables after one iteration using EM.\n*/\n\n/*\n////////////////////NOTES BEGIN//////////////////////////////////////////////\n\nGuassian Distribution function with d demensions, where T is the transpose matrix (necessary for dimensions of d=3 or greater), \u00b5=mean, \ud835\udf2e=standard deviation:\n\nP(x | \u00b5, \ud835\udf2e) =  \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99) = (  exp\u2061( (\u22121/2) * (\ud835\udc99\u2212\ud835\udf41)^\ud835\udc47 * \u03a3^(\u22121) * (\ud835\udc99\u2212\ud835\udf41) )  ) / sqrt( (2\ud835\udf0b)^\ud835\udc51 * |\ud835\udf2e|) --> |\ud835\udf2e| = magintiude of matrix \ud835\udf2e, \u03a3^(\u22121) = inverse of matrix \u03a3\n\n-->for 1 dimension (d=1), the Gaussian Distribution Function simplifies to: \nP(x | \u00b5, \ud835\udf2e) =  \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99) = (  exp\u2061( (\u22121/2) * (\ud835\udc99\u2212\ud835\udf41)^(2) * \u03a3^(-2) )  ) / sqrt( (2\ud835\udf0b) * \ud835\udf2e^(2) )\n\n\nThus, for Guassian Learning with MLE (max likelihood estimation):\n\n\ud835\udc5d(\ud835\udc99_1,\u2026,\ud835\udc99_\ud835\udc41 ) = \u220f_\ud835\udc5b( \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99_\ud835\udc5b) ), where \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99_n) represents the distribution function given a population N as shown above.\n\nNOTE: N refers to distribution given a population for the above f(x), it is not multiplied; it just represents an f(x) given a mean and standard deviation for any input x essentially."
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\FINAL_EXAM_Programs_CIS-479-MEECH\\K-MeansAlgorithm_FINALEXAMQ12_meech.cpp",
        "snippet": "// K-MeansAlgorithm_HW4_Q6-CIS-479_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson (Meech)\n//Purpose: Create a K-Means algorithm in order to answer question 6 from HW4, CIS-479 SUMMER II with DR. Shengquan Wang\n//Date created: 8/16/22\n//Date Modified: 8/17/22\n/*\n\nWe have the following eight 2D data points:\nX          Y\n24.5     3.5\n26.5     7.0\n21.5     7.5\n25.0    15.5\n2.5     20.5\n9.5     23.0\n11.0    20.0\n21.5     4.0\nTwo initial centroids (12.0, 12.5), (15.0, 15.5). Please find the next two centroids after one iteration using K-means\nwith K = 2 and Euclidean distance.\n\n\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <iomanip>\nusing namespace std;\n\n/////////////////FUNCTION DECLARATIONS, STRUCTS, ENUM DECLARATIONS, GLOBAL VAR//////////////////////////////\nstruct XY_coord { float x; float y; };\nint numDataPts = 0;\nint numUpdatesPerformed = 0;\nint K = 2;\n\nbool init_data_array(vector<XY_coord>& data_array);\nvoid calc_Euclidean_distances(vector<XY_coord>& data_array, XY_coord& centroid, vector<float>& E_array);"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\K-MeansAlgorithm_HW4_Q6-CIS-479_meech",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\K-MeansAlgorithm_HW4_Q6-CIS-479_meech\\K-MeansAlgorithm_HW4_Q6-CIS-479_meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\K-MeansAlgorithm_HW4_Q6-CIS-479_meech\\K-MeansAlgorithm_HW4_Q6-CIS-479_meech.cpp",
        "snippet": "// K-MeansAlgorithm_HW4_Q6-CIS-479_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson (Meech)\n//Purpose: Create a K-Means algorithm in order to answer question 6 from HW4, CIS-479 SUMMER II with DR. Shengquan Wang\n//Date created: 8/16/22\n//Date Modified: 8/17/22\n/*\n\nWe have the following eight 2D data points:\nX          Y\n24.5     3.5\n26.5     7.0\n21.5     7.5\n25.0    15.5\n2.5     20.5\n9.5     23.0\n11.0    20.0\n21.5     4.0\nTwo initial centroids (12.0, 12.5), (15.0, 15.5). Please find the next two centroids after one iteration using K-means\nwith K = 2 and Euclidean distance.\n\n\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <iomanip>\nusing namespace std;\n\n/////////////////FUNCTION DECLARATIONS, STRUCTS, ENUM DECLARATIONS, GLOBAL VAR//////////////////////////////\nstruct XY_coord { float x; float y; };\nint numDataPts = 0;\nint numUpdatesPerformed = 0;\nint K = 2;\n\nbool init_data_array(vector<XY_coord>& data_array);\nvoid calc_Euclidean_distances(vector<XY_coord>& data_array, XY_coord& centroid, vector<float>& E_array);"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\minHeapPQ.cpp",
      "CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\minHeapPQ_TestModuleProject-meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\minHeapPQ_TestModuleProject-meech.cpp",
        "snippet": "// minHeapPQ_TestModuleProject-meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n//Author: Demetrius E Johnson\n//Purpose: test the minHeapPQ library module so that I can make sure it can be integrated with other programs\n//Date Created: 7/21/22\n//Date Modified: 7/21/22\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this sitation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nminHeapPQ<int> pq;\nvector<int> test;\nint main()\n{\n\n\tfor (int i = 0; i < 15; i++)\n\t\ttest.push_back(i);\n\n\t//test inserting numbers 0 to 14 and then popping them:\n\tcout << \"\\ntest inserting numbers 0 to 14 and then popping them:\\n\";\n\tfor (int i = 0; i < 15; i++)\n\t\tpq.insert(test[i]);\n\n\tfor (int i = 0; i < 15; i++)\n\t\tcout << pq.deleteMin() << endl;\n\n\n\t//test inserting numbers 14 to 0 and then popping them:\n\tcout << \"\\ntest inserting numbers 14 to 0 and then popping them:\\n\";\n\tfor (int i = 14; i >= 0; i--)\n\t\tpq.insert(test[i]);"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\back up\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 8/02/21\n\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject\n\tif (heapArray.size() == 1) { //case: first element to be added to queue; simply add it and exit function\n\n\t\theapArray.push_back(insertElement);\n\t\treturn;\n\t}\n\telse {//case: size of heap array > 1:\n\n\t\t//insert the element at the end and initialize the parent and children values relative to the size of the heap upon calling the function:"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\CIS-350-ORIGNAL H AND CPP__broken\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 8/02/21\n\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\tif (heapArray.size() == 1) { //case: first element to be added to queue; simply add it and exit function\n\n\t\theapArray.push_back(insertElement);\n\t\treturn;\n\t}\n\telse {//case: size of heap array > 1:\n\t\t\n\t\t//insert the element at the end and initialize the parent and children values relative to the size of the heap upon calling the function:\n\t\theapArray.push_back(insertElement);\t//insert"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\back up",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\back up\\minHeapPQ.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\back up\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 8/02/21\n\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject\n\tif (heapArray.size() == 1) { //case: first element to be added to queue; simply add it and exit function\n\n\t\theapArray.push_back(insertElement);\n\t\treturn;\n\t}\n\telse {//case: size of heap array > 1:\n\n\t\t//insert the element at the end and initialize the parent and children values relative to the size of the heap upon calling the function:"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\CIS-350-ORIGNAL H AND CPP__broken",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\CIS-350-ORIGNAL H AND CPP__broken\\minHeapPQ.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\CIS-350-ORIGNAL H AND CPP__broken\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 8/02/21\n\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\tif (heapArray.size() == 1) { //case: first element to be added to queue; simply add it and exit function\n\n\t\theapArray.push_back(insertElement);\n\t\treturn;\n\t}\n\telse {//case: size of heap array > 1:\n\t\t\n\t\t//insert the element at the end and initialize the parent and children values relative to the size of the heap upon calling the function:\n\t\theapArray.push_back(insertElement);\t//insert"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\Tested and Fully functional minHeap PQ files",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\minHeapPQ_TestModuleProject-meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\MAIN_Project1-CIS-479-Meech.cpp",
      "CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\minHeapPQ.cpp",
      "CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\QuadraticProbing.cpp",
      "CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\StateNode.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\MAIN_Project1-CIS-479-Meech.cpp",
        "snippet": "// Project1-CIS-479-Meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius E Johnson\n//Purpose: Implement the A* Search algorithm\n//Date Created: 7/15/22\n//Date Modified: \n\n//CIS-479: Windy Maze puzzle 8-tile program\n#include <iostream>\n#include \"StateNode.h\"\n#include \"minHeapPQ.h\"\n#include \"minHeapPQ.cpp\"\n#include \"QuadraticProbing.h\"\nusing namespace std;\n\n////////////////////////FUNCTION DECLARATIONS//////////////////////\nint getValueLocation_row(StateNode& state, int value);\nint getValueLocation_col(StateNode& state, int value);\nint calcHeuristic_full_state(StateNode& stateStart, StateNode& stateGoal);\nint calcHeuristic_single_tile(StateNode& stateStart, StateNode& stateGoal, int& rowStart, int& colStart);\nvoid calcHeuristic_based_on_parent(StateNode& parentNode, StateNode& childNode);\nvoid swap_blankTile_nonBlankTile(StateNode& parentNode, StateNode& childNode);\nvoid output_traced_solution(StateNode& terminal);\nvoid output_expansionOrder(void);\nint expandNode_WNES_order(StateNode& parentNode);\nbool A_Star_search(StateNode& solutionNode);\nvoid welcome_menu(void);\n//////////////GLOBAL VARIABLES//////////////\nint initialize_hashTableSize = 300; //use this to set hash table size in the event that solution is found but cannot be traced due to rehash() function needing to be called and making parent pointers bad\nminHeapPQ<StateNode> frontierSet_PQ;  //Frontier Set: all leaf nodes available for expansion at any given point (in time / during traversal).\nHashTable<StateNode> exploreSet_HashTable(initialize_hashTableSize);   //Use explored set to remember every expanded node to avoid redundant paths.\nStateNode stateGoal;\nStateNode stateStart;\nint searchLoop_Limitation;\nvector<StateNode> expansionOrder_vector; //track expansion order\n//////////////MAIN FUNCTION///////////////////\nint main()\n{\n    welcome_menu();\n    //initialize start state node"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\QuadraticProbing.cpp",
        "snippet": "//Hash Table function provided by Professor Dr. Junhua Guo -- UM-DEARBORN -- \n//Modfied by Demetrius Johnson --for CIS-350 Summer 2021 and CIS-479 Summer 2022\n//this version of the class was adapted for the Windy Puzzle Program 1 for CIS-479 with Doctor Shenquan Wang\n#include \"QuadraticProbing.h\"\n#include <iostream>\nusing namespace std;\n\n/**\n * Internal method to test if a positive number is prime.\n * Not an efficient algorithm.\n */\nbool isPrime( int n )\n{\n    if( n == 2 || n == 3 )\n        return true;\n\n    if( n == 1 || n % 2 == 0 )\n        return false;\n\n    for( int i = 3; i * i <= n; i += 2 )\n        if( n % i == 0 )\n            return false;\n\n    return true;\n}\n\n/**\n * Internal method to return a prime number at least as large as n.\n * Assumes n > 0.\n */\nint nextPrime( int n )\n{\n    if( n <= 0 )\n        n = 3;\n\n    if( n % 2 == 0 )\n        n++;\n\n    for( ; !isPrime( n ); n += 2 )\n        ;"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\StateNode.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: \n//Date Created: 7/15/22\n//Date Modified: \n\n\n#include \"StateNode.h\"\n\nStateNode::StateNode() {\n\n\theuristicVal = -1;\n\tpathCost = -1;\n\tEvalFunction = -1;\n\thash_string.resize(9);\n\tparent = nullptr; //pointer works so that you can trace back to root; but rehash function causes this program to fail; safegaurd placed in main program.\n\n}\nvoid StateNode::setEval_value(void) { EvalFunction = (pathCost + heuristicVal); }\n\n//convert table values for a given node to a uniquely ordered string value\n//so that it can be used in the hash function (a part of the Quadratic Probing class)\nvoid StateNode::setHash_string(void) {\n\n\t\n\tint string_location = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\n\t\t\thash_string[string_location] = table[i][j] + 48;  //ASCII characters '0' - '9' begin at decimal 48\n\t\t\tstring_location++;\n\t\t}\n\t}\n}\n\n/////OPERATOR OVERLOADING///////\nbool StateNode::operator< (const StateNode& RHoperand) {\n\n\tif (EvalFunction < RHoperand.EvalFunction)\n\t\treturn true;\n\telse"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\P1_COMPLETED PROJECT\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\P2_COMPLETED PROJECT\\Project2-CIS-479-Meech",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\P2_COMPLETED PROJECT\\Project2-CIS-479-Meech\\MAIN_Project2-CIS-479-Meech.cpp",
      "CIS-479_firstAttempt_programs\\programming\\P2_COMPLETED PROJECT\\Project2-CIS-479-Meech\\Value_Iteration_BellmanEquation_meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\P2_COMPLETED PROJECT\\Project2-CIS-479-Meech\\MAIN_Project2-CIS-479-Meech.cpp",
        "snippet": "\ufeff//MAIN_Project2-CIS-479-Meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius E Johnson\n//Purpose: Implement Robot Localization with the HMM (Hidden Markov Model) algorithm - CIS-479-Project2\n//Special Notes: Adapated some of my Value Iteration Bellman Equation Program\n//Date Created: 8/02/2022\n//Date Modified: 8/09/2022\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\n\n//note:\n//static keyword will make the variables go in the .DATA section at compile time and not on the run time stack --> which requires an instnace of table to be called\n//static variables therefore are shared by all objects of the class AND can be accessed even before an object of the class is declared.\nstruct table {\n\n    const static int numRows = 6; \n    const static int numCols = 7;\n    float tablePos_locationProb_prior[numRows][numCols];\n    float tablePos_locationProb_posterior[numRows][numCols];\n    void setPrior_toPosterior(void) {\n    \n        for (int i = 0; i < numRows; i++)\n            for (int j = 0; j < numCols; j++)\n                tablePos_locationProb_prior[i][j] = tablePos_locationProb_posterior[i][j];\n    }\n   \n};\n\nenum class Direction_Relative { NO_DIREC = 0, FORWARD = 1, LEFT = 2, RIGHT = 3 };\nenum class Direction_Cardinal { WEST = 1, NORTH = 2, EAST = 3, SOUTH = 4 };\nenum Location {OBSTACLE = 1, OPEN_SQUARE = 0};\n//////////////////GLOBAL VARIABLES//////////////////////////////////////////\ntable table_struct_global;\n\n//moving transition probabilities:\nconst float forward_probability = (float)0.8;     //move forward in desired direction = 80%"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\P2_COMPLETED PROJECT\\Project2-CIS-479-Meech\\Value_Iteration_BellmanEquation_meech.cpp",
        "snippet": "//Value_Iteration_BellmanEquation_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n//Purposse:     //Value Iteration Program using the Bellman Equation\\n-for CIS-479 with Doctor Shengquan Wang\n                //Program Written to demonstrate Lecutre Slide 7 - Planning and Decision Making (slides 42-50)\n                \n//Date Created: 7/28/22\n//Date Modified: 7/28/22\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\nstruct table {\n\n    int tablePos_reward[3][4];\n    float utility_val[3][4];\n    int rewardVal = -3;\n    int selected_utility_val = 0;\n};\n\nenum class Direction { NO_DIREC = 0, FORWARD = 1, LEFT = 2, RIGHT = 3 };\nenum class Direction_Cardinal { WEST = 1, NORTH = 2, EAST = 3, SOUTH = 4 };\n\n//////////////////GLOBAL VARIABLES//////////////////////////////////////////\ntable table_struct_global;\nfloat forward_probability = 0.8;\nfloat left_probability = 0.1;\nfloat right_probability = 0.1;\nint num_Bellman_iterations = 0;\nint endState_1 = 100;\nint endState_2 = -100;\n/////////////////////FUNCTION DECLARATIONS/////////////////////////////////\nvoid outputTable_reward(table &table_struct);\nvoid outputTable_utility(table &table_struct);\nfloat expected_utility_WEST(int row, int col);\nfloat expected_utility_NORTH(int row, int col);\nfloat expected_utility_EAST(int row, int col);\nfloat expected_utility_SOUTH(int row, int col);"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\MAIN_Project1_CIS-479_QuizQuestion.cpp",
      "CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\minHeapPQ.cpp",
      "CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\Project1-CIS-479-Meech.cpp",
      "CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\QuadraticProbing.cpp",
      "CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\StateNode.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\MAIN_Project1_CIS-479_QuizQuestion.cpp",
        "snippet": "// Project1-CIS-479-Meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius E Johnson\n//Purpose: Implement the A* Search algorithm\n//Date Created: 7/15/22\n//Date Modified: \n\n//CIS-479: Windy Maze puzzle 8-tile program\n#include <iostream>\n#include \"StateNode.h\"\n#include \"minHeapPQ.h\"\n#include \"minHeapPQ.cpp\"\n#include \"QuadraticProbing.h\"\nusing namespace std;\n\n////////////////////////FUNCTION DECLARATIONS//////////////////////\nint getValueLocation_row(StateNode& state, int value);\nint getValueLocation_col(StateNode& state, int value);\nint calcHeuristic_full_state(StateNode& stateStart, StateNode& stateGoal);\nint calcHeuristic_single_tile(StateNode& stateStart, StateNode& stateGoal, int& rowStart, int& colStart);\nvoid calcHeuristic_based_on_parent(StateNode& parentNode, StateNode& childNode);\nvoid swap_blankTile_nonBlankTile(StateNode& parentNode, StateNode& childNode);\nvoid output_traced_solution(StateNode& terminal);\nvoid output_expansionOrder(void);\nint expandNode_WNES_order(StateNode& parentNode);\nbool A_Star_search(StateNode& solutionNode);\nvoid welcome_menu(void);\n//////////////GLOBAL VARIABLES//////////////\nint initialize_hashTableSize = 300; //use this to set hash table size in the event that solution is found but cannot be traced due to rehash() function needing to be called and making parent pointers bad\nminHeapPQ<StateNode> frontierSet_PQ;  //Frontier Set: all leaf nodes available for expansion at any given point (in time / during traversal).\nHashTable<StateNode> exploreSet_HashTable(initialize_hashTableSize);   //Use explored set to remember every expanded node to avoid redundant paths.\nStateNode stateGoal;\nStateNode stateStart;\nint searchLoop_Limitation;\nvector<StateNode> expansionOrder_vector; //track expansion order\n//////////////MAIN FUNCTION///////////////////\nint main()\n{\n    welcome_menu();\n    //initialize start state node"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\Project1-CIS-479-Meech.cpp",
        "snippet": "// Project1-CIS-479-Meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius E Johnson\n//Purpose: Implement the A* Search algorithm\n//Date Created: 7/15/22\n//Date Modified: \n\n//CIS-479: Windy Maze puzzle 8-tile program\n#include <iostream>\n#include \"StateNode.h\"\n#include \"minHeapPQ.h\"\n#include \"minHeapPQ.cpp\"\n#include \"QuadraticProbing.h\"\nusing namespace std;\n\n////////////////////////FUNCTION DECLARATIONS//////////////////////\nint getValueLocation_row(StateNode& state, int value);\nint getValueLocation_col(StateNode& state, int value);\nint calcHeuristic_full_state(StateNode& stateStart, StateNode& stateGoal);\nint calcHeuristic_single_tile(StateNode& stateStart, StateNode& stateGoal, int& rowStart, int& colStart);\nvoid calcHeuristic_based_on_parent(StateNode& parentNode, StateNode& childNode);\nvoid swap_blankTile_nonBlankTile(StateNode& parentNode, StateNode& childNode);\nvoid output_traced_solution(StateNode& terminal);\nvoid output_expansionOrder(void);\nint expandNode_WNES_order(StateNode& parentNode);\nbool A_Star_search(StateNode& solutionNode);\nvoid welcome_menu(void);\n//////////////GLOBAL VARIABLES//////////////\nint initialize_hashTableSize = 300; //use this to set hash table size in the event that solution is found but cannot be traced due to rehash() function needing to be called and making parent pointers bad\nminHeapPQ<StateNode> frontierSet_PQ;  //Frontier Set: all leaf nodes available for expansion at any given point (in time / during traversal).\nHashTable<StateNode> exploreSet_HashTable(initialize_hashTableSize);   //Use explored set to remember every expanded node to avoid redundant paths.\nStateNode stateGoal;\nStateNode stateStart;\nint searchLoop_Limitation;\nvector<StateNode> expansionOrder_vector; //track expansion order\n//////////////MAIN FUNCTION///////////////////\nint main()\n{\n    welcome_menu();\n    //initialize start state node"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\QuadraticProbing.cpp",
        "snippet": "//Hash Table function provided by Professor Dr. Junhua Guo -- UM-DEARBORN -- \n//Modfied by Demetrius Johnson --for CIS-350 Summer 2021 and CIS-479 Summer 2022\n//this version of the class was adapted for the Windy Puzzle Program 1 for CIS-479 with Doctor Shenquan Wang\n#include \"QuadraticProbing.h\"\n#include <iostream>\nusing namespace std;\n\n/**\n * Internal method to test if a positive number is prime.\n * Not an efficient algorithm.\n */\nbool isPrime( int n )\n{\n    if( n == 2 || n == 3 )\n        return true;\n\n    if( n == 1 || n % 2 == 0 )\n        return false;\n\n    for( int i = 3; i * i <= n; i += 2 )\n        if( n % i == 0 )\n            return false;\n\n    return true;\n}\n\n/**\n * Internal method to return a prime number at least as large as n.\n * Assumes n > 0.\n */\nint nextPrime( int n )\n{\n    if( n <= 0 )\n        n = 3;\n\n    if( n % 2 == 0 )\n        n++;\n\n    for( ; !isPrime( n ); n += 2 )\n        ;"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\StateNode.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: \n//Date Created: 7/15/22\n//Date Modified: \n\n\n#include \"StateNode.h\"\n\nStateNode::StateNode() {\n\n\theuristicVal = -1;\n\tpathCost = -1;\n\tEvalFunction = -1;\n\thash_string.resize(9);\n\tparent = nullptr; //pointer works so that you can trace back to root; but rehash function causes this program to fail; safegaurd placed in main program.\n\n}\nvoid StateNode::setEval_value(void) { EvalFunction = (pathCost + heuristicVal); }\n\n//convert table values for a given node to a uniquely ordered string value\n//so that it can be used in the hash function (a part of the Quadratic Probing class)\nvoid StateNode::setHash_string(void) {\n\n\t\n\tint string_location = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\n\t\t\thash_string[string_location] = table[i][j] + 48;  //ASCII characters '0' - '9' begin at decimal 48\n\t\t\tstring_location++;\n\t\t}\n\t}\n}\n\n/////OPERATOR OVERLOADING///////\nbool StateNode::operator< (const StateNode& RHoperand) {\n\n\tif (EvalFunction < RHoperand.EvalFunction)\n\t\treturn true;\n\telse"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Project1-CIS-479-Meech\\Tested and Fully functional minHeap PQ files\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: creat a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 7/21/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n//As of 7/21/22: have fully tested this module through a test module program (minHeapPQ_testModule_prj). No known issues. Works as expected.\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\Project2-CIS-479-Meech",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\Project2-CIS-479-Meech\\MAIN_Project2-CIS-479-Meech.cpp",
      "CIS-479_firstAttempt_programs\\programming\\Project2-CIS-479-Meech\\Value_Iteration_BellmanEquation_meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Project2-CIS-479-Meech\\MAIN_Project2-CIS-479-Meech.cpp",
        "snippet": "\ufeff//MAIN_Project2-CIS-479-Meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius E Johnson\n//Purpose: Implement Robot Localization with the HMM (Hidden Markov Model) algorithm - CIS-479-Project2\n//Special Notes: Adapated some of my Value Iteration Bellman Equation Program\n//Date Created: 8/02/2022\n//Date Modified: 8/09/2022\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\n\n//note:\n//static keyword will make the variables go in the .DATA section at compile time and not on the run time stack --> which requires an instnace of table to be called\n//static variables therefore are shared by all objects of the class AND can be accessed even before an object of the class is declared.\nstruct table {\n\n    const static int numRows = 6; \n    const static int numCols = 7;\n    float tablePos_locationProb_prior[numRows][numCols];\n    float tablePos_locationProb_posterior[numRows][numCols];\n    void setPrior_toPosterior(void) {\n    \n        for (int i = 0; i < numRows; i++)\n            for (int j = 0; j < numCols; j++)\n                tablePos_locationProb_prior[i][j] = tablePos_locationProb_posterior[i][j];\n    }\n   \n};\n\nenum class Direction_Relative { NO_DIREC = 0, FORWARD = 1, LEFT = 2, RIGHT = 3 };\nenum class Direction_Cardinal { WEST = 1, NORTH = 2, EAST = 3, SOUTH = 4 };\nenum Location {OBSTACLE = 1, OPEN_SQUARE = 0};\n//////////////////GLOBAL VARIABLES//////////////////////////////////////////\ntable table_struct_global;\n\n//moving transition probabilities:\nconst float forward_probability = (float)0.8;     //move forward in desired direction = 80%"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Project2-CIS-479-Meech\\Value_Iteration_BellmanEquation_meech.cpp",
        "snippet": "//Value_Iteration_BellmanEquation_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n//Purposse:     //Value Iteration Program using the Bellman Equation\\n-for CIS-479 with Doctor Shengquan Wang\n                //Program Written to demonstrate Lecutre Slide 7 - Planning and Decision Making (slides 42-50)\n                \n//Date Created: 7/28/22\n//Date Modified: 7/28/22\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\nstruct table {\n\n    int tablePos_reward[3][4];\n    float utility_val[3][4];\n    int rewardVal = -3;\n    int selected_utility_val = 0;\n};\n\nenum class Direction { NO_DIREC = 0, FORWARD = 1, LEFT = 2, RIGHT = 3 };\nenum class Direction_Cardinal { WEST = 1, NORTH = 2, EAST = 3, SOUTH = 4 };\n\n//////////////////GLOBAL VARIABLES//////////////////////////////////////////\ntable table_struct_global;\nfloat forward_probability = 0.8;\nfloat left_probability = 0.1;\nfloat right_probability = 0.1;\nint num_Bellman_iterations = 0;\nint endState_1 = 100;\nint endState_2 = -100;\n/////////////////////FUNCTION DECLARATIONS/////////////////////////////////\nvoid outputTable_reward(table &table_struct);\nvoid outputTable_utility(table &table_struct);\nfloat expected_utility_WEST(int row, int col);\nfloat expected_utility_NORTH(int row, int col);\nfloat expected_utility_EAST(int row, int col);\nfloat expected_utility_SOUTH(int row, int col);"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\HW3_Q4_Value_Iteration_BellmanEquation_meech.cpp",
      "CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\original_Value_Iteration_BellmanEquation_meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\HW3_Q4_Value_Iteration_BellmanEquation_meech.cpp",
        "snippet": "\ufeff//Value_Iteration_BellmanEquation_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n//Purposse:     //Value Iteration Program using the Bellman Equation\\n-for CIS-479 with Doctor Shengquan Wang\n                //Program Written to demonstrate Lecutre Slide 7 - Planning and Decision Making (slides 42-50)\n//STATUS: WORKS; NO KNOWN ISSUES\n//Revised for HW3 Q4:\n\n/*\n\n\nWe still assume the wind comes from the north\nand the cost of one step is defined as follows (the reward will be the negation of the cost): \n1 for moving southward; \n2 for moving eastward or westward; 3 for moving northward.\nThe reward function R(s,a) will be the negative of the cost.\nWe also assume that the reward reaching at the goal is 80. \nSince the reward function R(s; a) here depends on both the state \nand the action taken at this state, all utility equations should be revised as:\n\nU(s) \u2190 max_a (R(s,a) + \u03b3 \u03a3s' P(s'|s,a) U(s'))\n\nWe choose \u03b3=1. We assume the initial utility at any state is 0 except for 80 at the goal state. \nWe perform one-iteration update of the utility of all states in this order: \na1, a2, ..., a5, b1, b2, ..., b5, c1, ..., c5, d1, d2, ..., d5. \nPlease give the updated utility at each state.\n\n\n*/\n                \n//Date Created: 08/05/22\n//Date Modified: 08/05/22\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cstdlib>\n\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\nstruct table {"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\original_Value_Iteration_BellmanEquation_meech.cpp",
        "snippet": "//Value_Iteration_BellmanEquation_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n//Purposse:     //Value Iteration Program using the Bellman Equation\\n-for CIS-479 with Doctor Shengquan Wang\n                //Program Written to demonstrate Lecutre Slide 7 - Planning and Decision Making (slides 42-50)\n                \n//Date Created: 7/28/22\n//Date Modified: 7/28/22\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\nstruct table {\n\n    int tablePos_reward[3][4];\n    float utility_val[3][4];\n    int rewardVal = -3;\n    int selected_utility_val = 0;\n};\n\nenum class Direction { NO_DIREC = 0, FORWARD = 1, LEFT = 2, RIGHT = 3 };\nenum class Direction_Cardinal { WEST = 1, NORTH = 2, EAST = 3, SOUTH = 4 };\n\n//////////////////GLOBAL VARIABLES//////////////////////////////////////////\ntable table_struct_global;\nfloat forward_probability = 0.8;\nfloat left_probability = 0.1;\nfloat right_probability = 0.1;\nint num_Bellman_iterations = 0;\nint endState_1 = 100;\nint endState_2 = -100;\n/////////////////////FUNCTION DECLARATIONS/////////////////////////////////\nvoid outputTable_reward(table &table_struct);\nvoid outputTable_utility(table &table_struct);\nfloat expected_utility_WEST(int row, int col);\nfloat expected_utility_NORTH(int row, int col);\nfloat expected_utility_EAST(int row, int col);\nfloat expected_utility_SOUTH(int row, int col);"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\officially working version source file\\HW3_Q4_Value_Iteration_BellmanEquation_meech.cpp",
        "snippet": "\ufeff//Value_Iteration_BellmanEquation_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n//Purposse:     //Value Iteration Program using the Bellman Equation\\n-for CIS-479 with Doctor Shengquan Wang\n                //Program Written to demonstrate Lecutre Slide 7 - Planning and Decision Making (slides 42-50)\n//STATUS: WORKS; NO KNOWN ISSUES\n//Revised for HW3 Q4:\n\n/*\n\n\nWe still assume the wind comes from the north\nand the cost of one step is defined as follows (the reward will be the negation of the cost): \n1 for moving southward; \n2 for moving eastward or westward; 3 for moving northward.\nThe reward function R(s,a) will be the negative of the cost.\nWe also assume that the reward reaching at the goal is 80. \nSince the reward function R(s; a) here depends on both the state \nand the action taken at this state, all utility equations should be revised as:\n\nU(s) \u2190 max_a (R(s,a) + \u03b3 \u03a3s' P(s'|s,a) U(s'))\n\nWe choose \u03b3=1. We assume the initial utility at any state is 0 except for 80 at the goal state. \nWe perform one-iteration update of the utility of all states in this order: \na1, a2, ..., a5, b1, b2, ..., b5, c1, ..., c5, d1, d2, ..., d5. \nPlease give the updated utility at each state.\n\n\n*/\n                \n//Date Created: 08/05/22\n//Date Modified: 08/05/22\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cstdlib>\n\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\nstruct table {"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\officially working version source file\\original_Value_Iteration_BellmanEquation_meech.cpp",
        "snippet": "//Value_Iteration_BellmanEquation_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n//Purposse:     //Value Iteration Program using the Bellman Equation\\n-for CIS-479 with Doctor Shengquan Wang\n                //Program Written to demonstrate Lecutre Slide 7 - Planning and Decision Making (slides 42-50)\n                \n//Date Created: 7/28/22\n//Date Modified: 7/28/22\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\nstruct table {\n\n    int tablePos_reward[3][4];\n    float utility_val[3][4];\n    int rewardVal = -3;\n    int selected_utility_val = 0;\n};\n\nenum class Direction { NO_DIREC = 0, FORWARD = 1, LEFT = 2, RIGHT = 3 };\nenum class Direction_Cardinal { WEST = 1, NORTH = 2, EAST = 3, SOUTH = 4 };\n\n//////////////////GLOBAL VARIABLES//////////////////////////////////////////\ntable table_struct_global;\nfloat forward_probability = 0.8;\nfloat left_probability = 0.1;\nfloat right_probability = 0.1;\nint num_Bellman_iterations = 0;\nint endState_1 = 100;\nint endState_2 = -100;\n/////////////////////FUNCTION DECLARATIONS/////////////////////////////////\nvoid outputTable_reward(table &table_struct);\nvoid outputTable_utility(table &table_struct);\nfloat expected_utility_WEST(int row, int col);\nfloat expected_utility_NORTH(int row, int col);\nfloat expected_utility_EAST(int row, int col);\nfloat expected_utility_SOUTH(int row, int col);"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\officially working version source file",
    "code_files": [
      "CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\officially working version source file\\HW3_Q4_Value_Iteration_BellmanEquation_meech.cpp",
      "CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\officially working version source file\\original_Value_Iteration_BellmanEquation_meech.cpp",
      "CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\officially working version source file\\Value_Iteration_BellmanEquation_officialWorkingVers_meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\officially working version source file\\HW3_Q4_Value_Iteration_BellmanEquation_meech.cpp",
        "snippet": "\ufeff//Value_Iteration_BellmanEquation_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n//Purposse:     //Value Iteration Program using the Bellman Equation\\n-for CIS-479 with Doctor Shengquan Wang\n                //Program Written to demonstrate Lecutre Slide 7 - Planning and Decision Making (slides 42-50)\n//STATUS: WORKS; NO KNOWN ISSUES\n//Revised for HW3 Q4:\n\n/*\n\n\nWe still assume the wind comes from the north\nand the cost of one step is defined as follows (the reward will be the negation of the cost): \n1 for moving southward; \n2 for moving eastward or westward; 3 for moving northward.\nThe reward function R(s,a) will be the negative of the cost.\nWe also assume that the reward reaching at the goal is 80. \nSince the reward function R(s; a) here depends on both the state \nand the action taken at this state, all utility equations should be revised as:\n\nU(s) \u2190 max_a (R(s,a) + \u03b3 \u03a3s' P(s'|s,a) U(s'))\n\nWe choose \u03b3=1. We assume the initial utility at any state is 0 except for 80 at the goal state. \nWe perform one-iteration update of the utility of all states in this order: \na1, a2, ..., a5, b1, b2, ..., b5, c1, ..., c5, d1, d2, ..., d5. \nPlease give the updated utility at each state.\n\n\n*/\n                \n//Date Created: 08/05/22\n//Date Modified: 08/05/22\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cstdlib>\n\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\nstruct table {"
      },
      {
        "file": "CIS-479_RETAKE\\CIS-479_firstAttempt_programs\\programming\\Value_Iteration_BellmanEquation_meech\\officially working version source file\\original_Value_Iteration_BellmanEquation_meech.cpp",
        "snippet": "//Value_Iteration_BellmanEquation_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n//Purposse:     //Value Iteration Program using the Bellman Equation\\n-for CIS-479 with Doctor Shengquan Wang\n                //Program Written to demonstrate Lecutre Slide 7 - Planning and Decision Making (slides 42-50)\n                \n//Date Created: 7/28/22\n//Date Modified: 7/28/22\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\nstruct table {\n\n    int tablePos_reward[3][4];\n    float utility_val[3][4];\n    int rewardVal = -3;\n    int selected_utility_val = 0;\n};\n\nenum class Direction { NO_DIREC = 0, FORWARD = 1, LEFT = 2, RIGHT = 3 };\nenum class Direction_Cardinal { WEST = 1, NORTH = 2, EAST = 3, SOUTH = 4 };\n\n//////////////////GLOBAL VARIABLES//////////////////////////////////////////\ntable table_struct_global;\nfloat forward_probability = 0.8;\nfloat left_probability = 0.1;\nfloat right_probability = 0.1;\nint num_Bellman_iterations = 0;\nint endState_1 = 100;\nint endState_2 = -100;\n/////////////////////FUNCTION DECLARATIONS/////////////////////////////////\nvoid outputTable_reward(table &table_struct);\nvoid outputTable_utility(table &table_struct);\nfloat expected_utility_WEST(int row, int col);\nfloat expected_utility_NORTH(int row, int col);\nfloat expected_utility_EAST(int row, int col);\nfloat expected_utility_SOUTH(int row, int col);"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "homework\\hw4\\hw4_summer2022\\CIS-479_HW4_Q1_MarkovChain_Meech",
    "code_files": [
      "homework\\hw4\\hw4_summer2022\\CIS-479_HW4_Q1_MarkovChain_Meech\\CIS-479_RETAKE_HW4_Q1_MarkovChain_Meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\homework\\hw4\\hw4_summer2022\\CIS-479_HW4_Q1_MarkovChain_Meech\\CIS-479_RETAKE_HW4_Q1_MarkovChain_Meech.cpp",
        "snippet": "\ufeff// CIS-479_HW4_Q1_MarkovChain_Meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n// Purpose: Find probabilities from a Markov Chain data model; for CIS 479 SUMMER II With Dr. Shengquan Wang\n//Date Created: 8/13/22\n//Date Modified: 12/06/22  --> modified for HWW1_CIS-479_RETAKE - this is my second attempt in this course; I am using my programs I wrote for hw from SUMMER 2022\n\n\n/*\n\n\nWe consider a 3-state (a, b, c) Markov Chain. \n\nWe observe the following sequence of data: \nb a a b a b c c b c a b c c a b c c a c b c a b c c b b b a b c. (# of data points collected = 32).\n\nPlease use MLE and Laplace Smoothing with k = 2 to learn the following transition probabilities: \nP(a|a), P(b|a), P(c|a), P(a|b), P(b|b), P(c|b), P(a|c), P(b|c), P(c|c).\n\n\nMLE of \ud835\udc5d_\ud835\udc5a under Laplace Smoothing with k:\n\ud835\udc5d_\ud835\udc5a^\u2217=(\ud835\udc41_\ud835\udc5a+\ud835\udc58)/(\ud835\udc41+\ud835\udc58\u2217\ud835\udc40)\n\ud835\udc41_\ud835\udc5a is the occurrence of data in Category m.\u00a0\n\ud835\udc41 is the total number of data items.\n\n\n*/\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n\tcout << \"\\n HW4_Q1: Find probabilities from a Markov Chain data model; for CIS 479_RETAKE FALL 2022 With Dr. Shenguan Wang\\n--BY Demetrius Johnson\\n\\n\";\n\n\tstring data_string = \"b a a b a b c c b c a b c c a b c c a c b c a b c c b b b a b c\";\n\n\t//delete all spaces in the data squence:\n\tfor (int i = 0; i < data_string.size(); i++) {"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "homework\\hw4\\hw4_summer2022\\EM_Algorithm_HW4_Q7-CIS-479_meech",
    "code_files": [
      "homework\\hw4\\hw4_summer2022\\EM_Algorithm_HW4_Q7-CIS-479_meech\\EM_Algorithm_HW4_Q7-CIS-479_meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\homework\\hw4\\hw4_summer2022\\EM_Algorithm_HW4_Q7-CIS-479_meech\\EM_Algorithm_HW4_Q7-CIS-479_meech.cpp",
        "snippet": "\ufeff// EM_Algorithm_HW4_Q7-CIS-479_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson (Meech)\n//Purpose: Create the Exepectation Maximization (EM) algorithm in order to answer question 7 from HW4, CIS-479 SUMMER II with DR. Shengquan Wang\n//Date created: 8/17/22\n//Date Modified: 8/18/22\n\n#include <iostream>\n#include <stdlib.h>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\n\n/*\n\nWe have the following six 1D data_set points: 1.6, 2.1, 1.8, 5.3, 6.7, 4.7. \nWe consider EM with two components with the following initial setup: \n\u03c0_1 = 0.4, \u00b5_1 = 1, (\u03c3_1)^2 = 2, \u03c0_2 = 0.6, \u00b5_2 = 2, (\u03c3_2)^2 = 2, \nwhere \u03c0_k = weight of a cluster on all data_set pts, \u00b5_k = mean value of a cluster, \u03c3_k = standard deviation of a cluster.\nPlease find the updated values of these 6 variables after one iteration using EM.\n*/\n\n/*\n////////////////////NOTES BEGIN//////////////////////////////////////////////\n\nGuassian Distribution function with d demensions, where T is the transpose matrix (necessary for dimensions of d=3 or greater), \u00b5=mean, \ud835\udf2e=standard deviation:\n\nP(x | \u00b5, \ud835\udf2e) =  \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99) = (  exp\u2061( (\u22121/2) * (\ud835\udc99\u2212\ud835\udf41)^\ud835\udc47 * \u03a3^(\u22121) * (\ud835\udc99\u2212\ud835\udf41) )  ) / sqrt( (2\ud835\udf0b)^\ud835\udc51 * |\ud835\udf2e|) --> |\ud835\udf2e| = magintiude of matrix \ud835\udf2e, \u03a3^(\u22121) = inverse of matrix \u03a3\n\n-->for 1 dimension (d=1), the Gaussian Distribution Function simplifies to:\nP(x | \u00b5, \ud835\udf2e) =  \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99) = (  exp\u2061( (\u22121/2) * (\ud835\udc99\u2212\ud835\udf41)^(2) * \u03a3^(-2) )  ) / sqrt( (2\ud835\udf0b) * \ud835\udf2e^(2) )\n\n\nThus, for Guassian Learning with MLE (max likelihood estimation):\n\n\ud835\udc5d(\ud835\udc99_1,\u2026,\ud835\udc99_\ud835\udc41 ) = \u220f_\ud835\udc5b( \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99_\ud835\udc5b) ), where \ud835\udc41(\ud835\udf41,\ud835\udf2e)(\ud835\udc99_n) represents the distribution function given a population N as shown above.\n\nNOTE: N refers to distribution given a population for the above f(x), it is not multiplied; it just represents an f(x) given a mean and standard deviation for any input x essentially."
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "homework\\hw4\\hw4_summer2022\\K-MeansAlgorithm_HW4_Q6-CIS-479_meech",
    "code_files": [
      "homework\\hw4\\hw4_summer2022\\K-MeansAlgorithm_HW4_Q6-CIS-479_meech\\K-MeansAlgorithm_HW4_Q6-CIS-479_meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\homework\\hw4\\hw4_summer2022\\K-MeansAlgorithm_HW4_Q6-CIS-479_meech\\K-MeansAlgorithm_HW4_Q6-CIS-479_meech.cpp",
        "snippet": "// K-MeansAlgorithm_HW4_Q6-CIS-479_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson (Meech)\n//Purpose: Create a K-Means algorithm in order to answer question 6 from HW4, CIS-479 SUMMER II with DR. Shengquan Wang\n//Date created: 8/16/22\n//Date Modified: 8/17/22\n/*\n\nWe have the following eight 2D data points:\nX          Y\n24.5     3.5\n26.5     7.0\n21.5     7.5\n25.0    15.5\n2.5     20.5\n9.5     23.0\n11.0    20.0\n21.5     4.0\nTwo initial centroids (12.0, 12.5), (15.0, 15.5). Please find the next two centroids after one iteration using K-means\nwith K = 2 and Euclidean distance.\n\n\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <iomanip>\nusing namespace std;\n\n/////////////////FUNCTION DECLARATIONS, STRUCTS, ENUM DECLARATIONS, GLOBAL VAR//////////////////////////////\nstruct XY_coord { float x; float y; };\nint numDataPts = 0;\nint numUpdatesPerformed = 0;\nint K = 2;\n\nbool init_data_array(vector<XY_coord>& data_array);\nvoid calc_Euclidean_distances(vector<XY_coord>& data_array, XY_coord& centroid, vector<float>& E_array);"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "programming\\CIS-479_RETAKE_HW3",
    "code_files": [
      "programming\\CIS-479_RETAKE_HW3\\HW3_Q4_Value_Iteration_BellmanEquation_meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\programming\\CIS-479_RETAKE_HW3\\HW3_Q4_Value_Iteration_BellmanEquation_meech.cpp",
        "snippet": "\ufeff//Value_Iteration_BellmanEquation_meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius Johnson\n//Purposse:     //Value Iteration Program using the Bellman Equation\\n-for CIS-479 with Doctor Shengquan Wang\n                //Program Written to demonstrate Lecutre Slide 7 - Planning and Decision Making (slides 42-50)\n//STATUS: WORKS; NO KNOWN ISSUES\n//Revised for HW3 Q4 (retake): 11/12/22\n\n/*\n\n\nWe still assume the wind comes from the north\nand the cost of one step is defined as follows (the reward will be the negation of the cost): \n1 for moving southward; \n2 for moving eastward or westward; 3 for moving northward.\nThe reward function R(s,a) will be the negative of the cost.\nWe also assume that the reward reaching at the goal is 80. \nSince the reward function R(s; a) here depends on both the state \nand the action taken at this state, all utility equations should be revised as:\n\nU(s) \u2190 max_a (R(s,a) + \u03b3 \u03a3s' P(s'|s,a) U(s'))\n\nWe choose \u03b3=1. We assume the initial utility at any state is 0 except for 80 at the goal state. \nWe perform one-iteration update of the utility of all states in this order: \na1, a2, ..., a5, b1, b2, ..., b5, c1, ..., c5, d1, d2, ..., d5. \nPlease give the updated utility at each state.\n\n\n*/\n                \n//Date Created: 08/05/22\n//Date Modified: 11/12/22\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cstdlib>\n\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\nstruct table {"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "programming\\P1\\CIS-479_RETAKE-P1-MEECH",
    "code_files": [
      "programming\\P1\\CIS-479_RETAKE-P1-MEECH\\MAIN-CIS-479_RETAKE-P1-MEECH.cpp",
      "programming\\P1\\CIS-479_RETAKE-P1-MEECH\\minHeapPQ.cpp",
      "programming\\P1\\CIS-479_RETAKE-P1-MEECH\\QuadraticProbing.cpp",
      "programming\\P1\\CIS-479_RETAKE-P1-MEECH\\StateNode.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\programming\\P1\\CIS-479_RETAKE-P1-MEECH\\MAIN-CIS-479_RETAKE-P1-MEECH.cpp",
        "snippet": "// CIS-479_RETAKE-P1-MEECH.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n//Author: Demetrius E Johnson\n//Purpose: Implement the A* Search and Iterative Deepening Search (IDS) algorithms\n//Date Created: 7/15/22\n//Date Modified: \n\n//CIS-479: Windy Maze Problem (North wind)\n\n/*  [] = blank tile, #= wall obstacle, 0 = initial state, G = goal state\n\n\n    []      []     []     []     []    \n\n    []      #       #     []     []\n\n    []      #       G     []     []\n\n    0       #       #     []     []\n\n    []      #       []    []     []\n\n    []      []      []    []     []\n\n    Move North (against wind) cost = 3.\n    Move South (with wind) cost = 1.\n    Move East or West (side wind) cost = 2.\n\n    //special notes: each valid location is a state.\n    \n\n*/\n\n#include <iostream>\n#include \"FIFO.h\"\n#include \"StateNode.h\"\n#include \"minHeapPQ.h\"\n#include \"minHeapPQ.cpp\"\n#include \"QuadraticProbing.h\""
      },
      {
        "file": "CIS-479_RETAKE\\programming\\P1\\CIS-479_RETAKE-P1-MEECH\\minHeapPQ.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: create a min heap priority queue template class so I can use it for my MST program and for future uses\n//Date Created: 7/25/21\n//Date Modified: 9/19/22\n//New adaptation: added functions to support my CIS-479 P1 windy maze puzzle A* search program\n\n\n //note: minHeapPQ is a template class. There are two solutions to avoid FATAL LINK ERROR:\n//1) Place do not include cpp file in the project, only include the header, and add #include .cpp at end of header file, \n//then just #include the .h file in the main program source file.\n//2)just #include the .h and the cpp files of the header in the main program source file.\n//**for this situation, I tested both cases (they both work!), and decided to go with option 1 for this test project.\n#include \"minHeapPQ.h\"\n\n//pq using an array\n//min will always be at root\n//chidlren will be greater than their parent\n//i has children 2i and 2i+1 (left and right child, respectively)\n//i has parent i/2\n//start of a priority queue using a heap structure is at index i = 1 (not index 0; index 0 is place holder)\n//note: since start of heap is nullObject placeholder (index 0 = null element), then size of heap == will always return 1; thus true heap size is heapSize - 1\n\ntemplate<typename T>\nminHeapPQ<T>::minHeapPQ() {\n\n\tvectorPtr = &heapArray;\n\tparent = -1;\n\tleftChild = -1;\n\trightChild = -1;\n\tcurrentPos = -1;\n\theapArray.push_back(nullObject); //element 0 is a placeholder holding a T object that will be ignored /treated as null\n\n}\n\ntemplate<typename T>\nvoid minHeapPQ<T>::insert(T insertElement) {\n\n\t//remember, element 1 is a placeholder; so size == 1 means element 0 == nullObject\n\tif (heapArray.size() == 1) { //case: first element to be added to queue; simply add it and exit function"
      },
      {
        "file": "CIS-479_RETAKE\\programming\\P1\\CIS-479_RETAKE-P1-MEECH\\QuadraticProbing.cpp",
        "snippet": "//Hash Table function provided by Professor Dr. Junhua Guo -- UM-DEARBORN -- \n//Modfied by Demetrius Johnson --for CIS-350 Summer 2021 and CIS-479 Summer 2022 and CIS-479 Fall 2022 \n// most recent modification:  9/19/22\n//this version of the class was adapted for the Windy Puzzle Program 1 for CIS-479 with Doctor Shenquan Wang\n#include \"QuadraticProbing.h\"\n#include <iostream>\nusing namespace std;\n\n/**\n * Internal method to test if a positive number is prime.\n * Not an efficient algorithm.\n */\nbool isPrime( int n )\n{\n    if( n == 2 || n == 3 )\n        return true;\n\n    if( n == 1 || n % 2 == 0 )\n        return false;\n\n    for( int i = 3; i * i <= n; i += 2 )\n        if( n % i == 0 )\n            return false;\n\n    return true;\n}\n\n/**\n * Internal method to return a prime number at least as large as n.\n * Assumes n > 0.\n */\nint nextPrime( int n )\n{\n    if( n <= 0 )\n        n = 3;\n\n    if( n % 2 == 0 )\n        n++;\n\n    for( ; !isPrime( n ); n += 2 )"
      },
      {
        "file": "CIS-479_RETAKE\\programming\\P1\\CIS-479_RETAKE-P1-MEECH\\StateNode.cpp",
        "snippet": "//Author: Demetrius E Johnson\n//Purpose: adapted from my program I wrote in SUMMER II CIS-479 with Dr. Wang\n//Date Created: 7/15/22\n//Date Modified: 9/19/22\n//note: each location in the windy maze is a state.\n\n#include \"StateNode.h\"\n\n//default constructor\nStateNode::StateNode() {\n\t\n\trow_location = -1;\n\tcol_location = -1;\n\theuristicVal = -1;\n\tpathCost = -1;\n\tEvalFunction = -1;\n\ttie_breaker.evalFx_val = -1;\n\ttie_breaker.insert_order_val = -1;\n\thash_string.resize(2); //I will convert the coordinates of a state into a string of size 2. For example, location (i,j) = (1,2), the string= \"12\".\n\tparent = nullptr; //pointer works so that you can trace back to root; but rehash function causes this program to fail; safegaurd placed in main program.\n\n}\n\n//set eval function = path cost + hueristic value\nvoid StateNode::setEval_value(void) { \n\t\n\t\n\tEvalFunction = (pathCost + heuristicVal);\n\ttie_breaker.evalFx_val = EvalFunction; //also set this so we can use it for the FIFO hash table tracker\n}\n\n//convert table values for a given node to a uniquely ordered string value\n//so that it can be used in the hash function (a part of the Quadratic Probing class)\nvoid StateNode::setHash_string(void) {\n\n\t\thash_string[0] = row_location + 48;  //ASCII characters '0' - '9' begin at decimal 48\n\t\thash_string[1] = col_location + 48;  //ASCII characters '0' - '9' begin at decimal 48\n\n}"
      }
    ]
  },
  {
    "repo": "CIS-479_RETAKE",
    "folder": "programming\\P2\\CIS-479_RETAKE-P2-MEECH",
    "code_files": [
      "programming\\P2\\CIS-479_RETAKE-P2-MEECH\\MAIN_Project2-CIS-479_RETAKE-Meech.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-479_RETAKE\\programming\\P2\\CIS-479_RETAKE-P2-MEECH\\MAIN_Project2-CIS-479_RETAKE-Meech.cpp",
        "snippet": "\ufeff//MAIN_Project2-CIS-479_RETAKE-Meech.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//Author: Demetrius E Johnson\n//Purpose: Implement Robot Localization with the HMM (Hidden Markov Model) algorithm - CIS-479-Project2\n//Special Notes: Adapated some of my Value Iteration Bellman Equation Program and from my P2 from my first and failed attempt to pass CIS-479 in Summer II 2022 semester with same professor. \n    //I did however received 100% on this program.\n//Date Created: 10/28/2022\n//Date Modified: 10/28/2022\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n///////DATA STRUCTURES && ENUMERATORS////////////////////////////////////////////////////\n\n\n//note:\n//static keyword will make the variables go in the .DATA section at compile time and not on the run time stack --> which requires an instance of table to be called\n//static variables therefore are shared by all objects of the class AND can be accessed even before an object instance of the class is declared/created.\nstruct table {\n\n    const static int numRows = 6; \n    const static int numCols = 7;\n    float tablePos_locationProb_prior[numRows][numCols];\n    float tablePos_locationProb_posterior[numRows][numCols];\n    void setPrior_toPosterior(void) {\n    \n        for (int i = 0; i < numRows; i++)\n            for (int j = 0; j < numCols; j++)\n                tablePos_locationProb_prior[i][j] = tablePos_locationProb_posterior[i][j];\n    }\n};\n\nenum class Direction_Relative { NO_DIREC = 0, FORWARD = 1, LEFT = 2, RIGHT = 3 };\nenum class Direction_Cardinal { WEST = 1, NORTH = 2, EAST = 3, SOUTH = 4 };\nenum Location {OBSTACLE = 1, OPEN_SQUARE = 0};\n//////////////////GLOBAL VARIABLES//////////////////////////////////////////\ntable table_struct_global;\n\n//moving transition probabilities:\nconst float forward_probability = (float)0.8;   //move forward in desired direction = 80%"
      }
    ]
  }
]