[
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\OpenCV\\DroneRedDetect_OpenCV",
    "code_files": [
      "Client - Dr Song\\OpenCV\\DroneRedDetect_OpenCV\\RedDetect_drone-SD1_demo-v1.py",
      "Client - Dr Song\\OpenCV\\DroneRedDetect_OpenCV\\RedDetect_drone-SD1_demo-v2.py",
      "Client - Dr Song\\OpenCV\\DroneRedDetect_OpenCV\\RedDetect_drone-SD1_demo-v3.py",
      "Client - Dr Song\\OpenCV\\DroneRedDetect_OpenCV\\RedDetect_drone.py",
      "Client - Dr Song\\OpenCV\\DroneRedDetect_OpenCV\\RedDetect_drone_showHSV.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\OpenCV\\DroneRedDetect_OpenCV\\RedDetect_drone-SD1_demo-v1.py",
        "snippet": "import rospy\nimport cv2\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\n\nrospy.init_node('red_object_detection')\nbridge = CvBridge()\n\n# Create a publisher to publish the video feed to a ROS topic\nimage_pub = rospy.Publisher('red_object_detection/image_raw', Image, queue_size=10)\n\ndef detect_red(cv_image):\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)\n\n    # Define the range of red color in HSV\n    lower_red = (0, 50, 50)\n    upper_red = (10, 255, 255)\n    mask1 = cv2.inRange(hsv, lower_red, upper_red)\n\n    lower_red = (170, 50, 50)\n    upper_red = (180, 255, 255)\n    mask2 = cv2.inRange(hsv, lower_red, upper_red)\n\n    # Combine the masks to obtain the final mask\n    mask = mask1 + mask2\n\n    # Apply the mask to the original image\n    res = cv2.bitwise_and(cv_image, cv_image, mask=mask)\n\n    return res\n\n\ndef image_callback(data):\n    # Convert the ROS image message to an OpenCV image\n    cv_image = bridge.imgmsg_to_cv2(data, 'bgr8')\n\n    # Detect the red objects in the image\n    red_image = detect_red(cv_image)"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\OpenCV\\DroneRedDetect_OpenCV\\RedDetect_drone-SD1_demo-v2.py",
        "snippet": "import rospy\nimport cv2\nimport numpy as np\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\n\nrospy.init_node('red_object_detection')\nbridge = CvBridge()\n\n# Create a publisher to publish the video feed to a ROS topic\nimage_pub = rospy.Publisher('red_object_detection/image_raw', Image, queue_size=10)\n\ndef detect_red(cv_image):\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)\n\n    # Define the range of red color in HSV\n    lower_red = (0, 50, 50)\n    upper_red = (10, 255, 255)\n    mask1 = cv2.inRange(hsv, lower_red, upper_red)\n\n    lower_red = (170, 50, 50)\n    upper_red = (180, 255, 255)\n    mask2 = cv2.inRange(hsv, lower_red, upper_red)\n\n    # Combine the masks to obtain the final mask\n    mask = mask1 + mask2\n\n    return mask\n\ndef draw_bounding_boxes(cv_image, mask, min_area=500):\n    # Find contours in the mask\n    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    # Iterate through the contours\n    for contour in contours:\n        # Calculate the area of the contour\n        area = cv2.contourArea(contour)\n\n        # Filter contours based on the minimum area"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\OpenCV\\DroneRedDetect_OpenCV\\RedDetect_drone-SD1_demo-v3.py",
        "snippet": "import rospy\nimport cv2\nimport numpy as np\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\n\nrospy.init_node('red_object_detection')\nbridge = CvBridge()\n\n# Create a publisher to publish the video feed to a ROS topic\nimage_pub = rospy.Publisher('red_object_detection/image_raw', Image, queue_size=10)\n\ndef detect_red(cv_image):\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)\n\n    # Define the range of red color in HSV (red has 2 ranges) --> format is (hue, saturation, value (brightness))\n    #lower range: 0-10 for hue for color red\n    lower_red = (0, 240, 50)\n    upper_red = (8, 255, 255)\n    mask1 = cv2.inRange(hsv, lower_red, upper_red)\n\n    #upper range: 170-180 for hue for color red\n    lower_red = (170, 160, 60)\n    upper_red = (175, 255, 80)\n    mask2 = cv2.inRange(hsv, lower_red, upper_red)\n\n    # Combine the masks to obtain the final mask\n    mask = mask1 + mask2\n\n    return mask\n\ndef draw_bounding_boxes(cv_image, mask, min_area=1000, max_area=10000): #min and max area determine size of detected objects to draw bounding boxes around\n    # Find contours in the mask\n    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    # Iterate through the contours\n    for contour in contours:\n        # Calculate the area of the contour\n        area = cv2.contourArea(contour)"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\OpenCV\\DroneRedDetect_OpenCV\\RedDetect_drone.py",
        "snippet": "import numpy\nimport cv2\n\npos = (300,100)\nfont = cv2.FONT_HERSHEY_SIMPLEX\nfontScale = 3\ncolor = (250,250,250)\nthickness = 5\n\nlowColorVal1 = numpy.array([170, 160, 60])\nhighColorVal1 = numpy.array([175, 255, 80])\nlowColorVal2 = numpy.array([0, 240, 255])\nhighColorVal2 = numpy.array([3, 255, 255])\n\ncam = cv2.VideoCapture(0)\n\nif not cam.isOpened():\n    print(\"Cannot open camera\")\n    exit()\n\ncv2.namedWindow('frame',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('frame',960,540)\ncv2.namedWindow('mask',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('mask',960,540)\nkernel = numpy.ones((13,13),numpy.uint8)\n\nwhile True:\n    # Capture frame-by-frame\n    ret, frame = cam.read()\n\n    if not ret:\n        print(\"Can't receive frame (stream end?). Exiting ...\")\n        break\n    \n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    final = frame.copy()\n    \n    mask1 = cv2.inRange(hsv, lowColorVal1, highColorVal1)\n    mask2 = cv2.inRange(hsv, lowColorVal2, highColorVal2)\n    mask = mask1+mask2"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\OpenCV\\DroneRedDetect_OpenCV\\RedDetect_drone_showHSV.py",
        "snippet": "import numpy\nimport cv2\n\npos = (300,100)\nfont = cv2.FONT_HERSHEY_SIMPLEX\nfontScale = 3\ncolor = (250,250,250)\nthickness = 5\n\n#Color\tHue Range for color RED - it has two ranges, a higher range, and alowe range\n#Red:\tlower range: 0-10, higher range: 170-180\n\nlowColorVal1 = numpy.array([170, 160, 60])\nhighColorVal1 = numpy.array([175, 255, 80])\nlowColorVal2 = numpy.array([0, 255, 255])\nhighColorVal2 = numpy.array([1, 255, 255])\n\ncam = cv2.VideoCapture(0)\n\nif not cam.isOpened():\n    print(\"Cannot open camera\")\n    exit()\n\ncv2.namedWindow('frame',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('frame',960,540)\ncv2.namedWindow('mask',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('mask',960,540)\nkernel = numpy.ones((13,13),numpy.uint8)\n\nwhile True:\n    # Capture frame-by-frame\n    ret, frame = cam.read()\n\n    if not ret:\n        print(\"Can't receive frame (stream end?). Exiting ...\")\n        break\n    \n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    final = frame.copy()"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\OpenCV\\Jonathan Test Code",
    "code_files": [
      "Client - Dr Song\\OpenCV\\Jonathan Test Code\\cvtest.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\OpenCV\\Jonathan Test Code\\cvtest.py",
        "snippet": "import numpy\nimport cv2\n\npos = (300,100)\nfont = cv2.FONT_HERSHEY_SIMPLEX\nfontScale = 3\ncolor = (250,250,250)\nthickness = 5\n\nlowColorVal1 = numpy.array([167, 45, 45])\nhighColorVal1 = numpy.array([180, 255, 255])\nlowColorVal2 = numpy.array([0, 45, 45])\nhighColorVal2 = numpy.array([3, 255, 255])\n#img = cv2.imread(\"cube.jpg\")\ncam = cv2.VideoCapture(\"red.mp4\")\n#if img is None:\n#    print(\"Cannot open image\")\n#    exit()\nif not cam.isOpened():\n    print(\"Cannot open camera\")\n    exit()\n\n#cv2.imshow(\"red\",img)\n#hsvimg = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n#mask = cv2.inRange(hsvimg, lowColorVal, highColorVal)\n#cv2.imshow(\"hsv\",hsvimg)\n#cv2.imshow(\"maskred\",mask)\n#cv2.waitKey(0)\n#cv2.destroyAllWindows()\n#exit()\ncv2.namedWindow('frame',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('frame',960,540)\ncv2.namedWindow('mask',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('mask',960,540)\nkernel = numpy.ones((13,13),numpy.uint8)\nwhile True:\n    # Capture frame-by-frame\n    good, frame = cam.read()\n    # if frame is read correctly ret is True\n    if not good:"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\OpenCV\\Olivia Test Code",
    "code_files": [
      "Client - Dr Song\\OpenCV\\Olivia Test Code\\yellow.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\OpenCV\\Olivia Test Code\\yellow.py",
        "snippet": "#  Importing the libraries OpenCV and numpy\nimport cv2\nimport numpy as np\n\n# Read the images\nimg = cv2.imread(\"starry_night.jpg\")\n\n# Resizing the image\nimage = cv2.resize(img, (700, 600))\n\n# Convert Image to Image HSV\nhsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n# Defining lower and upper bound HSV values\nlower = np.array([20, 100, 100])\nupper = np.array([30, 255, 255])\n\n# Defining mask for detecting color\nmask = cv2.inRange(hsv, lower, upper)\n\n# Display Image and Mask\ncv2.imshow(\"Image\", image)\ncv2.imshow(\"Mask\", mask)\n\n# Make python sleep for unlimited time\ncv2.waitKey(0)"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV",
    "code_files": [
      "Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\cvtest.py",
      "Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\RedDetect_drone-SD1_demo-v1.py",
      "Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\RedDetect_drone-SD1_demo-v2.py",
      "Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\RedDetect_drone-SD1_demo-v3.py",
      "Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\RedDetect_drone.py",
      "Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\RedDetect_drone_showHSV.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\cvtest.py",
        "snippet": "import numpy\nimport cv2\n\npos = (300,100)\nfont = cv2.FONT_HERSHEY_SIMPLEX\nfontScale = 3\ncolor = (250,250,250)\nthickness = 5\n\nlowColorVal1 = numpy.array([167, 45, 45])\nhighColorVal1 = numpy.array([180, 255, 255])\nlowColorVal2 = numpy.array([0, 45, 45])\nhighColorVal2 = numpy.array([3, 255, 255])\n#img = cv2.imread(\"cube.jpg\")\ncam = cv2.VideoCapture(\"red.mp4\")\n#if img is None:\n#    print(\"Cannot open image\")\n#    exit()\nif not cam.isOpened():\n    print(\"Cannot open camera\")\n    exit()\n\n#cv2.imshow(\"red\",img)\n#hsvimg = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n#mask = cv2.inRange(hsvimg, lowColorVal, highColorVal)\n#cv2.imshow(\"hsv\",hsvimg)\n#cv2.imshow(\"maskred\",mask)\n#cv2.waitKey(0)\n#cv2.destroyAllWindows()\n#exit()\ncv2.namedWindow('frame',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('frame',960,540)\ncv2.namedWindow('mask',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('mask',960,540)\nkernel = numpy.ones((13,13),numpy.uint8)\nwhile True:\n    # Capture frame-by-frame\n    good, frame = cam.read()\n    # if frame is read correctly ret is True\n    if not good:"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\RedDetect_drone-SD1_demo-v1.py",
        "snippet": "import rospy\nimport cv2\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\n\nrospy.init_node('red_object_detection')\nbridge = CvBridge()\n\n# Create a publisher to publish the video feed to a ROS topic\nimage_pub = rospy.Publisher('red_object_detection/image_raw', Image, queue_size=10)\n\ndef detect_red(cv_image):\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)\n\n    # Define the range of red color in HSV\n    lower_red = (0, 50, 50)\n    upper_red = (10, 255, 255)\n    mask1 = cv2.inRange(hsv, lower_red, upper_red)\n\n    lower_red = (170, 50, 50)\n    upper_red = (180, 255, 255)\n    mask2 = cv2.inRange(hsv, lower_red, upper_red)\n\n    # Combine the masks to obtain the final mask\n    mask = mask1 + mask2\n\n    # Apply the mask to the original image\n    res = cv2.bitwise_and(cv_image, cv_image, mask=mask)\n\n    return res\n\n\ndef image_callback(data):\n    # Convert the ROS image message to an OpenCV image\n    cv_image = bridge.imgmsg_to_cv2(data, 'bgr8')\n\n    # Detect the red objects in the image\n    red_image = detect_red(cv_image)"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\RedDetect_drone-SD1_demo-v2.py",
        "snippet": "import rospy\nimport cv2\nimport numpy as np\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\n\nrospy.init_node('red_object_detection')\nbridge = CvBridge()\n\n# Create a publisher to publish the video feed to a ROS topic\nimage_pub = rospy.Publisher('red_object_detection/image_raw', Image, queue_size=10)\n\ndef detect_red(cv_image):\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)\n\n    # Define the range of red color in HSV\n    lower_red = (0, 50, 50)\n    upper_red = (10, 255, 255)\n    mask1 = cv2.inRange(hsv, lower_red, upper_red)\n\n    lower_red = (170, 50, 50)\n    upper_red = (180, 255, 255)\n    mask2 = cv2.inRange(hsv, lower_red, upper_red)\n\n    # Combine the masks to obtain the final mask\n    mask = mask1 + mask2\n\n    return mask\n\ndef draw_bounding_boxes(cv_image, mask, min_area=500):\n    # Find contours in the mask\n    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    # Iterate through the contours\n    for contour in contours:\n        # Calculate the area of the contour\n        area = cv2.contourArea(contour)\n\n        # Filter contours based on the minimum area"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\RedDetect_drone-SD1_demo-v3.py",
        "snippet": "import rospy\nimport cv2\nimport numpy as np\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\nimport sys\nsys.path.insert(0, '/home/pi/Python_files/SocketPrograms')\nimport client as connect\n\nrospy.init_node('red_object_detection')\nbridge = CvBridge()\nUSED = 0\n# Create a publisher to publish the video feed to a ROS topic\nimage_pub = rospy.Publisher('red_object_detection/image_raw', Image, queue_size=10)\n\ndef detect_red(cv_image):\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)\n\n    # Define the range of red color in HSV (red has 2 ranges) --> format is (hue, saturation, value (brightness))\n    #lower range: 0-10 for hue for color red\n    lower_red = (0, 100, 20)\n    upper_red = (10, 255, 255)\n    mask1 = cv2.inRange(hsv, lower_red, upper_red)\n\n    #upper range: 170-180 for hue for color red\n    lower_red = (160, 100, 20)\n    upper_red = (179, 255, 255)\n    mask2 = cv2.inRange(hsv, lower_red, upper_red)\n\n    # Combine the masks to obtain the final mask\n    mask = mask1 + mask2\n\n    return mask\n\ndef draw_bounding_boxes(cv_image, mask, min_area=1000, max_area=10000): #min and max area determine size of detected objects to draw bounding boxes around\n    # Find contours in the mask\n    global USED\n    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\RedDetect_drone.py",
        "snippet": "import numpy\nimport cv2\n\npos = (300,100)\nfont = cv2.FONT_HERSHEY_SIMPLEX\nfontScale = 3\ncolor = (250,250,250)\nthickness = 5\n\nlowColorVal1 = numpy.array([170, 160, 60])\nhighColorVal1 = numpy.array([175, 255, 80])\nlowColorVal2 = numpy.array([0, 240, 255])\nhighColorVal2 = numpy.array([3, 255, 255])\n\ncam = cv2.VideoCapture(0)\n\nif not cam.isOpened():\n    print(\"Cannot open camera\")\n    exit()\n\ncv2.namedWindow('frame',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('frame',960,540)\ncv2.namedWindow('mask',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('mask',960,540)\nkernel = numpy.ones((13,13),numpy.uint8)\n\nwhile True:\n    # Capture frame-by-frame\n    ret, frame = cam.read()\n\n    if not ret:\n        print(\"Can't receive frame (stream end?). Exiting ...\")\n        break\n    \n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    final = frame.copy()\n    \n    mask1 = cv2.inRange(hsv, lowColorVal1, highColorVal1)\n    mask2 = cv2.inRange(hsv, lowColorVal2, highColorVal2)\n    mask = mask1+mask2"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_CloverDrone\\RedOpenCV\\RedDetect_drone_showHSV.py",
        "snippet": "import numpy\nimport cv2\n\npos = (300,100)\nfont = cv2.FONT_HERSHEY_SIMPLEX\nfontScale = 3\ncolor = (250,250,250)\nthickness = 5\n\n#Color\tHue Range for color RED - it has two ranges, a higher range, and alowe range\n#Red:\tlower range: 0-10, higher range: 170-180\n\nlowColorVal1 = numpy.array([170, 160, 60])\nhighColorVal1 = numpy.array([175, 255, 80])\nlowColorVal2 = numpy.array([0, 255, 255])\nhighColorVal2 = numpy.array([1, 255, 255])\n\ncam = cv2.VideoCapture(0)\n\nif not cam.isOpened():\n    print(\"Cannot open camera\")\n    exit()\n\ncv2.namedWindow('frame',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('frame',960,540)\ncv2.namedWindow('mask',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('mask',960,540)\nkernel = numpy.ones((13,13),numpy.uint8)\n\nwhile True:\n    # Capture frame-by-frame\n    ret, frame = cam.read()\n\n    if not ret:\n        print(\"Can't receive frame (stream end?). Exiting ...\")\n        break\n    \n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    final = frame.copy()"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\PythonFiles_CloverDrone\\SocketPrograms",
    "code_files": [
      "Client - Dr Song\\PythonFiles_CloverDrone\\SocketPrograms\\drone_client.py",
      "Client - Dr Song\\PythonFiles_CloverDrone\\SocketPrograms\\server.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_CloverDrone\\SocketPrograms\\drone_client.py",
        "snippet": "# Ryan Sauer\n# CIS 427\n# Socket Program\n# This program is the client script for the yamotd protocol\n\nfrom socket import *\n\n\nSERVER_NAME = \"192.168.11.133\"                            # Server IP (User defiend)\nSERVER_PORT = 10600                         # Server Port (Predefined)\nCLIENT_SOCKET = socket(AF_INET, SOCK_STREAM)    # Client Socket Creation\n\n\ndef send_message(var):\n    CLIENT_SOCKET.connect((SERVER_NAME, SERVER_PORT))\n    CLIENT_SOCKET.send(str(var).encode())"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_CloverDrone\\SocketPrograms\\server.py",
        "snippet": "from socket import *\nfrom picarx import Picarx\nimport time\n\nHOSTNAME = socket.gethostname()                             # Server Hostname\nSERVER_NAME = socket.gethostbyname(HOSTNAME)                # Server IP (car)\nSERVER_PORT = 10600                                         # Server Port(Predefined)\nSPEED = 0                                                   # Global speed variable\nDEFAULT_SPEED = 0                                           # Default crusing speed\npx = Picarx()\n\ndef warning(var):\n    global SPEED\n    if var == 2:\n        if SPEED != 0:                                      # Slow car down by half\n            SPEED = SPEED / 2\n            px.forward(SPEED)\n    elif var == 3:\n        raise NotImplementedError                           # Turn car left\n    elif var == 4:\n        raise NotImplementedError                           # Turn car right\n    \ndef obstruction():\n    global SPEED\n    SPEED = 0\n    px.forward(SPEED)                                       # Stop car\n\ndef continueDriving():\n    global SPEED\n    global DEFAULT_SPEED\n    SPEED = DEFAULT_SPEED                                   # Restart car after stopping or slowing down\n    px.forward(SPEED)\n\n\ndef main():\n    SPEED = 0\n    px.forward(5)\n    SERVER_SOCKET = socket(AF_INET, SOCK_STREAM)                # Server socket creation\n    SERVER_SOCKET.bind((SERVER_NAME, SERVER_PORT))\n    SERVER_SOCKET.listen(1)"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\PythonFiles_CloverDrone\\StarryNightOpenCV",
    "code_files": [
      "Client - Dr Song\\PythonFiles_CloverDrone\\StarryNightOpenCV\\yellow.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_CloverDrone\\StarryNightOpenCV\\yellow.py",
        "snippet": "#  Importing the libraries OpenCV and numpy\nimport cv2\nimport numpy as np\n\n# Read the images\nimg = cv2.imread(\"starry_night.jpg\")\n\n# Resizing the image\nimage = cv2.resize(img, (700, 600))\n\n# Convert Image to Image HSV\nhsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n# Defining lower and upper bound HSV values\nlower = np.array([20, 100, 100])\nupper = np.array([30, 255, 255])\n\n# Defining mask for detecting color\nmask = cv2.inRange(hsv, lower, upper)\n\n# Display Image and Mask\ncv2.imshow(\"Image\", image)\ncv2.imshow(\"Mask\", mask)\n\n# Make python sleep for unlimited time\ncv2.waitKey(0)"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\PythonFiles_PiCarX\\Python_files\\Red OpenCV",
    "code_files": [
      "Client - Dr Song\\PythonFiles_PiCarX\\Python_files\\Red OpenCV\\cvtest.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_PiCarX\\Python_files\\Red OpenCV\\cvtest.py",
        "snippet": "import numpy\nimport cv2\n\npos = (300,100)\nfont = cv2.FONT_HERSHEY_SIMPLEX\nfontScale = 3\ncolor = (250,250,250)\nthickness = 5\n\nlowColorVal1 = numpy.array([167, 45, 45])\nhighColorVal1 = numpy.array([180, 255, 255])\nlowColorVal2 = numpy.array([0, 45, 45])\nhighColorVal2 = numpy.array([3, 255, 255])\n#img = cv2.imread(\"cube.jpg\")\ncam = cv2.VideoCapture(\"red.mp4\")\n#if img is None:\n#    print(\"Cannot open image\")\n#    exit()\nif not cam.isOpened():\n    print(\"Cannot open camera\")\n    exit()\n\n#cv2.imshow(\"red\",img)\n#hsvimg = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n#mask = cv2.inRange(hsvimg, lowColorVal, highColorVal)\n#cv2.imshow(\"hsv\",hsvimg)\n#cv2.imshow(\"maskred\",mask)\n#cv2.waitKey(0)\n#cv2.destroyAllWindows()\n#exit()\ncv2.namedWindow('frame',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('frame',960,540)\ncv2.namedWindow('mask',cv2.WINDOW_NORMAL)\ncv2.resizeWindow('mask',960,540)\nkernel = numpy.ones((13,13),numpy.uint8)\nwhile True:\n    # Capture frame-by-frame\n    good, frame = cam.read()\n    # if frame is read correctly ret is True\n    if not good:"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\PythonFiles_PiCarX\\Python_files\\Socket Programs",
    "code_files": [
      "Client - Dr Song\\PythonFiles_PiCarX\\Python_files\\Socket Programs\\client.py",
      "Client - Dr Song\\PythonFiles_PiCarX\\Python_files\\Socket Programs\\picar_server.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_PiCarX\\Python_files\\Socket Programs\\client.py",
        "snippet": "# Ryan Sauer\n# CIS 427\n# Socket Program\n# This program is the client script for the yamotd protocol\n\nfrom socket import *\n\n\nMSGS= [\"MSGGET\\n\", \"MSGSTORE\\n\", \"QUIT\\n\"]  # Predefined yamotd messages\nDELIM = '\\n'                                # Response Delim\n\nSERVER_NAME = \"\"                            # Server IP (User defiend)\nSERVER_PORT = 11427                         # Server Port (Predefined)\nCLIENT_SOCKET = socket(AF_INET, SOCK_STREAM)    # Client Socket Creation\n\n\n# Sends packet and decodes response\n# RETURNS: decoded server response\ndef send_packet(PACKET):\n    CLIENT_SOCKET.send(PACKET.encode())\n    server_packet = CLIENT_SOCKET.recv(1024)\n    server_message = server_packet.decode().split(DELIM)\n    return server_message\n\n\n# MSGGET Protocol\ndef get_pkt():\n    server_message = send_packet(MSGS[0])\n    if server_message[0] == '200 OK':           # If 200, print message\n        print(server_message[1])\n    else:                                       # Else print error\n        print(\"Error:\\n\" + server_message[0])\n    \n# MSGSTORE Protocol\ndef store_pkt(NEW_MESSAGE):\n    server_message = send_packet(MSGS[1])\n    if server_message[0] == '200 OK':           # If 200, send new message\n        server_message = send_packet(NEW_MESSAGE + '\\n')\n    else:                                       # Else print error\n        print(\"Error:\\n\" + server_message[0])"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_PiCarX\\Python_files\\Socket Programs\\picar_server.py",
        "snippet": "from socket import *\nfrom picarx import Picarx\nimport time\n\n                             # Server Hostname\nSERVER_NAME = \"192.168.11.133\"                # Server IP (car)\nSERVER_PORT = 10600                                         # Server Port(Predefined)\nSPEED = 0                                                   # Global speed variable\nDEFAULT_SPEED = 0                                           # Default crusing speed\npx = Picarx()\n\ndef warning(var):\n    global SPEED\n    if var == 2:\n        if SPEED != 0:                                      # Slow car down by half\n            SPEED = SPEED / 2\n            px.forward(SPEED)\n    elif var == 3:\n        raise NotImplementedError                           # Turn car left\n    elif var == 4:\n        raise NotImplementedError                           # Turn car right\n    \ndef obstruction():\n    global SPEED\n    SPEED = 0\n    px.forward(SPEED)                                       # Stop car\n\ndef continueDriving():\n    global SPEED\n    global DEFAULT_SPEED\n    SPEED = DEFAULT_SPEED                                   # Restart car after stopping or slowing down\n    px.forward(SPEED)\n\n\ndef main():\n    SPEED = 1\n    px.forward(SPEED)\n    SERVER_SOCKET = socket(AF_INET, SOCK_STREAM)                # Server socket creation\n    SERVER_SOCKET.bind((SERVER_NAME, SERVER_PORT))"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\PythonFiles_PiCarX\\Python_files\\Starry Night OpenCV",
    "code_files": [
      "Client - Dr Song\\PythonFiles_PiCarX\\Python_files\\Starry Night OpenCV\\yellow.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\PythonFiles_PiCarX\\Python_files\\Starry Night OpenCV\\yellow.py",
        "snippet": "#  Importing the libraries OpenCV and numpy\nimport cv2\nimport numpy as np\n\n# Read the images\nimg = cv2.imread(\"starry_night.jpg\")\n\n# Resizing the image\nimage = cv2.resize(img, (700, 600))\n\n# Convert Image to Image HSV\nhsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n# Defining lower and upper bound HSV values\nlower = np.array([20, 100, 100])\nupper = np.array([30, 255, 255])\n\n# Defining mask for detecting color\nmask = cv2.inRange(hsv, lower, upper)\n\n# Display Image and Mask\ncv2.imshow(\"Image\", image)\ncv2.imshow(\"Mask\", mask)\n\n# Make python sleep for unlimited time\ncv2.waitKey(0)"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\actionlib_msgs\\scripts",
    "code_files": [
      "Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\actionlib_msgs\\scripts\\genaction.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\actionlib_msgs\\scripts\\genaction.py",
        "snippet": "#! /usr/bin/env python\n# Copyright (c) 2009, Willow Garage, Inc.\n# All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n#     * Redistributions of source code must retain the above copyright\n#       notice, this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of the Willow Garage, Inc. nor the names of its\n#       contributors may be used to endorse or promote products derived from\n#       this software without specific prior written permission.\n# \n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n# Author: Stuart Glaser\n\nimport sys\ntry:\n    from cStringIO import StringIO\nexcept ImportError:\n    from io import StringIO\nimport re\nimport os, os.path\nimport errno\nfrom optparse import OptionParser"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs",
    "code_files": [
      "Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\setup.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\setup.py",
        "snippet": "from setuptools import setup\nfrom catkin_pkg.python_setup import generate_distutils_setup\n\nd = generate_distutils_setup(\n    ##  don't do this unless you want a globally visible script\n    # scripts=['bin/myscript'], \n    packages=['sensor_msgs'],\n    package_dir={'': 'src'}\n)\n\nsetup(**d)"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\src\\sensor_msgs\\point_cloud2.py",
        "snippet": "#!/usr/bin/env python\n\n# Software License Agreement (BSD License)\n#\n# Copyright (c) 2008, Willow Garage, Inc.\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# * Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n# * Redistributions in binary form must reproduce the above\n# copyright notice, this list of conditions and the following\n# disclaimer in the documentation and/or other materials provided\n# with the distribution.\n# * Neither the name of Willow Garage, Inc. nor the names of its\n# contributors may be used to endorse or promote products derived\n# from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\nfrom __future__ import print_function\n\n\"\"\"\nSerialization of sensor_msgs.PointCloud2 messages.\n\nAuthor: Tim Field"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\test\\main.cpp",
        "snippet": "/*\n * Software License Agreement (BSD License)\n *\n *  Copyright (c) 2013, Open Source Robotics Foundation\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.\n *   * Neither the name of Willow Garage, Inc. nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <gtest/gtest.h>\n\n#include <sensor_msgs/point_cloud2_iterator.h>\n\nTEST(sensor_msgs, PointCloud2Iterator)\n{"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\test\\test_image_encodings.cpp",
        "snippet": "/*\n * Software License Agreement (BSD License)\n *\n *  Copyright (c) 2016, Kentaro Wada.\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.\n *   * Neither the name of Willow Garage, Inc. nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <gtest/gtest.h>\n\n#include <sensor_msgs/image_encodings.h>\n\nTEST(sensor_msgs, NumChannels)\n{"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\src\\sensor_msgs",
    "code_files": [
      "Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\src\\sensor_msgs\\point_cloud2.py",
      "Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\src\\sensor_msgs\\__init__.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\src\\sensor_msgs\\point_cloud2.py",
        "snippet": "#!/usr/bin/env python\n\n# Software License Agreement (BSD License)\n#\n# Copyright (c) 2008, Willow Garage, Inc.\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# * Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n# * Redistributions in binary form must reproduce the above\n# copyright notice, this list of conditions and the following\n# disclaimer in the documentation and/or other materials provided\n# with the distribution.\n# * Neither the name of Willow Garage, Inc. nor the names of its\n# contributors may be used to endorse or promote products derived\n# from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\nfrom __future__ import print_function\n\n\"\"\"\nSerialization of sensor_msgs.PointCloud2 messages.\n\nAuthor: Tim Field"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\test",
    "code_files": [
      "Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\test\\main.cpp",
      "Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\test\\test_image_encodings.cpp"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\test\\main.cpp",
        "snippet": "/*\n * Software License Agreement (BSD License)\n *\n *  Copyright (c) 2013, Open Source Robotics Foundation\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.\n *   * Neither the name of Willow Garage, Inc. nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <gtest/gtest.h>\n\n#include <sensor_msgs/point_cloud2_iterator.h>\n\nTEST(sensor_msgs, PointCloud2Iterator)\n{"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\source code\\common_msgs-noetic-devel\\common_msgs-noetic-devel\\sensor_msgs\\test\\test_image_encodings.cpp",
        "snippet": "/*\n * Software License Agreement (BSD License)\n *\n *  Copyright (c) 2016, Kentaro Wada.\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.\n *   * Neither the name of Willow Garage, Inc. nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <gtest/gtest.h>\n\n#include <sensor_msgs/image_encodings.h>\n\nTEST(sensor_msgs, NumChannels)\n{"
      }
    ]
  },
  {
    "repo": "CIS-4951",
    "folder": "Client - Dr Song\\Team4_Song_SD1_Prototype_DemoFiles_4-26-23",
    "code_files": [
      "Client - Dr Song\\Team4_Song_SD1_Prototype_DemoFiles_4-26-23\\drone_client.py",
      "Client - Dr Song\\Team4_Song_SD1_Prototype_DemoFiles_4-26-23\\picar_server.py",
      "Client - Dr Song\\Team4_Song_SD1_Prototype_DemoFiles_4-26-23\\RedDetect_drone-SD1_demo-v3.py"
    ],
    "snippets": [
      {
        "file": "CIS-4951\\Client - Dr Song\\Team4_Song_SD1_Prototype_DemoFiles_4-26-23\\drone_client.py",
        "snippet": "# Ryan Sauer\n# CIS 427\n# Socket Program\n# This program is the client script for the yamotd protocol\n\nfrom socket import *\n\n\nSERVER_NAME = \"192.168.11.133\"                            # Server IP (User defiend)\nSERVER_PORT = 10600                         # Server Port (Predefined)\nCLIENT_SOCKET = socket(AF_INET, SOCK_STREAM)    # Client Socket Creation\n\n\ndef send_message(var):\n    CLIENT_SOCKET.connect((SERVER_NAME, SERVER_PORT))\n    CLIENT_SOCKET.send(str(var).encode())"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\Team4_Song_SD1_Prototype_DemoFiles_4-26-23\\picar_server.py",
        "snippet": "from socket import *\nfrom picarx import Picarx\nimport time\n\n                             # Server Hostname\nSERVER_NAME = \"192.168.11.133\"                # Server IP (car)\nSERVER_PORT = 10600                                         # Server Port(Predefined)\nSPEED = 0                                                   # Global speed variable\nDEFAULT_SPEED = 0                                           # Default crusing speed\npx = Picarx()\n\ndef warning(var):\n    global SPEED\n    if var == 2:\n        if SPEED != 0:                                      # Slow car down by half\n            SPEED = SPEED / 2\n            px.forward(SPEED)\n    elif var == 3:\n        raise NotImplementedError                           # Turn car left\n    elif var == 4:\n        raise NotImplementedError                           # Turn car right\n    \ndef obstruction():\n    global SPEED\n    SPEED = 0\n    px.forward(SPEED)                                       # Stop car\n\ndef continueDriving():\n    global SPEED\n    global DEFAULT_SPEED\n    SPEED = DEFAULT_SPEED                                   # Restart car after stopping or slowing down\n    px.forward(SPEED)\n\n\ndef main():\n    SPEED = 1\n    px.forward(SPEED)\n    SERVER_SOCKET = socket(AF_INET, SOCK_STREAM)                # Server socket creation\n    SERVER_SOCKET.bind((SERVER_NAME, SERVER_PORT))"
      },
      {
        "file": "CIS-4951\\Client - Dr Song\\Team4_Song_SD1_Prototype_DemoFiles_4-26-23\\RedDetect_drone-SD1_demo-v3.py",
        "snippet": "import rospy\nimport cv2\nimport numpy as np\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\nimport sys\nsys.path.insert(0, '/home/pi/Python_files/SocketPrograms')\nimport client as connect\n\nrospy.init_node('red_object_detection')\nbridge = CvBridge()\nUSED = 0\n# Create a publisher to publish the video feed to a ROS topic\nimage_pub = rospy.Publisher('red_object_detection/image_raw', Image, queue_size=10)\n\ndef detect_red(cv_image):\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)\n\n    # Define the range of red color in HSV (red has 2 ranges) --> format is (hue, saturation, value (brightness))\n    #lower range: 0-10 for hue for color red\n    lower_red = (0, 100, 20)\n    upper_red = (10, 255, 255)\n    mask1 = cv2.inRange(hsv, lower_red, upper_red)\n\n    #upper range: 170-180 for hue for color red\n    lower_red = (160, 100, 20)\n    upper_red = (179, 255, 255)\n    mask2 = cv2.inRange(hsv, lower_red, upper_red)\n\n    # Combine the masks to obtain the final mask\n    mask = mask1 + mask2\n\n    return mask\n\ndef draw_bounding_boxes(cv_image, mask, min_area=1000, max_area=10000): #min and max area determine size of detected objects to draw bounding boxes around\n    # Find contours in the mask\n    global USED\n    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)"
      }
    ]
  }
]